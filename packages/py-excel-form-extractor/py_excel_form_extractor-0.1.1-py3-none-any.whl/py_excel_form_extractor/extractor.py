
# python wrapper for package github.com/adhadse/excelFormExtractor/pkg/extractor within overall package extractor
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build --output=py_excel_form_extractor -vm=python3 ./pkg/extractor ./pkg/utils

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _extractor
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from extractor import extractor
# and then refer to everything using extractor. prefix
# packages imported by this package listed below:

from . import utils



# ---- Types ---

# Python type for slice []extractor.CellRange
class Slice_extractor_CellRange(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.Slice_extractor_CellRange_CTor()
			_extractor.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_extractor_CellRange.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		s = 'extractor.Slice_extractor_CellRange len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'extractor.Slice_extractor_CellRange([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _extractor.Slice_extractor_CellRange_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _extractor.Slice_extractor_CellRange_len(self.handle)
				return Slice_extractor_CellRange(handle=_extractor.Slice_extractor_CellRange_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return CellRange(handle=_extractor.Slice_extractor_CellRange_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_extractor.Slice_extractor_CellRange_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_extractor_CellRange.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = CellRange(handle=_extractor.Slice_extractor_CellRange_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_extractor.Slice_extractor_CellRange_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []extractor.ControlCotent
class Slice_extractor_ControlCotent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.Slice_extractor_ControlCotent_CTor()
			_extractor.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_extractor_ControlCotent.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		s = 'extractor.Slice_extractor_ControlCotent len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'extractor.Slice_extractor_ControlCotent([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _extractor.Slice_extractor_ControlCotent_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _extractor.Slice_extractor_ControlCotent_len(self.handle)
				return Slice_extractor_ControlCotent(handle=_extractor.Slice_extractor_ControlCotent_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ControlCotent(handle=_extractor.Slice_extractor_ControlCotent_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_extractor.Slice_extractor_ControlCotent_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_extractor_ControlCotent.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ControlCotent(handle=_extractor.Slice_extractor_ControlCotent_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_extractor.Slice_extractor_ControlCotent_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface extractor.SheetNameGetter
class SheetNameGetter(go.GoClass):
	"""Generic interface for structures with SheetName\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = 0
	def GetSheetName(self):
		"""GetSheetName() str"""
		return _extractor.extractor_SheetNameGetter_GetSheetName(self.handle)

# Python type for interface extractor.ValueExtractor
class ValueExtractor(go.GoClass):
	"""Add a method to handle value extraction based on criteria type\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = 0


# ---- Structs ---

# Python type for struct extractor.BuyerDetails
class BuyerDetails(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BuyerDetails_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SheetName = args[0]
			if "SheetName" in kwargs:
				self.SheetName = kwargs["SheetName"]
			if  1 < len(args):
				self.PartNumber = args[1]
			if "PartNumber" in kwargs:
				self.PartNumber = kwargs["PartNumber"]
			if  2 < len(args):
				self.PartDescription = args[2]
			if "PartDescription" in kwargs:
				self.PartDescription = kwargs["PartDescription"]
			if  3 < len(args):
				self.ClassificationOfItem = args[3]
			if "ClassificationOfItem" in kwargs:
				self.ClassificationOfItem = kwargs["ClassificationOfItem"]
			if  4 < len(args):
				self.ControlListClassificationNumber = args[4]
			if "ControlListClassificationNumber" in kwargs:
				self.ControlListClassificationNumber = kwargs["ControlListClassificationNumber"]
			if  5 < len(args):
				self.RFQ = args[5]
			if "RFQ" in kwargs:
				self.RFQ = kwargs["RFQ"]
			if  6 < len(args):
				self.BuildToPrint = args[6]
			if "BuildToPrint" in kwargs:
				self.BuildToPrint = kwargs["BuildToPrint"]
			if  7 < len(args):
				self.ManufacturedToSpecification = args[7]
			if "ManufacturedToSpecification" in kwargs:
				self.ManufacturedToSpecification = kwargs["ManufacturedToSpecification"]
			if  8 < len(args):
				self.OriginalEquipmentManufacturer = args[8]
			if "OriginalEquipmentManufacturer" in kwargs:
				self.OriginalEquipmentManufacturer = kwargs["OriginalEquipmentManufacturer"]
			if  9 < len(args):
				self.Modified = args[9]
			if "Modified" in kwargs:
				self.Modified = kwargs["Modified"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BuyerDetails{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BuyerDetails ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SheetName(self):
		return _extractor.extractor_BuyerDetails_SheetName_Get(self.handle)
	@SheetName.setter
	def SheetName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_SheetName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_SheetName_Set(self.handle, value)
	@property
	def PartNumber(self):
		return _extractor.extractor_BuyerDetails_PartNumber_Get(self.handle)
	@PartNumber.setter
	def PartNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_PartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_PartNumber_Set(self.handle, value)
	@property
	def PartDescription(self):
		return _extractor.extractor_BuyerDetails_PartDescription_Get(self.handle)
	@PartDescription.setter
	def PartDescription(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_PartDescription_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_PartDescription_Set(self.handle, value)
	@property
	def ClassificationOfItem(self):
		return _extractor.extractor_BuyerDetails_ClassificationOfItem_Get(self.handle)
	@ClassificationOfItem.setter
	def ClassificationOfItem(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_ClassificationOfItem_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_ClassificationOfItem_Set(self.handle, value)
	@property
	def ControlListClassificationNumber(self):
		return _extractor.extractor_BuyerDetails_ControlListClassificationNumber_Get(self.handle)
	@ControlListClassificationNumber.setter
	def ControlListClassificationNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_ControlListClassificationNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_ControlListClassificationNumber_Set(self.handle, value)
	@property
	def RFQ(self):
		return _extractor.extractor_BuyerDetails_RFQ_Get(self.handle)
	@RFQ.setter
	def RFQ(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_RFQ_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_RFQ_Set(self.handle, value)
	@property
	def BuildToPrint(self):
		return _extractor.extractor_BuyerDetails_BuildToPrint_Get(self.handle)
	@BuildToPrint.setter
	def BuildToPrint(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_BuildToPrint_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_BuildToPrint_Set(self.handle, value)
	@property
	def ManufacturedToSpecification(self):
		return _extractor.extractor_BuyerDetails_ManufacturedToSpecification_Get(self.handle)
	@ManufacturedToSpecification.setter
	def ManufacturedToSpecification(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_ManufacturedToSpecification_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_ManufacturedToSpecification_Set(self.handle, value)
	@property
	def OriginalEquipmentManufacturer(self):
		return _extractor.extractor_BuyerDetails_OriginalEquipmentManufacturer_Get(self.handle)
	@OriginalEquipmentManufacturer.setter
	def OriginalEquipmentManufacturer(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_OriginalEquipmentManufacturer_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_OriginalEquipmentManufacturer_Set(self.handle, value)
	@property
	def Modified(self):
		return _extractor.extractor_BuyerDetails_Modified_Get(self.handle)
	@Modified.setter
	def Modified(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BuyerDetails_Modified_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BuyerDetails_Modified_Set(self.handle, value)
	def GetSheetName(self):
		"""GetSheetName() str
		
		Add methods to both structs to implement SheetNameGetter
		"""
		return _extractor.extractor_BuyerDetails_GetSheetName(self.handle)

# Python type for struct extractor.DivideByZeroError
class DivideByZeroError(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_DivideByZeroError_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DivideByZeroError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DivideByZeroError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.SimpleValueExtractor
class SimpleValueExtractor(go.GoClass):
	"""Implement different extractors for different types of fields\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SimpleValueExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SimpleValueExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SimpleValueExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.TriColumnClfExtractor
class TriColumnClfExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_TriColumnClfExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriColumnClfExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriColumnClfExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.BoolClassificationCriteria
class BoolClassificationCriteria(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BoolClassificationCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.Offset = args[0]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
			if  1 < len(args):
				self.SearchTerms = args[1]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolClassificationCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolClassificationCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Offset(self):
		return _extractor.extractor_BoolClassificationCriteria_Offset_Get(self.handle)
	@Offset.setter
	def Offset(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BoolClassificationCriteria_Offset_Set(self.handle, value.handle)
		else:
			_extractor.extractor_BoolClassificationCriteria_Offset_Set(self.handle, value)
	@property
	def SearchTerms(self):
		return go.Slice_string(handle=_extractor.extractor_BoolClassificationCriteria_SearchTerms_Get(self.handle))
	@SearchTerms.setter
	def SearchTerms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_BoolClassificationCriteria_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.ControlCotent
class ControlCotent(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ControlCotent_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SheetName = args[0]
			if "SheetName" in kwargs:
				self.SheetName = kwargs["SheetName"]
			if  1 < len(args):
				self.ItemNum = args[1]
			if "ItemNum" in kwargs:
				self.ItemNum = kwargs["ItemNum"]
			if  2 < len(args):
				self.PartNumber = args[2]
			if "PartNumber" in kwargs:
				self.PartNumber = kwargs["PartNumber"]
			if  3 < len(args):
				self.ComponentManufacturerPartNumber = args[3]
			if "ComponentManufacturerPartNumber" in kwargs:
				self.ComponentManufacturerPartNumber = kwargs["ComponentManufacturerPartNumber"]
			if  4 < len(args):
				self.PartDescription = args[4]
			if "PartDescription" in kwargs:
				self.PartDescription = kwargs["PartDescription"]
			if  5 < len(args):
				self.ManufacturerOfComponent = args[5]
			if "ManufacturerOfComponent" in kwargs:
				self.ManufacturerOfComponent = kwargs["ManufacturerOfComponent"]
			if  6 < len(args):
				self.ExportRegulationCountry = args[6]
			if "ExportRegulationCountry" in kwargs:
				self.ExportRegulationCountry = kwargs["ExportRegulationCountry"]
			if  7 < len(args):
				self.DualControlListClfNum = args[7]
			if "DualControlListClfNum" in kwargs:
				self.DualControlListClfNum = kwargs["DualControlListClfNum"]
			if  8 < len(args):
				self.MilitaryControlListClfNum = args[8]
			if "MilitaryControlListClfNum" in kwargs:
				self.MilitaryControlListClfNum = kwargs["MilitaryControlListClfNum"]
			if  9 < len(args):
				self.IndicateLicenseApplication = args[9]
			if "IndicateLicenseApplication" in kwargs:
				self.IndicateLicenseApplication = kwargs["IndicateLicenseApplication"]
			if  10 < len(args):
				self.TopLevelDeliverableItem = args[10]
			if "TopLevelDeliverableItem" in kwargs:
				self.TopLevelDeliverableItem = kwargs["TopLevelDeliverableItem"]
			if  11 < len(args):
				self.USML_N = args[11]
			if "USML_N" in kwargs:
				self.USML_N = kwargs["USML_N"]
			if  12 < len(args):
				self.ECCN_N = args[12]
			if "ECCN_N" in kwargs:
				self.ECCN_N = kwargs["ECCN_N"]
			if  13 < len(args):
				self.US_EA_CONTENT_RATIO = args[13]
			if "US_EA_CONTENT_RATIO" in kwargs:
				self.US_EA_CONTENT_RATIO = kwargs["US_EA_CONTENT_RATIO"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ControlCotent{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ControlCotent ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SheetName(self):
		return _extractor.extractor_ControlCotent_SheetName_Get(self.handle)
	@SheetName.setter
	def SheetName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_SheetName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_SheetName_Set(self.handle, value)
	@property
	def ItemNum(self):
		return _extractor.extractor_ControlCotent_ItemNum_Get(self.handle)
	@ItemNum.setter
	def ItemNum(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ItemNum_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ItemNum_Set(self.handle, value)
	@property
	def PartNumber(self):
		return _extractor.extractor_ControlCotent_PartNumber_Get(self.handle)
	@PartNumber.setter
	def PartNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_PartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_PartNumber_Set(self.handle, value)
	@property
	def ComponentManufacturerPartNumber(self):
		return _extractor.extractor_ControlCotent_ComponentManufacturerPartNumber_Get(self.handle)
	@ComponentManufacturerPartNumber.setter
	def ComponentManufacturerPartNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ComponentManufacturerPartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ComponentManufacturerPartNumber_Set(self.handle, value)
	@property
	def PartDescription(self):
		return _extractor.extractor_ControlCotent_PartDescription_Get(self.handle)
	@PartDescription.setter
	def PartDescription(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_PartDescription_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_PartDescription_Set(self.handle, value)
	@property
	def ManufacturerOfComponent(self):
		return _extractor.extractor_ControlCotent_ManufacturerOfComponent_Get(self.handle)
	@ManufacturerOfComponent.setter
	def ManufacturerOfComponent(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ManufacturerOfComponent_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ManufacturerOfComponent_Set(self.handle, value)
	@property
	def ExportRegulationCountry(self):
		return _extractor.extractor_ControlCotent_ExportRegulationCountry_Get(self.handle)
	@ExportRegulationCountry.setter
	def ExportRegulationCountry(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ExportRegulationCountry_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ExportRegulationCountry_Set(self.handle, value)
	@property
	def DualControlListClfNum(self):
		return _extractor.extractor_ControlCotent_DualControlListClfNum_Get(self.handle)
	@DualControlListClfNum.setter
	def DualControlListClfNum(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_DualControlListClfNum_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_DualControlListClfNum_Set(self.handle, value)
	@property
	def MilitaryControlListClfNum(self):
		return _extractor.extractor_ControlCotent_MilitaryControlListClfNum_Get(self.handle)
	@MilitaryControlListClfNum.setter
	def MilitaryControlListClfNum(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_MilitaryControlListClfNum_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_MilitaryControlListClfNum_Set(self.handle, value)
	@property
	def IndicateLicenseApplication(self):
		return _extractor.extractor_ControlCotent_IndicateLicenseApplication_Get(self.handle)
	@IndicateLicenseApplication.setter
	def IndicateLicenseApplication(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_IndicateLicenseApplication_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_IndicateLicenseApplication_Set(self.handle, value)
	@property
	def TopLevelDeliverableItem(self):
		return _extractor.extractor_ControlCotent_TopLevelDeliverableItem_Get(self.handle)
	@TopLevelDeliverableItem.setter
	def TopLevelDeliverableItem(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_TopLevelDeliverableItem_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_TopLevelDeliverableItem_Set(self.handle, value)
	@property
	def USML_N(self):
		return _extractor.extractor_ControlCotent_USML_N_Get(self.handle)
	@USML_N.setter
	def USML_N(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_USML_N_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_USML_N_Set(self.handle, value)
	@property
	def ECCN_N(self):
		return _extractor.extractor_ControlCotent_ECCN_N_Get(self.handle)
	@ECCN_N.setter
	def ECCN_N(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_ECCN_N_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_ECCN_N_Set(self.handle, value)
	@property
	def US_EA_CONTENT_RATIO(self):
		return _extractor.extractor_ControlCotent_US_EA_CONTENT_RATIO_Get(self.handle)
	@US_EA_CONTENT_RATIO.setter
	def US_EA_CONTENT_RATIO(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ControlCotent_US_EA_CONTENT_RATIO_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ControlCotent_US_EA_CONTENT_RATIO_Set(self.handle, value)

# Python type for struct extractor.DualClassificationCriteria
class DualClassificationCriteria(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_DualClassificationCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.TYPE_1 = args[0]
			if "TYPE_1" in kwargs:
				self.TYPE_1 = kwargs["TYPE_1"]
			if  1 < len(args):
				self.TYPE_2 = args[1]
			if "TYPE_2" in kwargs:
				self.TYPE_2 = kwargs["TYPE_2"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualClassificationCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualClassificationCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def TYPE_1(self):
		return ClassificationCriteria(handle=_extractor.extractor_DualClassificationCriteria_TYPE_1_Get(self.handle))
	@TYPE_1.setter
	def TYPE_1(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_DualClassificationCriteria_TYPE_1_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TYPE_2(self):
		return ClassificationCriteria(handle=_extractor.extractor_DualClassificationCriteria_TYPE_2_Get(self.handle))
	@TYPE_2.setter
	def TYPE_2(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_DualClassificationCriteria_TYPE_2_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.DualColumnClfExtractor
class DualColumnClfExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_DualColumnClfExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualColumnClfExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.DualColumnClfExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.ProductDetails
class ProductDetails(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ProductDetails_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SheetName = args[0]
			if "SheetName" in kwargs:
				self.SheetName = kwargs["SheetName"]
			if  1 < len(args):
				self.SupplierPartNumber = args[1]
			if "SupplierPartNumber" in kwargs:
				self.SupplierPartNumber = kwargs["SupplierPartNumber"]
			if  2 < len(args):
				self.SupplierCompanyName = args[2]
			if "SupplierCompanyName" in kwargs:
				self.SupplierCompanyName = kwargs["SupplierCompanyName"]
			if  3 < len(args):
				self.SupplierFullAddress = args[3]
			if "SupplierFullAddress" in kwargs:
				self.SupplierFullAddress = kwargs["SupplierFullAddress"]
			if  4 < len(args):
				self.SupplierCountry = args[4]
			if "SupplierCountry" in kwargs:
				self.SupplierCountry = kwargs["SupplierCountry"]
			if  5 < len(args):
				self.SupplierCompanyNumber = args[5]
			if "SupplierCompanyNumber" in kwargs:
				self.SupplierCompanyNumber = kwargs["SupplierCompanyNumber"]
			if  6 < len(args):
				self.ManufacturerPartNumber = args[6]
			if "ManufacturerPartNumber" in kwargs:
				self.ManufacturerPartNumber = kwargs["ManufacturerPartNumber"]
			if  7 < len(args):
				self.ManufacturerCompanyName = args[7]
			if "ManufacturerCompanyName" in kwargs:
				self.ManufacturerCompanyName = kwargs["ManufacturerCompanyName"]
			if  8 < len(args):
				self.ManufacturerFullAddress = args[8]
			if "ManufacturerFullAddress" in kwargs:
				self.ManufacturerFullAddress = kwargs["ManufacturerFullAddress"]
			if  9 < len(args):
				self.ManufacturerCountry = args[9]
			if "ManufacturerCountry" in kwargs:
				self.ManufacturerCountry = kwargs["ManufacturerCountry"]
			if  10 < len(args):
				self.ManufacturerCompanyNumber = args[10]
			if "ManufacturerCompanyNumber" in kwargs:
				self.ManufacturerCompanyNumber = kwargs["ManufacturerCompanyNumber"]
			if  11 < len(args):
				self.CountryOfOrigin = args[11]
			if "CountryOfOrigin" in kwargs:
				self.CountryOfOrigin = kwargs["CountryOfOrigin"]
			if  12 < len(args):
				self.CustomsTariffCode = args[12]
			if "CustomsTariffCode" in kwargs:
				self.CustomsTariffCode = kwargs["CustomsTariffCode"]
			if  13 < len(args):
				self.ExportControlRegulated = args[13]
			if "ExportControlRegulated" in kwargs:
				self.ExportControlRegulated = kwargs["ExportControlRegulated"]
			if  14 < len(args):
				self.PartClassification = args[14]
			if "PartClassification" in kwargs:
				self.PartClassification = kwargs["PartClassification"]
			if  15 < len(args):
				self.ControlListClassificationNumber = args[15]
			if "ControlListClassificationNumber" in kwargs:
				self.ControlListClassificationNumber = kwargs["ControlListClassificationNumber"]
			if  16 < len(args):
				self.ThirdCountryControlledContent = args[16]
			if "ThirdCountryControlledContent" in kwargs:
				self.ThirdCountryControlledContent = kwargs["ThirdCountryControlledContent"]
			if  17 < len(args):
				self.EndUserStatementRequired = args[17]
			if "EndUserStatementRequired" in kwargs:
				self.EndUserStatementRequired = kwargs["EndUserStatementRequired"]
			if  18 < len(args):
				self.ExportLicenceShipmentRequired = args[18]
			if "ExportLicenceShipmentRequired" in kwargs:
				self.ExportLicenceShipmentRequired = kwargs["ExportLicenceShipmentRequired"]
			if  19 < len(args):
				self.ExportLicenceEndUserRequired = args[19]
			if "ExportLicenceEndUserRequired" in kwargs:
				self.ExportLicenceEndUserRequired = kwargs["ExportLicenceEndUserRequired"]
			if  20 < len(args):
				self.AdditionalExportDocsRequired = args[20]
			if "AdditionalExportDocsRequired" in kwargs:
				self.AdditionalExportDocsRequired = kwargs["AdditionalExportDocsRequired"]
			if  21 < len(args):
				self.TransferReexportConditions = args[21]
			if "TransferReexportConditions" in kwargs:
				self.TransferReexportConditions = kwargs["TransferReexportConditions"]
			if  22 < len(args):
				self.RepresentativeName = args[22]
			if "RepresentativeName" in kwargs:
				self.RepresentativeName = kwargs["RepresentativeName"]
			if  23 < len(args):
				self.RepresentativePosition = args[23]
			if "RepresentativePosition" in kwargs:
				self.RepresentativePosition = kwargs["RepresentativePosition"]
			if  24 < len(args):
				self.RepresentativeCompany = args[24]
			if "RepresentativeCompany" in kwargs:
				self.RepresentativeCompany = kwargs["RepresentativeCompany"]
			if  25 < len(args):
				self.RepresentativeSignature = args[25]
			if "RepresentativeSignature" in kwargs:
				self.RepresentativeSignature = kwargs["RepresentativeSignature"]
			if  26 < len(args):
				self.SupplierCompanySeal = args[26]
			if "SupplierCompanySeal" in kwargs:
				self.SupplierCompanySeal = kwargs["SupplierCompanySeal"]
			if  27 < len(args):
				self.SignatureDate = args[27]
			if "SignatureDate" in kwargs:
				self.SignatureDate = kwargs["SignatureDate"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ProductDetails{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ProductDetails ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SheetName(self):
		"""Sheet Metadata
		"""
		return _extractor.extractor_ProductDetails_SheetName_Get(self.handle)
	@SheetName.setter
	def SheetName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SheetName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SheetName_Set(self.handle, value)
	@property
	def SupplierPartNumber(self):
		"""Supplier Details
		"""
		return _extractor.extractor_ProductDetails_SupplierPartNumber_Get(self.handle)
	@SupplierPartNumber.setter
	def SupplierPartNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierPartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierPartNumber_Set(self.handle, value)
	@property
	def SupplierCompanyName(self):
		return _extractor.extractor_ProductDetails_SupplierCompanyName_Get(self.handle)
	@SupplierCompanyName.setter
	def SupplierCompanyName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCompanyName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCompanyName_Set(self.handle, value)
	@property
	def SupplierFullAddress(self):
		return _extractor.extractor_ProductDetails_SupplierFullAddress_Get(self.handle)
	@SupplierFullAddress.setter
	def SupplierFullAddress(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierFullAddress_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierFullAddress_Set(self.handle, value)
	@property
	def SupplierCountry(self):
		return _extractor.extractor_ProductDetails_SupplierCountry_Get(self.handle)
	@SupplierCountry.setter
	def SupplierCountry(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCountry_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCountry_Set(self.handle, value)
	@property
	def SupplierCompanyNumber(self):
		return _extractor.extractor_ProductDetails_SupplierCompanyNumber_Get(self.handle)
	@SupplierCompanyNumber.setter
	def SupplierCompanyNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCompanyNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCompanyNumber_Set(self.handle, value)
	@property
	def ManufacturerPartNumber(self):
		"""Manufacturer Details
		"""
		return _extractor.extractor_ProductDetails_ManufacturerPartNumber_Get(self.handle)
	@ManufacturerPartNumber.setter
	def ManufacturerPartNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerPartNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerPartNumber_Set(self.handle, value)
	@property
	def ManufacturerCompanyName(self):
		return _extractor.extractor_ProductDetails_ManufacturerCompanyName_Get(self.handle)
	@ManufacturerCompanyName.setter
	def ManufacturerCompanyName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerCompanyName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerCompanyName_Set(self.handle, value)
	@property
	def ManufacturerFullAddress(self):
		return _extractor.extractor_ProductDetails_ManufacturerFullAddress_Get(self.handle)
	@ManufacturerFullAddress.setter
	def ManufacturerFullAddress(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerFullAddress_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerFullAddress_Set(self.handle, value)
	@property
	def ManufacturerCountry(self):
		return _extractor.extractor_ProductDetails_ManufacturerCountry_Get(self.handle)
	@ManufacturerCountry.setter
	def ManufacturerCountry(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerCountry_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerCountry_Set(self.handle, value)
	@property
	def ManufacturerCompanyNumber(self):
		return _extractor.extractor_ProductDetails_ManufacturerCompanyNumber_Get(self.handle)
	@ManufacturerCompanyNumber.setter
	def ManufacturerCompanyNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ManufacturerCompanyNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ManufacturerCompanyNumber_Set(self.handle, value)
	@property
	def CountryOfOrigin(self):
		"""Product Details
		"""
		return _extractor.extractor_ProductDetails_CountryOfOrigin_Get(self.handle)
	@CountryOfOrigin.setter
	def CountryOfOrigin(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_CountryOfOrigin_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_CountryOfOrigin_Set(self.handle, value)
	@property
	def CustomsTariffCode(self):
		return _extractor.extractor_ProductDetails_CustomsTariffCode_Get(self.handle)
	@CustomsTariffCode.setter
	def CustomsTariffCode(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_CustomsTariffCode_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_CustomsTariffCode_Set(self.handle, value)
	@property
	def ExportControlRegulated(self):
		return _extractor.extractor_ProductDetails_ExportControlRegulated_Get(self.handle)
	@ExportControlRegulated.setter
	def ExportControlRegulated(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ExportControlRegulated_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ExportControlRegulated_Set(self.handle, value)
	@property
	def PartClassification(self):
		return _extractor.extractor_ProductDetails_PartClassification_Get(self.handle)
	@PartClassification.setter
	def PartClassification(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_PartClassification_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_PartClassification_Set(self.handle, value)
	@property
	def ControlListClassificationNumber(self):
		return _extractor.extractor_ProductDetails_ControlListClassificationNumber_Get(self.handle)
	@ControlListClassificationNumber.setter
	def ControlListClassificationNumber(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ControlListClassificationNumber_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ControlListClassificationNumber_Set(self.handle, value)
	@property
	def ThirdCountryControlledContent(self):
		return _extractor.extractor_ProductDetails_ThirdCountryControlledContent_Get(self.handle)
	@ThirdCountryControlledContent.setter
	def ThirdCountryControlledContent(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ThirdCountryControlledContent_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ThirdCountryControlledContent_Set(self.handle, value)
	@property
	def EndUserStatementRequired(self):
		return _extractor.extractor_ProductDetails_EndUserStatementRequired_Get(self.handle)
	@EndUserStatementRequired.setter
	def EndUserStatementRequired(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_EndUserStatementRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_EndUserStatementRequired_Set(self.handle, value)
	@property
	def ExportLicenceShipmentRequired(self):
		return _extractor.extractor_ProductDetails_ExportLicenceShipmentRequired_Get(self.handle)
	@ExportLicenceShipmentRequired.setter
	def ExportLicenceShipmentRequired(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ExportLicenceShipmentRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ExportLicenceShipmentRequired_Set(self.handle, value)
	@property
	def ExportLicenceEndUserRequired(self):
		return _extractor.extractor_ProductDetails_ExportLicenceEndUserRequired_Get(self.handle)
	@ExportLicenceEndUserRequired.setter
	def ExportLicenceEndUserRequired(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_ExportLicenceEndUserRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_ExportLicenceEndUserRequired_Set(self.handle, value)
	@property
	def AdditionalExportDocsRequired(self):
		return _extractor.extractor_ProductDetails_AdditionalExportDocsRequired_Get(self.handle)
	@AdditionalExportDocsRequired.setter
	def AdditionalExportDocsRequired(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_AdditionalExportDocsRequired_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_AdditionalExportDocsRequired_Set(self.handle, value)
	@property
	def TransferReexportConditions(self):
		"""Mandatory
		"""
		return _extractor.extractor_ProductDetails_TransferReexportConditions_Get(self.handle)
	@TransferReexportConditions.setter
	def TransferReexportConditions(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_TransferReexportConditions_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_TransferReexportConditions_Set(self.handle, value)
	@property
	def RepresentativeName(self):
		"""Supplier Representative
		"""
		return _extractor.extractor_ProductDetails_RepresentativeName_Get(self.handle)
	@RepresentativeName.setter
	def RepresentativeName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativeName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativeName_Set(self.handle, value)
	@property
	def RepresentativePosition(self):
		return _extractor.extractor_ProductDetails_RepresentativePosition_Get(self.handle)
	@RepresentativePosition.setter
	def RepresentativePosition(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativePosition_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativePosition_Set(self.handle, value)
	@property
	def RepresentativeCompany(self):
		return _extractor.extractor_ProductDetails_RepresentativeCompany_Get(self.handle)
	@RepresentativeCompany.setter
	def RepresentativeCompany(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativeCompany_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativeCompany_Set(self.handle, value)
	@property
	def RepresentativeSignature(self):
		return _extractor.extractor_ProductDetails_RepresentativeSignature_Get(self.handle)
	@RepresentativeSignature.setter
	def RepresentativeSignature(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_RepresentativeSignature_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_RepresentativeSignature_Set(self.handle, value)
	@property
	def SupplierCompanySeal(self):
		return _extractor.extractor_ProductDetails_SupplierCompanySeal_Get(self.handle)
	@SupplierCompanySeal.setter
	def SupplierCompanySeal(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SupplierCompanySeal_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SupplierCompanySeal_Set(self.handle, value)
	@property
	def SignatureDate(self):
		return _extractor.extractor_ProductDetails_SignatureDate_Get(self.handle)
	@SignatureDate.setter
	def SignatureDate(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ProductDetails_SignatureDate_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ProductDetails_SignatureDate_Set(self.handle, value)
	def GetSheetName(self):
		"""GetSheetName() str"""
		return _extractor.extractor_ProductDetails_GetSheetName(self.handle)

# Python type for struct extractor.Response
class Response(go.GoClass):
	"""Response struct for structured output\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_Response_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.Status = args[0]
			if "Status" in kwargs:
				self.Status = kwargs["Status"]
			if  1 < len(args):
				self.Message = args[1]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.Response{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.Response ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Status(self):
		return _extractor.extractor_Response_Status_Get(self.handle)
	@Status.setter
	def Status(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_Response_Status_Set(self.handle, value.handle)
		else:
			_extractor.extractor_Response_Status_Set(self.handle, value)
	@property
	def Message(self):
		return _extractor.extractor_Response_Message_Get(self.handle)
	@Message.setter
	def Message(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_Response_Message_Set(self.handle, value.handle)
		else:
			_extractor.extractor_Response_Message_Set(self.handle, value)
	@property
	def Data(self):
		return any(handle=_extractor.extractor_Response_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_Response_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.SECCFExtraction
class SECCFExtraction(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SECCFExtraction_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.BuyerDetails = args[0]
			if "BuyerDetails" in kwargs:
				self.BuyerDetails = kwargs["BuyerDetails"]
			if  1 < len(args):
				self.ProductDetails = args[1]
			if "ProductDetails" in kwargs:
				self.ProductDetails = kwargs["ProductDetails"]
			if  2 < len(args):
				self.ControlledContent = args[2]
			if "ControlledContent" in kwargs:
				self.ControlledContent = kwargs["ControlledContent"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SECCFExtraction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SECCFExtraction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def BuyerDetails(self):
		return BuyerDetails(handle=_extractor.extractor_SECCFExtraction_BuyerDetails_Get(self.handle))
	@BuyerDetails.setter
	def BuyerDetails(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SECCFExtraction_BuyerDetails_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ProductDetails(self):
		return ProductDetails(handle=_extractor.extractor_SECCFExtraction_ProductDetails_Get(self.handle))
	@ProductDetails.setter
	def ProductDetails(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SECCFExtraction_ProductDetails_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ControlledContent(self):
		return Slice_extractor_ControlCotent(handle=_extractor.extractor_SECCFExtraction_ControlledContent_Get(self.handle))
	@ControlledContent.setter
	def ControlledContent(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SECCFExtraction_ControlledContent_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.SheetNotFoundError
class SheetNotFoundError(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SheetNotFoundError_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SheetNotFoundError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SheetNotFoundError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Error(self):
		"""Error() str"""
		return _extractor.extractor_SheetNotFoundError_Error(self.handle)

# Python type for struct extractor.SearchCriteria
class SearchCriteria(go.GoClass):
	"""SearchCriteria defines what to look for and where\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_SearchCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.SearchTerms = args[0]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
			if  1 < len(args):
				self.CellRanges = args[1]
			if "CellRanges" in kwargs:
				self.CellRanges = kwargs["CellRanges"]
			if  2 < len(args):
				self.DualColumnCheckBoxClf = args[2]
			if "DualColumnCheckBoxClf" in kwargs:
				self.DualColumnCheckBoxClf = kwargs["DualColumnCheckBoxClf"]
			if  3 < len(args):
				self.DualColumnClfCriteria = args[3]
			if "DualColumnClfCriteria" in kwargs:
				self.DualColumnClfCriteria = kwargs["DualColumnClfCriteria"]
			if  4 < len(args):
				self.TriColumnCheckBoxClf = args[4]
			if "TriColumnCheckBoxClf" in kwargs:
				self.TriColumnCheckBoxClf = kwargs["TriColumnCheckBoxClf"]
			if  5 < len(args):
				self.TriColumnClfCriteria = args[5]
			if "TriColumnClfCriteria" in kwargs:
				self.TriColumnClfCriteria = kwargs["TriColumnClfCriteria"]
			if  6 < len(args):
				self.BoolCheckBox = args[6]
			if "BoolCheckBox" in kwargs:
				self.BoolCheckBox = kwargs["BoolCheckBox"]
			if  7 < len(args):
				self.BoolClfCriteria = args[7]
			if "BoolClfCriteria" in kwargs:
				self.BoolClfCriteria = kwargs["BoolClfCriteria"]
			if  8 < len(args):
				self.Offset = args[8]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SearchCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.SearchCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SearchTerms(self):
		return go.Slice_string(handle=_extractor.extractor_SearchCriteria_SearchTerms_Get(self.handle))
	@SearchTerms.setter
	def SearchTerms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CellRanges(self):
		return Slice_extractor_CellRange(handle=_extractor.extractor_SearchCriteria_CellRanges_Get(self.handle))
	@CellRanges.setter
	def CellRanges(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_CellRanges_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DualColumnCheckBoxClf(self):
		return _extractor.extractor_SearchCriteria_DualColumnCheckBoxClf_Get(self.handle)
	@DualColumnCheckBoxClf.setter
	def DualColumnCheckBoxClf(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_DualColumnCheckBoxClf_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_DualColumnCheckBoxClf_Set(self.handle, value)
	@property
	def DualColumnClfCriteria(self):
		return DualClassificationCriteria(handle=_extractor.extractor_SearchCriteria_DualColumnClfCriteria_Get(self.handle))
	@DualColumnClfCriteria.setter
	def DualColumnClfCriteria(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_DualColumnClfCriteria_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TriColumnCheckBoxClf(self):
		return _extractor.extractor_SearchCriteria_TriColumnCheckBoxClf_Get(self.handle)
	@TriColumnCheckBoxClf.setter
	def TriColumnCheckBoxClf(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_TriColumnCheckBoxClf_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_TriColumnCheckBoxClf_Set(self.handle, value)
	@property
	def TriColumnClfCriteria(self):
		return TriClassificationCritera(handle=_extractor.extractor_SearchCriteria_TriColumnClfCriteria_Get(self.handle))
	@TriColumnClfCriteria.setter
	def TriColumnClfCriteria(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_TriColumnClfCriteria_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BoolCheckBox(self):
		return _extractor.extractor_SearchCriteria_BoolCheckBox_Get(self.handle)
	@BoolCheckBox.setter
	def BoolCheckBox(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_BoolCheckBox_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_BoolCheckBox_Set(self.handle, value)
	@property
	def BoolClfCriteria(self):
		return BoolClassificationCriteria(handle=_extractor.extractor_SearchCriteria_BoolClfCriteria_Get(self.handle))
	@BoolClfCriteria.setter
	def BoolClfCriteria(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_BoolClfCriteria_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Offset(self):
		return _extractor.extractor_SearchCriteria_Offset_Get(self.handle)
	@Offset.setter
	def Offset(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_SearchCriteria_Offset_Set(self.handle, value.handle)
		else:
			_extractor.extractor_SearchCriteria_Offset_Set(self.handle, value)

# Python type for struct extractor.TriClassificationCritera
class TriClassificationCritera(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_TriClassificationCritera_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.TYPE_1 = args[0]
			if "TYPE_1" in kwargs:
				self.TYPE_1 = kwargs["TYPE_1"]
			if  1 < len(args):
				self.TYPE_2 = args[1]
			if "TYPE_2" in kwargs:
				self.TYPE_2 = kwargs["TYPE_2"]
			if  2 < len(args):
				self.TYPE_3 = args[2]
			if "TYPE_3" in kwargs:
				self.TYPE_3 = kwargs["TYPE_3"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriClassificationCritera{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.TriClassificationCritera ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def TYPE_1(self):
		return ClassificationCriteria(handle=_extractor.extractor_TriClassificationCritera_TYPE_1_Get(self.handle))
	@TYPE_1.setter
	def TYPE_1(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_TriClassificationCritera_TYPE_1_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TYPE_2(self):
		return ClassificationCriteria(handle=_extractor.extractor_TriClassificationCritera_TYPE_2_Get(self.handle))
	@TYPE_2.setter
	def TYPE_2(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_TriClassificationCritera_TYPE_2_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TYPE_3(self):
		return ClassificationCriteria(handle=_extractor.extractor_TriClassificationCritera_TYPE_3_Get(self.handle))
	@TYPE_3.setter
	def TYPE_3(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_TriClassificationCritera_TYPE_3_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct extractor.BoolCheckBoxExtractor
class BoolCheckBoxExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_BoolCheckBoxExtractor_CTor()
			_extractor.IncRef(self.handle)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolCheckBoxExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.BoolCheckBoxExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct extractor.CellRange
class CellRange(go.GoClass):
	"""CellRange represents an Excel cell range\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_CellRange_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.StartCell = args[0]
			if "StartCell" in kwargs:
				self.StartCell = kwargs["StartCell"]
			if  1 < len(args):
				self.EndCell = args[1]
			if "EndCell" in kwargs:
				self.EndCell = kwargs["EndCell"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.CellRange{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.CellRange ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def StartCell(self):
		return _extractor.extractor_CellRange_StartCell_Get(self.handle)
	@StartCell.setter
	def StartCell(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_CellRange_StartCell_Set(self.handle, value.handle)
		else:
			_extractor.extractor_CellRange_StartCell_Set(self.handle, value)
	@property
	def EndCell(self):
		return _extractor.extractor_CellRange_EndCell_Get(self.handle)
	@EndCell.setter
	def EndCell(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_CellRange_EndCell_Set(self.handle, value.handle)
		else:
			_extractor.extractor_CellRange_EndCell_Set(self.handle, value)

# Python type for struct extractor.ClassificationCriteria
class ClassificationCriteria(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ClassificationCriteria_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.Label = args[0]
			if "Label" in kwargs:
				self.Label = kwargs["Label"]
			if  1 < len(args):
				self.SearchTerms = args[1]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
			if  2 < len(args):
				self.Offset = args[2]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ClassificationCriteria{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ClassificationCriteria ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Label(self):
		return _extractor.extractor_ClassificationCriteria_Label_Get(self.handle)
	@Label.setter
	def Label(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ClassificationCriteria_Label_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ClassificationCriteria_Label_Set(self.handle, value)
	@property
	def SearchTerms(self):
		return go.Slice_string(handle=_extractor.extractor_ClassificationCriteria_SearchTerms_Get(self.handle))
	@SearchTerms.setter
	def SearchTerms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ClassificationCriteria_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Offset(self):
		return _extractor.extractor_ClassificationCriteria_Offset_Get(self.handle)
	@Offset.setter
	def Offset(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ClassificationCriteria_Offset_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ClassificationCriteria_Offset_Set(self.handle, value)

# Python type for struct extractor.ColumnMapping
class ColumnMapping(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ColumnMapping_CTor()
			_extractor.IncRef(self.handle)
			if  0 < len(args):
				self.FieldName = args[0]
			if "FieldName" in kwargs:
				self.FieldName = kwargs["FieldName"]
			if  1 < len(args):
				self.SearchTerms = args[1]
			if "SearchTerms" in kwargs:
				self.SearchTerms = kwargs["SearchTerms"]
			if  2 < len(args):
				self.FoundColumn = args[2]
			if "FoundColumn" in kwargs:
				self.FoundColumn = kwargs["FoundColumn"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ColumnMapping{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ColumnMapping ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FieldName(self):
		return _extractor.extractor_ColumnMapping_FieldName_Get(self.handle)
	@FieldName.setter
	def FieldName(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ColumnMapping_FieldName_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ColumnMapping_FieldName_Set(self.handle, value)
	@property
	def SearchTerms(self):
		return go.Slice_string(handle=_extractor.extractor_ColumnMapping_SearchTerms_Get(self.handle))
	@SearchTerms.setter
	def SearchTerms(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ColumnMapping_SearchTerms_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def FoundColumn(self):
		return _extractor.extractor_ColumnMapping_FoundColumn_Get(self.handle)
	@FoundColumn.setter
	def FoundColumn(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ColumnMapping_FoundColumn_Set(self.handle, value.handle)
		else:
			_extractor.extractor_ColumnMapping_FoundColumn_Set(self.handle, value)

# Python type for struct extractor.ExcelExtractor
class ExcelExtractor(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_ExcelExtractor_CTor()
			_extractor.IncRef(self.handle)
			if  2 < len(args):
				self.Extraction = args[2]
			if "Extraction" in kwargs:
				self.Extraction = kwargs["Extraction"]
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ExcelExtractor{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'extractor.ExcelExtractor ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Extraction(self):
		return SECCFExtraction(handle=_extractor.extractor_ExcelExtractor_Extraction_Get(self.handle))
	@Extraction.setter
	def Extraction(self, value):
		if isinstance(value, go.GoClass):
			_extractor.extractor_ExcelExtractor_Extraction_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ReplaceCompanyNames(self, items):
		"""ReplaceCompanyNames([]str items) []str"""
		return go.Slice_string(handle=_extractor.extractor_ExcelExtractor_ReplaceCompanyNames(self.handle, items.handle))
	def GetCellValue(self, cellRange, sheetName):
		"""GetCellValue(object cellRange, str sheetName) str, str"""
		return _extractor.extractor_ExcelExtractor_GetCellValue(self.handle, cellRange.handle, sheetName)
	def ToJson(self):
		"""ToJson() str"""
		return _extractor.extractor_ExcelExtractor_ToJson(self.handle)
	def ReadFormControls(self, goRun=False):
		"""ReadFormControls() """
		_extractor.extractor_ExcelExtractor_ReadFormControls(self.handle, goRun)
	def Extract(self):
		"""Extract() object"""
		return SECCFExtraction(handle=_extractor.extractor_ExcelExtractor_Extract(self.handle))
	def Close(self):
		"""Close() str"""
		return _extractor.extractor_ExcelExtractor_Close(self.handle)


# ---- Slices ---

# Python type for slice extractor.CompanyNameList
class CompanyNameList(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_extractor.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_extractor.IncRef(self.handle)
		else:
			self.handle = _extractor.extractor_CompanyNameList_CTor()
			_extractor.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('extractor_CompanyNameList.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_extractor.DecRef(self.handle)
	def __str__(self):
		s = 'extractor.extractor_CompanyNameList len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'extractor.extractor_CompanyNameList([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _extractor.extractor_CompanyNameList_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _extractor.extractor_CompanyNameList_len(self.handle)
				return CompanyNameList(handle=_extractor.extractor_CompanyNameList_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _extractor.extractor_CompanyNameList_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_extractor.extractor_CompanyNameList_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('extractor_CompanyNameList.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _extractor.extractor_CompanyNameList_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_extractor.extractor_CompanyNameList_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


# ---- Maps ---


# ---- Constructors ---
def MakeSECCFExtractor(filePath, companyNames):
	"""MakeSECCFExtractor(str filePath, []str companyNames) object, str"""
	return ExcelExtractor(handle=_extractor.extractor_MakeSECCFExtractor(filePath, companyNames.handle))


# ---- Functions ---


