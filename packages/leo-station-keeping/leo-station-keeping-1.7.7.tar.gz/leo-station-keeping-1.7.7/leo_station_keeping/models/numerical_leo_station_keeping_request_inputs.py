# coding: utf-8

"""
    LEO Station Keeping API

    This mission allows to estimate the cost of station keeping maneuvers needed  to counter the effects of the atmospheric drag on the semi-major axis of a  spacecraft in low Earth orbit (up to an altitude of 1000 km).   <b>CHANGELOG</b> <ul>   <li><b>1.7.7</b> - 2024-07-11 - Add descriptions, required tags and default values, better handles user input errors</li>   <li><b>1.7.0</b> - 2024-07-11 - Add space weather data source choice to <b>NRLMSISE00AtmosphericModel</b> schema</li>   <li><b>1.6.0</b> - 2024-07-11 - Add <b>Battery</b> schema to inputs of <b>NumericalLeoStationKeepingRequest</b> schema</li>, update SolarArray efficiency description, added SYSTEM output ephemerides type, corrected <b>onBoardAveragePower</b> description</li>   <li><b>1.5.0</b> - 2024-07-08 - Replace custom earth potential data with <b>customEarthPotentialConfiguration</b> in <b>EarthPotentialPerturbation</b> schema</li>   <li><b>1.4.0</b> - 2024-07-08 - Add <b>efficiency</b> to <b>SolarArray</b> schema</li>   <li><b>1.3.0</b> - 2024-07-08 - Replace <b>missionDateTime</b> by <b>initialDate</b> in <b>NumericalLeoStationKeepingRequest</b> schema</li>    <li><b>1.2.0</b> - 2024-07-03 - Add <b>atmosphericModel</b> to <b>DragPerturbation</b> schema</li>   <li><b>1.1.0</b> - 2024-06-27 - Map custom maneuvering strategy</li>   <li><b>1.0.0</b> - 2024-06-07 - First version of the API</li> </ul> 

    The version of the OpenAPI document: 1.7.7
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from leo_station_keeping.models.battery import Battery
from leo_station_keeping.models.custom_maneuvering_strategy import CustomManeuveringStrategy
from leo_station_keeping.models.orbit import Orbit
from leo_station_keeping.models.perturbation import Perturbation
from leo_station_keeping.models.platform import Platform
from leo_station_keeping.models.propulsion_system import PropulsionSystem
from leo_station_keeping.models.spacecraft_geometry import SpacecraftGeometry
from leo_station_keeping.models.tolerance import Tolerance
from typing import Optional, Set
from typing_extensions import Self

class NumericalLeoStationKeepingRequestInputs(BaseModel):
    """
    The computation inputs. 
    """ # noqa: E501
    mission_date_time: Optional[StrictStr] = Field(default=None, description="Use `initialDate` instead", alias="missionDateTime")
    initial_date: Optional[datetime] = Field(default=None, description="The mission initial date and time.  This is the date and time at which the mission starts (overrides the orbit date/time if set). ", alias="initialDate")
    maximum_duration: StrictInt = Field(description="The simulation maximum duration (in days).  This is the maximum duration expected for the mission. If the target is not reached after that duration,  the mission would fail. This parameter is used to avoid unpredicted long simulation. ", alias="maximumDuration")
    initial_orbit: Orbit = Field(alias="initialOrbit")
    spacecraft_geometry: SpacecraftGeometry = Field(alias="spacecraftGeometry")
    platform: Platform
    propulsion_system: PropulsionSystem = Field(alias="propulsionSystem")
    battery: Optional[Battery] = None
    perturbations: List[Perturbation] = Field(description="The perturbations to apply to the orbit propagation. Must contain at least the atmospheric drag perturbation")
    tolerance: Tolerance
    custom_maneuvering_strategy: Optional[CustomManeuveringStrategy] = Field(default=None, alias="customManeuveringStrategy")
    __properties: ClassVar[List[str]] = ["missionDateTime", "initialDate", "maximumDuration", "initialOrbit", "spacecraftGeometry", "platform", "propulsionSystem", "battery", "perturbations", "tolerance", "customManeuveringStrategy"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NumericalLeoStationKeepingRequestInputs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of initial_orbit
        if self.initial_orbit:
            _dict['initialOrbit'] = self.initial_orbit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of spacecraft_geometry
        if self.spacecraft_geometry:
            _dict['spacecraftGeometry'] = self.spacecraft_geometry.to_dict()
        # override the default output from pydantic by calling `to_dict()` of platform
        if self.platform:
            _dict['platform'] = self.platform.to_dict()
        # override the default output from pydantic by calling `to_dict()` of propulsion_system
        if self.propulsion_system:
            _dict['propulsionSystem'] = self.propulsion_system.to_dict()
        # override the default output from pydantic by calling `to_dict()` of battery
        if self.battery:
            _dict['battery'] = self.battery.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in perturbations (list)
        _items = []
        if self.perturbations:
            for _item_perturbations in self.perturbations:
                if _item_perturbations:
                    _items.append(_item_perturbations.to_dict())
            _dict['perturbations'] = _items
        # override the default output from pydantic by calling `to_dict()` of tolerance
        if self.tolerance:
            _dict['tolerance'] = self.tolerance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of custom_maneuvering_strategy
        if self.custom_maneuvering_strategy:
            _dict['customManeuveringStrategy'] = self.custom_maneuvering_strategy.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NumericalLeoStationKeepingRequestInputs from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "missionDateTime": obj.get("missionDateTime"),
            "initialDate": obj.get("initialDate"),
            "maximumDuration": obj.get("maximumDuration"),
            "initialOrbit": Orbit.from_dict(obj["initialOrbit"]) if obj.get("initialOrbit") is not None else None,
            "spacecraftGeometry": SpacecraftGeometry.from_dict(obj["spacecraftGeometry"]) if obj.get("spacecraftGeometry") is not None else None,
            "platform": Platform.from_dict(obj["platform"]) if obj.get("platform") is not None else None,
            "propulsionSystem": PropulsionSystem.from_dict(obj["propulsionSystem"]) if obj.get("propulsionSystem") is not None else None,
            "battery": Battery.from_dict(obj["battery"]) if obj.get("battery") is not None else None,
            "perturbations": [Perturbation.from_dict(_item) for _item in obj["perturbations"]] if obj.get("perturbations") is not None else None,
            "tolerance": Tolerance.from_dict(obj["tolerance"]) if obj.get("tolerance") is not None else None,
            "customManeuveringStrategy": CustomManeuveringStrategy.from_dict(obj["customManeuveringStrategy"]) if obj.get("customManeuveringStrategy") is not None else None
        })
        return _obj


