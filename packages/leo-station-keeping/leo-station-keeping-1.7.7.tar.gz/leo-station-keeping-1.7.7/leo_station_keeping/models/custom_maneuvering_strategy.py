# coding: utf-8

"""
    LEO Station Keeping API

    This mission allows to estimate the cost of station keeping maneuvers needed  to counter the effects of the atmospheric drag on the semi-major axis of a  spacecraft in low Earth orbit (up to an altitude of 1000 km).   <b>CHANGELOG</b> <ul>   <li><b>1.7.7</b> - 2024-07-11 - Add descriptions, required tags and default values, better handles user input errors</li>   <li><b>1.7.0</b> - 2024-07-11 - Add space weather data source choice to <b>NRLMSISE00AtmosphericModel</b> schema</li>   <li><b>1.6.0</b> - 2024-07-11 - Add <b>Battery</b> schema to inputs of <b>NumericalLeoStationKeepingRequest</b> schema</li>, update SolarArray efficiency description, added SYSTEM output ephemerides type, corrected <b>onBoardAveragePower</b> description</li>   <li><b>1.5.0</b> - 2024-07-08 - Replace custom earth potential data with <b>customEarthPotentialConfiguration</b> in <b>EarthPotentialPerturbation</b> schema</li>   <li><b>1.4.0</b> - 2024-07-08 - Add <b>efficiency</b> to <b>SolarArray</b> schema</li>   <li><b>1.3.0</b> - 2024-07-08 - Replace <b>missionDateTime</b> by <b>initialDate</b> in <b>NumericalLeoStationKeepingRequest</b> schema</li>    <li><b>1.2.0</b> - 2024-07-03 - Add <b>atmosphericModel</b> to <b>DragPerturbation</b> schema</li>   <li><b>1.1.0</b> - 2024-06-27 - Map custom maneuvering strategy</li>   <li><b>1.0.0</b> - 2024-06-07 - First version of the API</li> </ul> 

    The version of the OpenAPI document: 1.7.7
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from leo_station_keeping.models.custom_thrust_arcs_position import CustomThrustArcsPosition
from leo_station_keeping.models.thrust_arc_definition import ThrustArcDefinition
from leo_station_keeping.models.thrust_arcs_position import ThrustArcsPosition
from typing import Optional, Set
from typing_extensions import Self

class CustomManeuveringStrategy(BaseModel):
    """
    A custom maneuvering strategy. Depending on the orbital elements changed in the  mission (semi-major axis, eccentricity, inclination, RAAN or argument of latitude), the user can change the number of thrust arcs (1 or 2),  their position, and the thrust pattern.  This custom mode is taken into account only in case of low thrust maneuver,  for impulsive maneuver the maneuver strategy is automatically determined to achieve the requested maneuver depending on perigee argument of orbit. 
    """ # noqa: E501
    thrust_arcs_number: Annotated[int, Field(le=2, strict=True, ge=1)] = Field(description="The number of thrust arcs", alias="thrustArcsNumber")
    thrust_arcs_position: ThrustArcsPosition = Field(alias="thrustArcsPosition")
    custom_thrust_arcs_position: Optional[CustomThrustArcsPosition] = Field(default=None, alias="customThrustArcsPosition")
    number_of_thrust_orbits: StrictInt = Field(description="The number of thrust orbits", alias="numberOfThrustOrbits")
    number_of_rest_orbits: StrictInt = Field(description="The number of rest orbits", alias="numberOfRestOrbits")
    number_of_shift_orbits: StrictInt = Field(description="The number of shift orbits", alias="numberOfShiftOrbits")
    thrust_arc_definition: ThrustArcDefinition = Field(alias="thrustArcDefinition")
    thrust_arc_mean_longitude_argument: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Use custom thrust arc position instead ", alias="thrustArcMeanLongitudeArgument")
    stop_thrusting_during_eclipse: Optional[StrictBool] = Field(default=False, description="Indicates whether the spacecraft has to stop thrusting during eclipse", alias="stopThrustingDuringEclipse")
    dynamic_duty_cycle: Optional[StrictBool] = Field(default=False, description="This option allows to update the duty cycle during the simulation", alias="dynamicDutyCycle")
    __properties: ClassVar[List[str]] = ["thrustArcsNumber", "thrustArcsPosition", "customThrustArcsPosition", "numberOfThrustOrbits", "numberOfRestOrbits", "numberOfShiftOrbits", "thrustArcDefinition", "thrustArcMeanLongitudeArgument", "stopThrustingDuringEclipse", "dynamicDutyCycle"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CustomManeuveringStrategy from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of custom_thrust_arcs_position
        if self.custom_thrust_arcs_position:
            _dict['customThrustArcsPosition'] = self.custom_thrust_arcs_position.to_dict()
        # override the default output from pydantic by calling `to_dict()` of thrust_arc_definition
        if self.thrust_arc_definition:
            _dict['thrustArcDefinition'] = self.thrust_arc_definition.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CustomManeuveringStrategy from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "thrustArcsNumber": obj.get("thrustArcsNumber"),
            "thrustArcsPosition": obj.get("thrustArcsPosition"),
            "customThrustArcsPosition": CustomThrustArcsPosition.from_dict(obj["customThrustArcsPosition"]) if obj.get("customThrustArcsPosition") is not None else None,
            "numberOfThrustOrbits": obj.get("numberOfThrustOrbits"),
            "numberOfRestOrbits": obj.get("numberOfRestOrbits"),
            "numberOfShiftOrbits": obj.get("numberOfShiftOrbits"),
            "thrustArcDefinition": ThrustArcDefinition.from_dict(obj["thrustArcDefinition"]) if obj.get("thrustArcDefinition") is not None else None,
            "thrustArcMeanLongitudeArgument": obj.get("thrustArcMeanLongitudeArgument"),
            "stopThrustingDuringEclipse": obj.get("stopThrustingDuringEclipse") if obj.get("stopThrustingDuringEclipse") is not None else False,
            "dynamicDutyCycle": obj.get("dynamicDutyCycle") if obj.get("dynamicDutyCycle") is not None else False
        })
        return _obj


