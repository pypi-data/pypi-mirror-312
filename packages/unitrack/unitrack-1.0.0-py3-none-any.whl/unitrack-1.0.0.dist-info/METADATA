Metadata-Version: 2.1
Name: unitrack
Version: 1.0.0
Summary: Toolkit for object tracking in computer vision applications.
Author-email: Kurt Stolle <k.h.w.stolle@gmail.com>
Keywords: ai,computer vision,deep learning
Classifier: Development Status :: 4 - Beta
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: Implementation :: CPython
Requires-Python: >=3.12
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: unipercept
Provides-Extra: dev
Requires-Dist: bandit[toml]; extra == "dev"
Requires-Dist: check-manifest; extra == "dev"
Requires-Dist: ruff; extra == "dev"
Requires-Dist: pre-commit; extra == "dev"
Requires-Dist: pygrep; extra == "dev"
Requires-Dist: isort>=5.13.2; extra == "dev"
Requires-Dist: refurb; extra == "dev"
Requires-Dist: pylint>=3.0.3; extra == "dev"
Requires-Dist: pylint_junit; extra == "dev"
Requires-Dist: autoflake; extra == "dev"
Requires-Dist: pydocstyle; extra == "dev"
Requires-Dist: mccabe; extra == "dev"
Requires-Dist: hypothesis>=6.100.1; extra == "dev"
Requires-Dist: pytest>=8.1.1; extra == "dev"
Requires-Dist: pytest-sugar; extra == "dev"
Requires-Dist: pytest-xdist; extra == "dev"
Requires-Dist: pytest-benchmark; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: pytest-mock; extra == "dev"
Requires-Dist: pytest-runner; extra == "dev"
Requires-Dist: pytest-github-actions-annotate-failures; extra == "dev"

# Unified Tracking in PyTorch

This package is a robust object tracking framework for PyTorch. 
t facilitates multi-stage and cascaded tracking algorithms under various modular configurations and assignment algorithms. 
This open-source implementation is designed to facilitate research in computer vision and machine learning.

## Installation

Ensure your environment meets the following requirements:

- `python >= 3.11`
- `torch >= 2.2`

Install via PyPI using the following command:

```bash
pip install unitrack
```

## Usage

The following example demonstrates object tracking across a sequence with detections that have `category` and `position` fields. 
This script tracks objects, updates internal state buffers for each frame, and prints the assigned IDs.

```python3
import unitrack

# Detections from 10 video frames having fields `category` and `position`.
frames = [
    {
        "category": torch.ones(1 + frame * 2, dtype=torch.long),
        "position": (torch.arange(1 + frame * 2, dtype=dtype)).unsqueeze(1),
    }
    for frame in range(0, 10)
]

# Multi-stage tracker with two value fields that map the detections' data
# to keys `pos_key` and `key_cat`, where the association stage calculates 
# the Euclidean distance of the positions between frames and subsequently 
# performs a Jonker-Volgenant assignment using the resulting cost matrix
tracker = unitrack.MultiStageTracker(
    fields={
        "key_pos": unitrack.fields.Value(key="category"),
        "key_cat": unitrack.fields.Value(key="position"),
    },
    stages=[unitrack.stages.Association(cost=costs.Distance("key_pos"), assignment=unitrack.assignment.Jonker(10))],
)

# Tracking memory that stores the relevant information to compute the
# cost matrix in the module buffers. States are observed at each frame,
# where in this case no state prediction is performed.
memory = unitrack.TrackletMemory(
    states={
        "key_pos": unitrack.states.Value(dtype),
        "key_cat": unitrack.states.Value(dtype=torch.long),
    }
)

# Iterate over frames, performing state observation, tracking and state
# propagation at every step.
for frame, detections in enumerate(frames):
    # Create a context object storing (meta)data about the current
    # frame, i.e. feature maps, instance detections and the frame number.
    ctx = unitrack.Context(None, detections, frame=frame)
    
    # Observe the states in memory. This can be extended to 
    # run a prediction step (e.g. Kalman filter) 
    obs = memory.observe()
    
    # Assign detections in the current frame to observations of
    # the state memory, giving an updated observations object
    # and the remaining unassigned new detections.
    obs, new = tracker(ctx, obs)
    
    # Update the tracking memory. Buffers are updated to match
    # the data in `obs`, and new IDs are generated for detection
    # data that could not be assigned in `new`. The returned tensor
    # contains ordered tracklet IDs for the detections assigned
    # to the frame context `ctx`.
    ids = tracks.update(ctx, obs, new)

    print(f"Assigned tracklet IDs {ids.tolist()} @ frame {frame}")
```

## Citation

If you use this package in your research, please cite [our paper](https://arxiv.org/abs/2303.01991) as

```bib
@inproceedings{stolle2023unitrack,
    title={Unified Perception: Efficient Depth-Aware Video Panoptic Segmentation with Minimal Annotation Costs},
    author={Kurt Stolle and Gijs Dubbelman},
    booktitle={IROS},
    year={2023}
}
```

