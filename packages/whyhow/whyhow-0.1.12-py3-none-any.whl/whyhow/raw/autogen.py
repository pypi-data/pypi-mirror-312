# generated by datamodel-codegen:
#   filename:  http://localhost:8000/openapi.json
#   timestamp: 2024-10-09T09:33:01+00:00
#   version: v0.3.44

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class APIKeyOutModel(BaseModel):
    api_key: Annotated[
        str, Field(description="User's active api key", title="Api Key")
    ]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]


class Content(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Content of the chunk", min_length=1, title="Content"
        ),
    ]


class Content1(RootModel[Dict[str, Any]]):
    root: Annotated[
        Dict[str, Any],
        Field(
            description="Content of the chunk", min_length=1, title="Content"
        ),
    ]


class AddChunkModel(BaseModel):
    content: Annotated[
        Union[Content, Content1],
        Field(description="Content of the chunk", title="Content"),
    ]
    user_metadata: Annotated[
        Optional[
            Dict[
                str,
                Union[
                    str, int, bool, float, List[Union[str, int, bool, float]]
                ],
            ]
        ],
        Field(
            None, description="User defined metadata", title="User Metadata"
        ),
    ]
    tags: Annotated[Optional[List[str]], Field(None, title="Tags")]


class AddChunksModel(BaseModel):
    chunks: Annotated[List[AddChunkModel], Field(title="Chunks")]


class BYOAzureOpenAIMetadata(BaseModel):
    api_version: Annotated[Optional[str], Field(None, title="Api Version")]
    azure_endpoint: Annotated[
        Optional[str], Field(None, title="Azure Endpoint")
    ]
    language_model_name: Annotated[
        Optional[str], Field(None, title="Language Model Name")
    ]
    embedding_name: Annotated[
        Optional[str], Field(None, title="Embedding Name")
    ]


class BYOOpenAIMetadata(BaseModel):
    language_model_name: Annotated[
        Optional[str], Field(None, title="Language Model Name")
    ]
    embedding_name: Annotated[
        Optional[str], Field(None, title="Embedding Name")
    ]


class BaseResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]


class ChunkAssignments(BaseModel):
    assigned: Annotated[List[str], Field(title="Assigned")]
    not_found: Annotated[List[str], Field(title="Not Found")]
    already_assigned: Annotated[List[str], Field(title="Already Assigned")]


class ChunkFilters(BaseModel):
    document_ids: Annotated[
        Optional[List[str]],
        Field(
            None,
            description="Document IDs that contain chunks.",
            title="Document Ids",
        ),
    ]
    data_types: Annotated[
        Optional[List[Literal["string", "object"]]],
        Field(None, description="Data types of chunks.", title="Data Types"),
    ]
    tags: Annotated[
        Optional[List[str]],
        Field(None, description="Tags for chunks.", title="Tags"),
    ]
    user_metadata: Annotated[
        Optional[Dict[str, Any]], Field(None, title="User Metadata")
    ]
    ids: Annotated[
        Optional[List[str]],
        Field(None, description="IDs of the chunks.", title="Ids"),
    ]


class ChunkMetadata(BaseModel):
    language: Annotated[
        Optional[str],
        Field("en", description="Language of the chunk", title="Language"),
    ]
    length: Annotated[
        Optional[int],
        Field(
            None,
            description="Length of the chunk in characters if string or keys if object",
            title="Length",
        ),
    ]
    size: Annotated[
        Optional[int],
        Field(None, description="Size of the chunk in bytes", title="Size"),
    ]
    data_source_type: Annotated[
        Optional[Literal["manual", "automatic", "external"]],
        Field(
            None,
            description="Source of how the chunk was created",
            title="Data Source Type",
        ),
    ]
    index: Annotated[
        Optional[int],
        Field(
            None,
            description="Index of the chunk in csv and json documents",
            title="Index",
        ),
    ]
    page: Annotated[
        Optional[int],
        Field(
            None,
            description="Page number of the chunk in pdf and txt documents",
            title="Page",
        ),
    ]
    start: Annotated[
        Optional[int],
        Field(
            None,
            description="Start position of the chunk in pdf and txt documents",
            title="Start",
        ),
    ]
    end: Annotated[
        Optional[int],
        Field(
            None,
            description="End position of the chunk in pdf and txt documents",
            title="End",
        ),
    ]


class Content2(Content):
    pass


class Content3(Content1):
    pass


class ChunkOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    workspaces: Annotated[List[str], Field(title="Workspaces")]
    document: Annotated[
        Optional[str],
        Field(
            None,
            description="Document id associated with the chunk",
            title="Document",
        ),
    ]
    data_type: Annotated[
        Literal["string", "object"],
        Field(
            description="Type of the content in the chunk", title="Data Type"
        ),
    ]
    content: Annotated[
        Union[Content2, Content3],
        Field(description="Content of the chunk", title="Content"),
    ]
    embedding: Annotated[
        Optional[List[float]],
        Field(None, description="Embedding of the chunk", title="Embedding"),
    ]
    metadata: ChunkMetadata
    tags: Annotated[
        Union[Dict[str, List[str]], List[str]], Field(title="Tags")
    ]
    user_metadata: Annotated[
        Union[
            Dict[
                str,
                Dict[
                    str,
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Union[str, int, bool, float]],
                    ],
                ],
            ],
            Dict[
                str,
                Union[
                    str, int, bool, float, List[Union[str, int, bool, float]]
                ],
            ],
        ],
        Field(title="User Metadata"),
    ]


class ChunkUnassignments(BaseModel):
    unassigned: Annotated[List[str], Field(title="Unassigned")]
    not_found: Annotated[List[str], Field(title="Not Found")]
    not_found_in_workspace: Annotated[
        List[str], Field(title="Not Found In Workspace")
    ]


class Content4(Content):
    pass


class Content5(Content1):
    pass


class ChunksResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    chunks: Annotated[List[ChunkOut], Field(title="Chunks")]


class CreateGraphBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str,
        Field(
            description="The name of the graph.", min_length=1, title="Name"
        ),
    ]
    workspace: Annotated[
        str,
        Field(
            description="The ID of the workspace for the graph. This is used for chunk retrieval.",
            title="Workspace",
        ),
    ]
    schema_: Annotated[
        str,
        Field(
            alias="schema",
            description="The ID of the schema to guide the graph creation.",
            title="Schema",
        ),
    ]
    filters: Annotated[
        Optional[ChunkFilters],
        Field(
            None,
            description="Filters to apply to the chunk retrieval. If not provided, all chunks will be used.",
        ),
    ]


class CreateGraphDetailsResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    cost: Annotated[
        float,
        Field(
            description="Estimated cost of the graph creation.", title="Cost"
        ),
    ]
    time: Annotated[
        float,
        Field(
            description="Estimated time taken for the graph creation.",
            title="Time",
        ),
    ]
    chunks_selected: Annotated[
        int,
        Field(
            description="Number of chunks selected.", title="Chunks Selected"
        ),
    ]
    chunks_allowed: Annotated[
        int,
        Field(description="Number of chunks allowed.", title="Chunks Allowed"),
    ]


class CypherResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    cypher_text: Annotated[str, Field(title="Cypher Text")]


class DeleteUserResponse(BaseResponse):
    pass


class DocumentAssignments(ChunkAssignments):
    pass


class DocumentDetail(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    filename: Annotated[
        str,
        Field(
            description="Filename of the document",
            min_length=1,
            title="Filename",
        ),
    ]


class DocumentMetadata(BaseModel):
    size: Annotated[
        int,
        Field(
            description="Size of the document", examples=[1234], title="Size"
        ),
    ]
    format: Annotated[
        Literal["csv", "json", "pdf", "txt"],
        Field(
            description="Format of the document",
            examples=["pdf", "csv", "json", "txt"],
            title="Format",
        ),
    ]
    filename: Annotated[
        str,
        Field(
            description="Filename of the document",
            min_length=1,
            title="Filename",
        ),
    ]


class DocumentUnassignments(ChunkUnassignments):
    pass


class DocumentUpdate(BaseModel):
    user_metadata: Annotated[
        Optional[
            Dict[
                str,
                Union[
                    str, int, bool, float, List[Union[str, int, bool, float]]
                ],
            ]
        ],
        Field(
            None,
            description="User supplied metadata to update",
            title="User Metadata",
        ),
    ]
    tags: Annotated[
        Optional[List[str]],
        Field(None, description="List of tags to update", title="Tags"),
    ]


class EntityField(BaseModel):
    name: Annotated[str, Field(title="Name")]
    properties: Annotated[Optional[List[str]], Field([], title="Properties")]


class ErrorDetails(BaseModel):
    message: Annotated[
        str,
        Field(
            description="The error message detailing what went wrong.",
            min_length=10,
            title="Message",
        ),
    ]
    created_at: Annotated[
        Optional[datetime],
        Field(
            None,
            description="The UTC timestamp when the error was logged.",
            title="Created At",
        ),
    ]
    level: Annotated[
        Literal["error", "critical"],
        Field(description="The severity level of the error.", title="Level"),
    ]


class GeneratePresignedDownloadResponse(BaseModel):
    url: Annotated[
        str,
        Field(
            description="Download URL of the document",
            min_length=1,
            title="Url",
        ),
    ]


class GeneratePresignedRequest(BaseModel):
    filename: Annotated[
        str,
        Field(
            description="Filename of the document",
            min_length=1,
            title="Filename",
        ),
    ]
    workspace_id: Annotated[str, Field(title="Workspace Id")]


class GeneratePresignedResponse(BaseModel):
    url: Annotated[str, Field(title="Url")]
    fields: Annotated[Dict[str, str], Field(title="Fields")]


class GenerateSchemaBody(BaseModel):
    workspace: Annotated[
        str,
        Field(
            description="Workspace to generate schema for.", title="Workspace"
        ),
    ]
    questions: Annotated[
        List[str],
        Field(
            description="list of questions to generate schema for.",
            title="Questions",
        ),
    ]


class GetAPIKeyResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    whyhow_api_key: Annotated[
        List[APIKeyOutModel], Field(title="Whyhow Api Key")
    ]


class GetUserStatusResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    active: Annotated[bool, Field(title="Active")]


class GraphOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    name: Annotated[
        str, Field(description="Name of the graph", min_length=1, title="Name")
    ]
    workspace_id: Annotated[str, Field(title="Workspace Id")]
    schema_id: Annotated[Optional[str], Field(None, title="Schema Id")]
    status: Annotated[
        Literal["creating", "updating", "ready", "failed"],
        Field(description="Status of the graph", title="Status"),
    ]
    errors: Annotated[
        Optional[List[ErrorDetails]],
        Field(
            [],
            description="Details about the error that occurred during graph creation.",
            title="Errors",
        ),
    ]
    public: Annotated[
        Optional[bool],
        Field(
            False,
            description="Whether the graph is public or not",
            title="Public",
        ),
    ]


class Name(RootModel[str]):
    root: Annotated[
        str, Field(description="Name of the graph", min_length=1, title="Name")
    ]


class GraphUpdate(BaseModel):
    name: Annotated[
        Optional[Name],
        Field(None, description="Name of the graph", title="Name"),
    ]
    public: Annotated[
        Optional[bool],
        Field(
            None,
            description="Whether the graph is public or not",
            title="Public",
        ),
    ]


class MergeNodesRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_nodes: Annotated[List[str], Field(title="From Nodes")]
    to_node: Annotated[str, Field(title="To Node")]
    save_as_rule: Annotated[
        Optional[bool],
        Field(
            False,
            description="A boolean specifying whether to save the merge as a rule or not.",
            title="Save As Rule",
        ),
    ]


class ApplyRuleRequest(BaseModel):
    from_strings: Annotated[
        List[str],
        Field(
            title="From Strings",
        ),
    ]
    to_string: Annotated[
        str,
        Field(
            title="To String",
        ),
    ]
    entity_type: Annotated[
        str,
        Field(
            title="Entity Type",
        ),
    ]
    save_as_rule: Annotated[
        Optional[bool],
        Field(
            default=True,
            description="A boolean specifying whether to save the merge as a rule or not.",
            title="Save As Rule",
        ),
    ]
    strict_mode: Annotated[
        Optional[bool],
        Field(
            default=False,
            description="Strict mode for node creation. If True, node validation will be performed. If False, invalid node will be used to extend the graph's schema.",
            title="Strict Mode",
        ),
    ]


class MergeNodesRule(BaseModel):
    rule_type: Annotated[
        Literal["merge_nodes"],
        Field("merge_nodes", description="Type of rule", title="Rule Type"),
    ]
    from_node_names: Annotated[List[str], Field(title="From Node Names")]
    to_node_name: Annotated[str, Field(title="To Node Name")]
    node_type: Annotated[str, Field(title="Node Type")]


class Node(BaseModel):
    name: Annotated[
        str,
        Field(
            description="The name of the node.",
            examples=["Python"],
            title="Name",
        ),
    ]
    label: Annotated[
        Optional[str],
        Field(
            None,
            description="The label assigned to the node (e.g., person, organization, location).",
            examples=["Programming Language"],
            title="Label",
        ),
    ]
    properties: Annotated[
        Optional[Dict[str, Any]],
        Field(None, description="Properties of the node.", title="Properties"),
    ]


class NodeCreate(BaseModel):
    name: Annotated[
        str, Field(description="Name of the node", min_length=1, title="Name")
    ]
    type: Annotated[
        str, Field(description="Type of the node", min_length=1, title="Type")
    ]
    properties: Annotated[
        Optional[
            Dict[
                str,
                Optional[
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Optional[Union[str, int, bool, float]]],
                    ]
                ],
            ]
        ],
        Field({}, description="Properties of the node", title="Properties"),
    ]
    graph: Annotated[
        str,
        Field(description="Graph id to which the node belongs", title="Graph"),
    ]
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the node is associated with",
            title="Chunks",
        ),
    ]
    strict_mode: Annotated[
        Optional[bool],
        Field(
            False,
            description="Strict mode for node creation. If True, node validation will be performed. If False, invalid node will be used to extend the graph's schema.",
            title="Strict Mode",
        ),
    ]


class NodeOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[
        str, Field(description="User who created the node", title="Created By")
    ]
    name: Annotated[
        str, Field(description="Name of the node", min_length=1, title="Name")
    ]
    type: Annotated[
        str, Field(description="Type of the node", min_length=1, title="Type")
    ]
    properties: Annotated[
        Dict[str, Any],
        Field(description="Properties of the node", title="Properties"),
    ]
    graph: Annotated[
        str,
        Field(description="Graph id to which the node belongs", title="Graph"),
    ]
    chunks: Annotated[
        List[str],
        Field(
            description="Chunk ids to which the node was found in",
            title="Chunks",
        ),
    ]


class Name1(RootModel[str]):
    root: Annotated[
        str, Field(description="Name of the node", min_length=1, title="Name")
    ]


class Type(RootModel[str]):
    root: Annotated[
        str, Field(description="Type of the node", min_length=1, title="Type")
    ]


class NodeUpdate(BaseModel):
    name: Annotated[
        Optional[Name1],
        Field(None, description="Name of the node", title="Name"),
    ]
    type: Annotated[
        Optional[Type],
        Field(None, description="Type of the node", title="Type"),
    ]
    properties: Annotated[
        Optional[Dict[str, Any]],
        Field(None, description="Properties of the node", title="Properties"),
    ]
    graph: Annotated[
        Optional[str],
        Field(
            None,
            description="Graph id to which the node belongs",
            title="Graph",
        ),
    ]
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the node is associated with",
            title="Chunks",
        ),
    ]


class Label(RootModel[str]):
    root: Annotated[
        str,
        Field(description="Label of the node", min_length=1, title="Label"),
    ]


class NodeWithId(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    name: Annotated[
        str, Field(description="Name of the node", min_length=1, title="Name")
    ]
    label: Annotated[
        Optional[Label], Field(description="Label of the node", title="Label")
    ]
    properties: Annotated[
        Optional[
            Dict[
                str,
                Optional[
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Optional[Union[str, int, bool, float]]],
                    ]
                ],
            ]
        ],
        Field({}, description="Properties of the node", title="Properties"),
    ]
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the node was found in",
            title="Chunks",
        ),
    ]


class NodeWithIdAndSimilarity(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    name: Annotated[
        str, Field(description="Name of the node", min_length=1, title="Name")
    ]
    label: Annotated[
        Optional[Label], Field(description="Label of the node", title="Label")
    ]
    properties: Annotated[
        Optional[
            Dict[
                str,
                Optional[
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Optional[Union[str, int, bool, float]]],
                    ]
                ],
            ]
        ],
        Field({}, description="Properties of the node", title="Properties"),
    ]
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the node was found in",
            title="Chunks",
        ),
    ]
    similarity: Annotated[
        float, Field(description="Similarity of the node", title="Similarity")
    ]


class NodesResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    nodes: Annotated[List[NodeOut], Field(title="Nodes")]


class Provider(BaseModel):
    type: Annotated[Literal["llm"], Field("llm", title="Type")]
    value: Annotated[
        Literal["byo-openai", "byo-azure-openai"], Field(title="Value")
    ]
    api_key: Annotated[str, Field(title="Api Key")]
    metadata: Annotated[
        Dict[str, Union[BYOOpenAIMetadata, BYOAzureOpenAIMetadata]],
        Field(title="Metadata"),
    ]


class ProviderConfig(BaseModel):
    providers: Annotated[List[Provider], Field(title="Providers")]


class Content6(Content):
    pass


class Content7(Content1):
    pass


class Query(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The query to use for the graph.",
            examples=["Who is the CEO of Apple?"],
            min_length=1,
            title="Query",
        ),
    ]


class QueryGraphRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    query: Annotated[
        Optional[Query],
        Field(
            None,
            description="The query to use for the graph.",
            examples=["Who is the CEO of Apple?"],
            title="Query",
        ),
    ]
    values: Annotated[
        Optional[List[str]],
        Field(
            None,
            description="A list of entity values (e.g. their content, names) to use for the graph.",
            examples=["Apple", "Tesla", "Mark Zuckerberg"],
            title="Values",
        ),
    ]
    entities: Annotated[
        Optional[List[str]],
        Field(
            None,
            description="A list of entity types to use for the graph.",
            examples=["Organization", "Person"],
            title="Entities",
        ),
    ]
    relations: Annotated[
        Optional[List[str]],
        Field(
            None,
            description="A list of relations to use for the graph.",
            examples=["founder", "CEO"],
            title="Relations",
        ),
    ]
    return_answer: Annotated[
        Optional[bool],
        Field(
            False,
            description="A boolean specifying whether to return natural language answer or not.",
            title="Return Answer",
        ),
    ]
    include_chunks: Annotated[
        Optional[bool],
        Field(
            False,
            description="A boolean specifying if to include the chunks in the query or not.",
            title="Include Chunks",
        ),
    ]


class Response(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Response associated with the query",
            min_length=1,
            title="Response",
        ),
    ]


class Content8(RootModel[str]):
    root: Annotated[
        str, Field(description="Query content", min_length=1, title="Content")
    ]


class QueryParameters(BaseModel):
    content: Annotated[
        Optional[Content8],
        Field(None, description="Query content", title="Content"),
    ]
    values: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="A list of entity values (e.g. their content, names) to use for the graph.",
            examples=["Apple", "Tesla", "Mark Zuckerberg"],
            title="Values",
        ),
    ]
    entities: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="A list of entity types to use for the graph.",
            examples=["Organization", "Person"],
            title="Entities",
        ),
    ]
    relations: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="A list of relations to use for the graph.",
            examples=["founder", "CEO"],
            title="Relations",
        ),
    ]
    return_answer: Annotated[
        Optional[bool],
        Field(
            False,
            description="A boolean specifying whether to return natural language answer or not.",
            title="Return Answer",
        ),
    ]
    include_chunks: Annotated[
        Optional[bool],
        Field(
            False,
            description="A boolean specifying if to include the chunks in the query or not.",
            title="Include Chunks",
        ),
    ]


class RelationOut(BaseModel):
    name: Annotated[
        str,
        Field(description="Name of the relation", min_length=1, title="Name"),
    ]
    properties: Annotated[
        Optional[Dict[str, Any]],
        Field(
            {}, description="Properties of the relation", title="Properties"
        ),
    ]


class RuleCreate(BaseModel):
    workspace: Annotated[
        str,
        Field(
            description="Workspace id associated with the schema",
            title="Workspace",
        ),
    ]
    rule: Annotated[MergeNodesRule, Field(description="Rule body")]


class RuleOut(BaseModel):
    workspace_id: Annotated[str, Field(title="Workspace Id")]
    rule: Annotated[MergeNodesRule, Field(description="Rule body")]
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]


class RulesResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    rules: Annotated[List[RuleOut], Field(title="Rules")]


class SchemaDetails(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    name: Annotated[
        str,
        Field(description="Name of the schema", min_length=1, title="Name"),
    ]


class SchemaEntity(BaseModel):
    name: Annotated[str, Field(title="Name")]
    description: Annotated[str, Field(title="Description")]
    fields: Annotated[
        Optional[List[EntityField]],
        Field(
            [],
            description="Fields corresponding to keys in structured content objects.",
            title="Fields",
        ),
    ]


class SchemaRelation(BaseModel):
    name: Annotated[str, Field(title="Name")]
    description: Annotated[str, Field(title="Description")]


class SchemaTriplePattern(BaseModel):
    head: SchemaEntity
    relation: SchemaRelation
    tail: SchemaEntity
    description: Annotated[str, Field(title="Description")]


class Name2(RootModel[str]):
    root: Annotated[
        str,
        Field(description="Name of the schema", min_length=1, title="Name"),
    ]


class SchemaUpdate(BaseModel):
    name: Annotated[
        Optional[Name2],
        Field(None, description="Name of the schema", title="Name"),
    ]


class SetProvidersDetailsResponse(BaseModel):
    providers: Annotated[List[Provider], Field(title="Providers")]
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]


class TaskOut(BaseModel):
    field_id: Annotated[Optional[str], Field(None, alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    start_time: Annotated[Optional[datetime], Field(None, title="Start Time")]
    end_time: Annotated[Optional[datetime], Field(None, title="End Time")]
    status: Annotated[
        Literal["pending", "success", "failed"],
        Field(description="Status of task", title="Status"),
    ]
    result: Annotated[Optional[str], Field(None, title="Result")]


class TaskResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    task: TaskOut


class Triple(BaseModel):
    head: Annotated[
        str,
        Field(
            description="The subject/head of the triple, representing an entity or a concept.",
            examples=["Python"],
            min_length=1,
            title="Head",
        ),
    ]
    head_type: Annotated[
        Optional[str],
        Field(
            "Entity",
            description="The semantic type of the triples subject/head.",
            examples=["Chunk", "Person", "Organisation"],
            min_length=1,
            title="Head Type",
        ),
    ]
    relation: Annotated[
        str,
        Field(
            description="The predicate of the triple, describing the relationship between the subject and object.",
            examples=["is a"],
            min_length=1,
            title="Relation",
        ),
    ]
    tail: Annotated[
        str,
        Field(
            description="The object/tail of the triple, representing an entity or concept that is related to the subject.",
            examples=["Programming Language"],
            min_length=1,
            title="Tail",
        ),
    ]
    tail_type: Annotated[
        Optional[str],
        Field(
            "Entity",
            description="The semantic type of the triples object/tail.",
            examples=["Chunk", "Person", "Organisation"],
            min_length=1,
            title="Tail Type",
        ),
    ]
    head_properties: Annotated[
        Optional[Dict[str, Any]],
        Field(
            {},
            description="Properties of the head entity.",
            title="Head Properties",
        ),
    ]
    relation_properties: Annotated[
        Optional[Dict[str, Any]],
        Field(
            {},
            description="Properties of the relation.",
            title="Relation Properties",
        ),
    ]
    tail_properties: Annotated[
        Optional[Dict[str, Any]],
        Field(
            {},
            description="Properties of the tail entity.",
            title="Tail Properties",
        ),
    ]


class TripleCreateNode(BaseModel):
    name: Annotated[
        str, Field(description="Name of the node", min_length=1, title="Name")
    ]
    type: Annotated[
        Optional[str],
        Field(
            "entity",
            description="Type of the node",
            min_length=1,
            title="Type",
        ),
    ]
    properties: Annotated[
        Optional[Dict[str, Any]],
        Field({}, description="Properties of the node", title="Properties"),
    ]


class TripleOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    head_node: Annotated[str, Field(title="Head Node")]
    tail_node: Annotated[str, Field(title="Tail Node")]
    type: Annotated[
        str,
        Field(
            description="Relation type of the triple",
            min_length=1,
            title="Type",
        ),
    ]
    properties: Annotated[
        Dict[str, Any],
        Field(description="Properties of the triple", title="Properties"),
    ]
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the triple was found in",
            title="Chunks",
        ),
    ]
    graph: Annotated[str, Field(title="Graph")]
    embedding: Annotated[Optional[List[float]], Field(None, title="Embedding")]


class TriplePattern(BaseModel):
    head: Annotated[str, Field(title="Head")]
    relation: Annotated[str, Field(title="Relation")]
    tail: Annotated[str, Field(title="Tail")]
    description: Annotated[str, Field(title="Description")]


class TripleWithId(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    head_node: NodeWithId
    relation: RelationOut
    tail_node: NodeWithId
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the triple was found in",
            title="Chunks",
        ),
    ]


class TriplesResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    triples: Annotated[List[TripleOut], Field(title="Triples")]


class UpdateChunkModel(BaseModel):
    user_metadata: Annotated[
        Optional[
            Dict[
                str,
                Union[
                    str, int, bool, float, List[Union[str, int, bool, float]]
                ],
            ]
        ],
        Field(
            None,
            description="User defined metadata to update",
            title="User Metadata",
        ),
    ]
    tags: Annotated[
        Optional[List[str]],
        Field(None, description="List of tags to update", title="Tags"),
    ]


class ValidationError(BaseModel):
    loc: Annotated[List[Union[str, int]], Field(title="Location")]
    msg: Annotated[str, Field(title="Message")]
    type: Annotated[str, Field(title="Error Type")]


class WorkspaceCreate(BaseModel):
    name: Annotated[
        str,
        Field(description="Name of the workspace", min_length=1, title="Name"),
    ]


class WorkspaceDetails(BaseModel):
    field_id: Annotated[
        str, Field(alias="_id", description="Workspace ID", title=" Id")
    ]
    name: Annotated[
        str,
        Field(description="Name of the workspace", min_length=1, title="Name"),
    ]


class WorkspaceOut(BaseModel):
    field_id: Annotated[
        str, Field(alias="_id", description="Workspace ID", title=" Id")
    ]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[
        str,
        Field(
            description="Id of the user who created the workspace",
            title="Created By",
        ),
    ]
    name: Annotated[
        str,
        Field(description="Name of the workspace", min_length=1, title="Name"),
    ]


class WorkspaceTagsResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    workspace_id: Annotated[str, Field(title="Workspace Id")]
    tags: Annotated[List[str], Field(title="Tags")]


class Name3(RootModel[str]):
    root: Annotated[
        str,
        Field(description="Name of the workspace", min_length=1, title="Name"),
    ]


class WorkspaceUpdate(BaseModel):
    name: Annotated[
        Optional[Name3],
        Field(None, description="Name of the workspace", title="Name"),
    ]


class WorkspacesResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    workspaces: Annotated[List[WorkspaceOut], Field(title="Workspaces")]


class AddChunksResponse(ChunksResponse):
    pass


class AddChunksToGraphBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    graph: Annotated[str, Field(title="Graph")]
    filters: Annotated[
        Optional[ChunkFilters],
        Field(
            None,
            description="Filters to apply to the chunk retrieval. If not provided, all chunks will be used.",
        ),
    ]


class ChunkAssignmentResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    chunks: ChunkAssignments


class ChunkUnassignmentResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    chunks: ChunkUnassignments


class ChunksOutWithWorkspaceDetails(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    workspaces: Annotated[List[WorkspaceDetails], Field(title="Workspaces")]
    document: Optional[DocumentDetail] = None
    data_type: Annotated[
        Literal["string", "object"],
        Field(
            description="Type of the content in the chunk", title="Data Type"
        ),
    ]
    content: Annotated[
        Union[Content4, Content5],
        Field(description="Content of the chunk", title="Content"),
    ]
    embedding: Annotated[
        Optional[List[float]],
        Field(None, description="Embedding of the chunk", title="Embedding"),
    ]
    metadata: ChunkMetadata
    tags: Annotated[
        Union[Dict[str, List[str]], List[str]], Field(title="Tags")
    ]
    user_metadata: Annotated[
        Union[
            Dict[
                str,
                Dict[
                    str,
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Union[str, int, bool, float]],
                    ],
                ],
            ],
            Dict[
                str,
                Union[
                    str, int, bool, float, List[Union[str, int, bool, float]]
                ],
            ],
        ],
        Field(title="User Metadata"),
    ]


class ChunksResponseWithWorkspaceDetails(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    chunks: Annotated[
        Optional[List[ChunksOutWithWorkspaceDetails]],
        Field([], description="list of chunks", title="Chunks"),
    ]


class CreateGraphFromTriplesBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str,
        Field(
            description="The name of the graph.", min_length=1, title="Name"
        ),
    ]
    workspace: Annotated[str, Field(title="Workspace")]
    schema_: Annotated[
        Optional[str], Field(None, alias="schema", title="Schema")
    ]
    triples: Annotated[
        List[Triple],
        Field(
            description="The triples to create the graph from.",
            min_length=1,
            title="Triples",
        ),
    ]


class DetailedGraphOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    name: Annotated[
        str, Field(description="Name of the graph", min_length=1, title="Name")
    ]
    workspace: WorkspaceDetails
    schema_: Annotated[SchemaDetails, Field(alias="schema")]
    status: Annotated[
        Literal["creating", "updating", "ready", "failed"],
        Field(description="Status of the graph", title="Status"),
    ]
    public: Annotated[
        bool,
        Field(
            description="Whether the graph is public or not", title="Public"
        ),
    ]
    errors: Annotated[
        Optional[List[ErrorDetails]],
        Field(
            [],
            description="Details about the error that occurred during graph creation.",
            title="Errors",
        ),
    ]


class DocumentAssignmentResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    documents: DocumentAssignments


class DocumentOut(BaseModel):
    field_id: Annotated[
        str, Field(alias="_id", description="Document ID", title=" Id")
    ]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    workspaces: Annotated[List[str], Field(title="Workspaces")]
    status: Annotated[
        Literal["uploaded", "processing", "processed", "failed"],
        Field(title="Status"),
    ]
    errors: Annotated[
        Optional[List[ErrorDetails]],
        Field(
            [],
            description="Details about the error that occurred during document processing.",
            title="Errors",
        ),
    ]
    metadata: DocumentMetadata
    tags: Annotated[
        Optional[Dict[str, List[str]]],
        Field({}, description="List of tags", title="Tags"),
    ]
    user_metadata: Annotated[
        Optional[
            Dict[
                str,
                Dict[
                    str,
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Union[str, int, bool, float]],
                    ],
                ],
            ]
        ],
        Field({}, description="User defined metadata", title="User Metadata"),
    ]


class DocumentOutWithWorkspaceDetails(BaseModel):
    field_id: Annotated[
        str, Field(alias="_id", description="Document ID", title=" Id")
    ]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    workspaces: Annotated[List[WorkspaceDetails], Field(title="Workspaces")]
    status: Annotated[
        Literal["uploaded", "processing", "processed", "failed"],
        Field(title="Status"),
    ]
    errors: Annotated[
        Optional[List[ErrorDetails]],
        Field(
            [],
            description="Details about the error that occurred during document processing.",
            title="Errors",
        ),
    ]
    metadata: DocumentMetadata
    tags: Annotated[
        Optional[Dict[str, List[str]]],
        Field({}, description="List of tags", title="Tags"),
    ]
    user_metadata: Annotated[
        Optional[
            Dict[
                str,
                Dict[
                    str,
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Union[str, int, bool, float]],
                    ],
                ],
            ]
        ],
        Field({}, description="User defined metadata", title="User Metadata"),
    ]


class DocumentUnassignmentResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    documents: DocumentUnassignments


class DocumentsResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    documents: Annotated[
        Optional[List[DocumentOut]],
        Field([], description="list of documents", title="Documents"),
    ]


class DocumentsResponseWithWorkspaceDetails(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    documents: Annotated[
        Optional[List[DocumentOutWithWorkspaceDetails]],
        Field([], description="list of documents", title="Documents"),
    ]


class GeneratedSchema(BaseModel):
    entities: Annotated[List[SchemaEntity], Field(title="Entities")]
    relations: Annotated[List[SchemaRelation], Field(title="Relations")]
    patterns: Annotated[List[TriplePattern], Field(title="Patterns")]


class GeneratedSchemaResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    questions: Annotated[List[str], Field(title="Questions")]
    generated_schema: GeneratedSchema
    errors: Annotated[Optional[List[ErrorDetails]], Field([], title="Errors")]


class GetProvidersDetailsResponse(SetProvidersDetailsResponse):
    pass


class GraphsDetailedNodeResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    graphs: Annotated[List[DetailedGraphOut], Field(title="Graphs")]
    nodes: Annotated[Optional[List[NodeWithId]], Field(None, title="Nodes")]


class GraphsDetailedTripleResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    graphs: Annotated[List[DetailedGraphOut], Field(title="Graphs")]
    triples: Annotated[
        Optional[List[TripleWithId]], Field(None, title="Triples")
    ]


class GraphsResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[int, Field(title="Count")]
    query_id: Annotated[Optional[str], Field(None, title="Query Id")]
    query: Annotated[Optional[str], Field(None, title="Query")]
    graphs: Annotated[List[GraphOut], Field(title="Graphs")]
    nodes: Annotated[Optional[List[Node]], Field(None, title="Nodes")]
    relations: Annotated[Optional[List[str]], Field(None, title="Relations")]
    triples: Annotated[Optional[List[Triple]], Field(None, title="Triples")]
    answer: Annotated[Optional[str], Field(None, title="Answer")]


class GraphsSimilarNodesResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    graphs: Annotated[List[DetailedGraphOut], Field(title="Graphs")]
    similar_nodes: Annotated[
        List[List[NodeWithIdAndSimilarity]], Field(title="Similar Nodes")
    ]


class HTTPValidationError(BaseModel):
    detail: Annotated[
        Optional[List[ValidationError]], Field(None, title="Detail")
    ]


class NodeChunksResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    chunks: Annotated[
        List[ChunksOutWithWorkspaceDetails], Field(title="Chunks")
    ]


class PublicChunksOutWithWorkspaceDetails(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    workspaces: Annotated[List[WorkspaceDetails], Field(title="Workspaces")]
    document: Optional[DocumentDetail] = None
    data_type: Annotated[
        Literal["string", "object"],
        Field(
            description="Type of the content in the chunk", title="Data Type"
        ),
    ]
    content: Annotated[
        Union[Content6, Content7],
        Field(description="Content of the chunk", title="Content"),
    ]
    embedding: Annotated[
        Optional[List[float]],
        Field(None, description="Embedding of the chunk", title="Embedding"),
    ]
    metadata: ChunkMetadata
    tags: Annotated[
        Union[Dict[str, List[str]], List[str]], Field(title="Tags")
    ]
    user_metadata: Annotated[
        Union[
            Dict[
                str,
                Dict[
                    str,
                    Union[
                        str,
                        int,
                        bool,
                        float,
                        List[Union[str, int, bool, float]],
                    ],
                ],
            ],
            Dict[
                str,
                Union[
                    str, int, bool, float, List[Union[str, int, bool, float]]
                ],
            ],
        ],
        Field(title="User Metadata"),
    ]


class PublicChunksResponseWithWorkspaceDetails(
    ChunksResponseWithWorkspaceDetails
):
    pass


class PublicGraphsDetailedNodeResponse(GraphsDetailedNodeResponse):
    pass


class PublicGraphsTripleResponse(GraphsDetailedTripleResponse):
    pass


class PublicTripleChunksResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    chunks: Annotated[
        Optional[List[PublicChunksOutWithWorkspaceDetails]],
        Field([], title="Chunks"),
    ]


class QueryOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    query: Annotated[
        QueryParameters, Field(description="Content of the query")
    ]
    response: Annotated[
        Optional[Response],
        Field(
            None,
            description="Response associated with the query",
            title="Response",
        ),
    ]
    graph: Annotated[str, Field(title="Graph")]
    triples: Annotated[
        Optional[List[TripleWithId]],
        Field(
            [],
            description="Triple ids associated with the query",
            title="Triples",
        ),
    ]
    nodes: Annotated[
        Optional[List[NodeWithId]],
        Field(
            [], description="Node ids associated with the query", title="Nodes"
        ),
    ]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]


class QueryResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    queries: Annotated[Optional[List[QueryOut]], Field([], title="Queries")]


class SchemaCreate(BaseModel):
    name: Annotated[
        str,
        Field(description="Name of the schema", min_length=1, title="Name"),
    ]
    workspace: Annotated[
        str,
        Field(
            description="Workspace id associated with the schema",
            title="Workspace",
        ),
    ]
    entities: Annotated[List[SchemaEntity], Field(title="Entities")]
    relations: Annotated[List[SchemaRelation], Field(title="Relations")]
    patterns: Annotated[List[TriplePattern], Field(title="Patterns")]


class SchemaOut(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    name: Annotated[
        str,
        Field(description="Name of the schema", min_length=1, title="Name"),
    ]
    workspace_id: Annotated[str, Field(title="Workspace Id")]
    entities: Annotated[List[SchemaEntity], Field(title="Entities")]
    relations: Annotated[List[SchemaRelation], Field(title="Relations")]
    patterns: Annotated[List[SchemaTriplePattern], Field(title="Patterns")]


class SchemaOutWithWorkspaceDetails(BaseModel):
    field_id: Annotated[str, Field(alias="_id", title=" Id")]
    created_at: Annotated[Optional[datetime], Field(None, title="Created At")]
    updated_at: Annotated[Optional[datetime], Field(None, title="Updated At")]
    created_by: Annotated[str, Field(title="Created By")]
    name: Annotated[
        str,
        Field(description="Name of the schema", min_length=1, title="Name"),
    ]
    workspace: WorkspaceDetails
    entities: Annotated[List[SchemaEntity], Field(title="Entities")]
    relations: Annotated[List[SchemaRelation], Field(title="Relations")]
    patterns: Annotated[List[SchemaTriplePattern], Field(title="Patterns")]


class SchemasResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    schemas: Annotated[List[SchemaOut], Field(title="Schemas")]


class SchemasResponseWithWorkspaceDetails(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    schemas: Annotated[
        Optional[List[SchemaOutWithWorkspaceDetails]],
        Field([], description="list of schemas", title="Schemas"),
    ]


class TripleChunksResponse(NodeChunksResponse):
    pass


class TripleCreate(BaseModel):
    head_node: Annotated[
        Union[TripleCreateNode, str], Field(title="Head Node")
    ]
    tail_node: Annotated[
        Union[TripleCreateNode, str], Field(title="Tail Node")
    ]
    type: Annotated[
        Optional[str],
        Field(
            "related_to",
            description="Relation type of the triple",
            min_length=1,
            title="Type",
        ),
    ]
    properties: Annotated[
        Optional[Dict[str, Any]],
        Field({}, description="Properties of the triple", title="Properties"),
    ]
    chunks: Annotated[
        Optional[List[str]],
        Field(
            [],
            description="Chunk ids to which the triple is associated with",
            title="Chunks",
        ),
    ]


class TriplesCreate(BaseModel):
    graph: Annotated[str, Field(title="Graph")]
    strict_mode: Annotated[
        Optional[bool],
        Field(
            False,
            description="Strict mode for triple creation. If True, triple validation will be performed. If False, invalid triples will be used to extend the graph's schema.",
            title="Strict Mode",
        ),
    ]
    triples: Annotated[List[TripleCreate], Field(title="Triples")]


class DetailedGraphsResponse(BaseModel):
    message: Annotated[str, Field(title="Message")]
    status: Annotated[
        Literal["success", "pending", "failed"], Field(title="Status")
    ]
    count: Annotated[Optional[int], Field(0, title="Count")]
    graphs: Annotated[List[DetailedGraphOut], Field(title="Graphs")]
    queries: Annotated[Optional[List[QueryOut]], Field(None, title="Queries")]
    relations: Annotated[Optional[List[str]], Field(None, title="Relations")]
    nodes: Annotated[Optional[List[NodeWithId]], Field(None, title="Nodes")]


class PublicGraphsResponse(DetailedGraphsResponse):
    pass
