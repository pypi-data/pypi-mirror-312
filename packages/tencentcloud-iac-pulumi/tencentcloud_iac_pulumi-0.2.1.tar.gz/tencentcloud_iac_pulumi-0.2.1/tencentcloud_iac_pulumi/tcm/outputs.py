# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AccessLogConfigCls',
    'AccessLogConfigSelectedRange',
    'AccessLogConfigSelectedRangeItem',
    'ClusterAttachmentClusterList',
    'MeshConfig',
    'MeshConfigInject',
    'MeshConfigIstio',
    'MeshConfigIstioSmartDns',
    'MeshConfigIstioTracing',
    'MeshConfigIstioTracingApm',
    'MeshConfigIstioTracingZipkin',
    'MeshConfigPrometheus',
    'MeshConfigPrometheusCustomProm',
    'MeshConfigSidecarResources',
    'MeshConfigSidecarResourcesLimit',
    'MeshConfigSidecarResourcesRequest',
    'MeshConfigTracing',
    'MeshConfigTracingApm',
    'MeshConfigTracingZipkin',
    'MeshTagList',
    'PrometheusAttachmentPrometheus',
    'PrometheusAttachmentPrometheusCustomProm',
    'TracingConfigApm',
    'TracingConfigZipkin',
    'GetMeshMeshListResult',
    'GetMeshMeshListConfigResult',
    'GetMeshMeshListConfigIstioResult',
    'GetMeshMeshListConfigIstioSmartDnResult',
    'GetMeshMeshListTagListResult',
]

@pulumi.output_type
class AccessLogConfigCls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logSet":
            suggest = "log_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessLogConfigCls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessLogConfigCls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessLogConfigCls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: bool,
                 log_set: Optional[str] = None,
                 topic: Optional[str] = None):
        """
        :param bool enable: Whether enable CLS.
        :param str log_set: Log set of CLS.
        :param str topic: Log topic of CLS.
        """
        pulumi.set(__self__, "enable", enable)
        if log_set is not None:
            pulumi.set(__self__, "log_set", log_set)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Whether enable CLS.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="logSet")
    def log_set(self) -> Optional[str]:
        """
        Log set of CLS.
        """
        return pulumi.get(self, "log_set")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        Log topic of CLS.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class AccessLogConfigSelectedRange(dict):
    def __init__(__self__, *,
                 all: Optional[bool] = None,
                 items: Optional[Sequence['outputs.AccessLogConfigSelectedRangeItem']] = None):
        """
        :param bool all: Select all if true, default false.
        :param Sequence['AccessLogConfigSelectedRangeItemArgs'] items: Items.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Select all if true, default false.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.AccessLogConfigSelectedRangeItem']]:
        """
        Items.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class AccessLogConfigSelectedRangeItem(dict):
    def __init__(__self__, *,
                 gateways: Optional[Sequence[str]] = None,
                 namespace: Optional[str] = None):
        """
        :param Sequence[str] gateways: Ingress gateway list.
        :param str namespace: Namespace.
        """
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence[str]]:
        """
        Ingress gateway list.
        """
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ClusterAttachmentClusterList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentClusterList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentClusterList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentClusterList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 region: str,
                 role: str,
                 type: str,
                 vpc_id: str,
                 subnet_id: Optional[str] = None):
        """
        :param str cluster_id: TKE Cluster id.
        :param str region: TKE cluster region.
        :param str role: Cluster role in mesh, REMOTE or MASTER.
        :param str type: Cluster type.
        :param str vpc_id: Cluster&#39;s VpcId.
        :param str subnet_id: Subnet id, only needed if it&#39;s standalone mesh.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        TKE Cluster id.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        TKE cluster region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Cluster role in mesh, REMOTE or MASTER.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Cluster type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Cluster&#39;s VpcId.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Subnet id, only needed if it&#39;s standalone mesh.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MeshConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sidecarResources":
            suggest = "sidecar_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inject: Optional['outputs.MeshConfigInject'] = None,
                 istio: Optional['outputs.MeshConfigIstio'] = None,
                 prometheus: Optional['outputs.MeshConfigPrometheus'] = None,
                 sidecar_resources: Optional['outputs.MeshConfigSidecarResources'] = None,
                 tracing: Optional['outputs.MeshConfigTracing'] = None):
        """
        :param 'MeshConfigInjectArgs' inject: Sidecar inject configuration.
        :param 'MeshConfigIstioArgs' istio: Istio configuration.
        :param 'MeshConfigPrometheusArgs' prometheus: Prometheus configuration.
        :param 'MeshConfigSidecarResourcesArgs' sidecar_resources: Default sidecar requests and limits.
        :param 'MeshConfigTracingArgs' tracing: Tracing config.
        """
        if inject is not None:
            pulumi.set(__self__, "inject", inject)
        if istio is not None:
            pulumi.set(__self__, "istio", istio)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if sidecar_resources is not None:
            pulumi.set(__self__, "sidecar_resources", sidecar_resources)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @property
    @pulumi.getter
    def inject(self) -> Optional['outputs.MeshConfigInject']:
        """
        Sidecar inject configuration.
        """
        return pulumi.get(self, "inject")

    @property
    @pulumi.getter
    def istio(self) -> Optional['outputs.MeshConfigIstio']:
        """
        Istio configuration.
        """
        return pulumi.get(self, "istio")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional['outputs.MeshConfigPrometheus']:
        """
        Prometheus configuration.
        """
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="sidecarResources")
    def sidecar_resources(self) -> Optional['outputs.MeshConfigSidecarResources']:
        """
        Default sidecar requests and limits.
        """
        return pulumi.get(self, "sidecar_resources")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.MeshConfigTracing']:
        """
        Tracing config.
        """
        return pulumi.get(self, "tracing")


@pulumi.output_type
class MeshConfigInject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeIpRanges":
            suggest = "exclude_ip_ranges"
        elif key == "holdApplicationUntilProxyStarts":
            suggest = "hold_application_until_proxy_starts"
        elif key == "holdProxyUntilApplicationEnds":
            suggest = "hold_proxy_until_application_ends"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigInject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigInject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigInject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_ip_ranges: Optional[Sequence[str]] = None,
                 hold_application_until_proxy_starts: Optional[bool] = None,
                 hold_proxy_until_application_ends: Optional[bool] = None):
        """
        :param Sequence[str] exclude_ip_ranges: IP ranges that should not be proxied.
        :param bool hold_application_until_proxy_starts: Let istio-proxy(sidecar) start first, before app container.
        :param bool hold_proxy_until_application_ends: Let istio-proxy(sidecar) stop last, after app container.
        """
        if exclude_ip_ranges is not None:
            pulumi.set(__self__, "exclude_ip_ranges", exclude_ip_ranges)
        if hold_application_until_proxy_starts is not None:
            pulumi.set(__self__, "hold_application_until_proxy_starts", hold_application_until_proxy_starts)
        if hold_proxy_until_application_ends is not None:
            pulumi.set(__self__, "hold_proxy_until_application_ends", hold_proxy_until_application_ends)

    @property
    @pulumi.getter(name="excludeIpRanges")
    def exclude_ip_ranges(self) -> Optional[Sequence[str]]:
        """
        IP ranges that should not be proxied.
        """
        return pulumi.get(self, "exclude_ip_ranges")

    @property
    @pulumi.getter(name="holdApplicationUntilProxyStarts")
    def hold_application_until_proxy_starts(self) -> Optional[bool]:
        """
        Let istio-proxy(sidecar) start first, before app container.
        """
        return pulumi.get(self, "hold_application_until_proxy_starts")

    @property
    @pulumi.getter(name="holdProxyUntilApplicationEnds")
    def hold_proxy_until_application_ends(self) -> Optional[bool]:
        """
        Let istio-proxy(sidecar) stop last, after app container.
        """
        return pulumi.get(self, "hold_proxy_until_application_ends")


@pulumi.output_type
class MeshConfigIstio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outboundTrafficPolicy":
            suggest = "outbound_traffic_policy"
        elif key == "disableHttpRetry":
            suggest = "disable_http_retry"
        elif key == "disablePolicyChecks":
            suggest = "disable_policy_checks"
        elif key == "enablePilotHttp":
            suggest = "enable_pilot_http"
        elif key == "smartDns":
            suggest = "smart_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigIstio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigIstio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigIstio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outbound_traffic_policy: str,
                 disable_http_retry: Optional[bool] = None,
                 disable_policy_checks: Optional[bool] = None,
                 enable_pilot_http: Optional[bool] = None,
                 smart_dns: Optional['outputs.MeshConfigIstioSmartDns'] = None,
                 tracing: Optional['outputs.MeshConfigIstioTracing'] = None):
        """
        :param str outbound_traffic_policy: Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
        :param bool disable_http_retry: Disable http retry.
        :param bool disable_policy_checks: Disable policy checks.
        :param bool enable_pilot_http: Enable HTTP/1.0 support.
        :param 'MeshConfigIstioSmartDnsArgs' smart_dns: SmartDNS configuration.
        :param 'MeshConfigIstioTracingArgs' tracing: Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
        pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        if disable_http_retry is not None:
            pulumi.set(__self__, "disable_http_retry", disable_http_retry)
        if disable_policy_checks is not None:
            pulumi.set(__self__, "disable_policy_checks", disable_policy_checks)
        if enable_pilot_http is not None:
            pulumi.set(__self__, "enable_pilot_http", enable_pilot_http)
        if smart_dns is not None:
            pulumi.set(__self__, "smart_dns", smart_dns)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> str:
        """
        Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
        """
        return pulumi.get(self, "outbound_traffic_policy")

    @property
    @pulumi.getter(name="disableHttpRetry")
    def disable_http_retry(self) -> Optional[bool]:
        """
        Disable http retry.
        """
        return pulumi.get(self, "disable_http_retry")

    @property
    @pulumi.getter(name="disablePolicyChecks")
    def disable_policy_checks(self) -> Optional[bool]:
        """
        Disable policy checks.
        """
        return pulumi.get(self, "disable_policy_checks")

    @property
    @pulumi.getter(name="enablePilotHttp")
    def enable_pilot_http(self) -> Optional[bool]:
        """
        Enable HTTP/1.0 support.
        """
        return pulumi.get(self, "enable_pilot_http")

    @property
    @pulumi.getter(name="smartDns")
    def smart_dns(self) -> Optional['outputs.MeshConfigIstioSmartDns']:
        """
        SmartDNS configuration.
        """
        return pulumi.get(self, "smart_dns")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.MeshConfigIstioTracing']:
        """
        Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
        """
        return pulumi.get(self, "tracing")


@pulumi.output_type
class MeshConfigIstioSmartDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "istioMetaDnsAutoAllocate":
            suggest = "istio_meta_dns_auto_allocate"
        elif key == "istioMetaDnsCapture":
            suggest = "istio_meta_dns_capture"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigIstioSmartDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigIstioSmartDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigIstioSmartDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 istio_meta_dns_auto_allocate: Optional[bool] = None,
                 istio_meta_dns_capture: Optional[bool] = None):
        """
        :param bool istio_meta_dns_auto_allocate: Enable auto allocate address.
        :param bool istio_meta_dns_capture: Enable dns proxy.
        """
        if istio_meta_dns_auto_allocate is not None:
            pulumi.set(__self__, "istio_meta_dns_auto_allocate", istio_meta_dns_auto_allocate)
        if istio_meta_dns_capture is not None:
            pulumi.set(__self__, "istio_meta_dns_capture", istio_meta_dns_capture)

    @property
    @pulumi.getter(name="istioMetaDnsAutoAllocate")
    def istio_meta_dns_auto_allocate(self) -> Optional[bool]:
        """
        Enable auto allocate address.
        """
        return pulumi.get(self, "istio_meta_dns_auto_allocate")

    @property
    @pulumi.getter(name="istioMetaDnsCapture")
    def istio_meta_dns_capture(self) -> Optional[bool]:
        """
        Enable dns proxy.
        """
        return pulumi.get(self, "istio_meta_dns_capture")


@pulumi.output_type
class MeshConfigIstioTracing(dict):
    def __init__(__self__, *,
                 apm: Optional['outputs.MeshConfigIstioTracingApm'] = None,
                 enable: Optional[bool] = None,
                 sampling: Optional[float] = None,
                 zipkin: Optional['outputs.MeshConfigIstioTracingZipkin'] = None):
        """
        :param 'MeshConfigIstioTracingApmArgs' apm: APM config.
        :param bool enable: Whether enable tracing.
        :param float sampling: Tracing sampling, 0.0-1.0.
        :param 'MeshConfigIstioTracingZipkinArgs' zipkin: Third party zipkin config.
        """
        if apm is not None:
            pulumi.set(__self__, "apm", apm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sampling is not None:
            pulumi.set(__self__, "sampling", sampling)
        if zipkin is not None:
            pulumi.set(__self__, "zipkin", zipkin)

    @property
    @pulumi.getter
    def apm(self) -> Optional['outputs.MeshConfigIstioTracingApm']:
        """
        APM config.
        """
        return pulumi.get(self, "apm")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether enable tracing.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def sampling(self) -> Optional[float]:
        """
        Tracing sampling, 0.0-1.0.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def zipkin(self) -> Optional['outputs.MeshConfigIstioTracingZipkin']:
        """
        Third party zipkin config.
        """
        return pulumi.get(self, "zipkin")


@pulumi.output_type
class MeshConfigIstioTracingApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigIstioTracingApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigIstioTracingApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigIstioTracingApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: bool,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param bool enable: Whether enable APM.
        :param str instance_id: Instance id of the APM.
        :param str region: Region.
        """
        pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Whether enable APM.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Instance id of the APM.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class MeshConfigIstioTracingZipkin(dict):
    def __init__(__self__, *,
                 address: str):
        """
        :param str address: Zipkin address.
        """
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Zipkin address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class MeshConfigPrometheus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProm":
            suggest = "custom_prom"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigPrometheus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigPrometheus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigPrometheus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_prom: Optional['outputs.MeshConfigPrometheusCustomProm'] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param 'MeshConfigPrometheusCustomPromArgs' custom_prom: Custom prometheus.
        :param str instance_id: Instance id.
        :param str region: Region.
        :param str subnet_id: Subnet id.
        :param str vpc_id: Vpc id.
        """
        if custom_prom is not None:
            pulumi.set(__self__, "custom_prom", custom_prom)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="customProm")
    def custom_prom(self) -> Optional['outputs.MeshConfigPrometheusCustomProm']:
        """
        Custom prometheus.
        """
        return pulumi.get(self, "custom_prom")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Subnet id.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class MeshConfigPrometheusCustomProm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "isPublicAddr":
            suggest = "is_public_addr"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigPrometheusCustomProm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigPrometheusCustomProm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigPrometheusCustomProm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 url: str,
                 is_public_addr: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param str auth_type: Authentication type of the prometheus.
        :param str url: Url of the prometheus.
        :param bool is_public_addr: Whether it is public address, default false.
        :param str password: Password of the prometheus, used in basic authentication type.
        :param str username: Username of the prometheus, used in basic authentication type.
        :param str vpc_id: Vpc id.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "url", url)
        if is_public_addr is not None:
            pulumi.set(__self__, "is_public_addr", is_public_addr)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication type of the prometheus.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Url of the prometheus.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="isPublicAddr")
    def is_public_addr(self) -> Optional[bool]:
        """
        Whether it is public address, default false.
        """
        return pulumi.get(self, "is_public_addr")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class MeshConfigSidecarResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Sequence['outputs.MeshConfigSidecarResourcesLimit']] = None,
                 requests: Optional[Sequence['outputs.MeshConfigSidecarResourcesRequest']] = None):
        """
        :param Sequence['MeshConfigSidecarResourcesLimitArgs'] limits: Sidecar limits.
        :param Sequence['MeshConfigSidecarResourcesRequestArgs'] requests: Sidecar requests.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Sequence['outputs.MeshConfigSidecarResourcesLimit']]:
        """
        Sidecar limits.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.MeshConfigSidecarResourcesRequest']]:
        """
        Sidecar requests.
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class MeshConfigSidecarResourcesLimit(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 quantity: Optional[str] = None):
        """
        :param str name: Resource type name, `cpu/memory`.
        :param str quantity: Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource type name, `cpu/memory`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[str]:
        """
        Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class MeshConfigSidecarResourcesRequest(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 quantity: Optional[str] = None):
        """
        :param str name: Resource type name, `cpu/memory`.
        :param str quantity: Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource type name, `cpu/memory`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[str]:
        """
        Resource quantity, example: cpu-`100m`, memory-`1Gi`.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class MeshConfigTracing(dict):
    def __init__(__self__, *,
                 apm: Optional['outputs.MeshConfigTracingApm'] = None,
                 enable: Optional[bool] = None,
                 sampling: Optional[float] = None,
                 zipkin: Optional['outputs.MeshConfigTracingZipkin'] = None):
        """
        :param 'MeshConfigTracingApmArgs' apm: APM config.
        :param bool enable: Whether enable tracing.
        :param float sampling: Tracing sampling, 0.0-1.0.
        :param 'MeshConfigTracingZipkinArgs' zipkin: Third party zipkin config.
        """
        if apm is not None:
            pulumi.set(__self__, "apm", apm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sampling is not None:
            pulumi.set(__self__, "sampling", sampling)
        if zipkin is not None:
            pulumi.set(__self__, "zipkin", zipkin)

    @property
    @pulumi.getter
    def apm(self) -> Optional['outputs.MeshConfigTracingApm']:
        """
        APM config.
        """
        return pulumi.get(self, "apm")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether enable tracing.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def sampling(self) -> Optional[float]:
        """
        Tracing sampling, 0.0-1.0.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def zipkin(self) -> Optional['outputs.MeshConfigTracingZipkin']:
        """
        Third party zipkin config.
        """
        return pulumi.get(self, "zipkin")


@pulumi.output_type
class MeshConfigTracingApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigTracingApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigTracingApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigTracingApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param bool enable: Whether enable APM.
        :param str instance_id: Instance id of the APM.
        :param str region: Region.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether enable APM.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Instance id of the APM.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class MeshConfigTracingZipkin(dict):
    def __init__(__self__, *,
                 address: str):
        """
        :param str address: Zipkin address.
        """
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Zipkin address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class MeshTagList(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 passthrough: Optional[bool] = None):
        """
        :param str key: Tag key.
        :param str value: Tag value.
        :param bool passthrough: Passthrough to other related product.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def passthrough(self) -> Optional[bool]:
        """
        Passthrough to other related product.
        """
        return pulumi.get(self, "passthrough")


@pulumi.output_type
class PrometheusAttachmentPrometheus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProm":
            suggest = "custom_prom"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusAttachmentPrometheus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusAttachmentPrometheus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusAttachmentPrometheus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_prom: Optional['outputs.PrometheusAttachmentPrometheusCustomProm'] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param 'PrometheusAttachmentPrometheusCustomPromArgs' custom_prom: Third party prometheus.
        :param str instance_id: Existed TMP id, auto create TMP if empty.
        :param str region: Region for TMP.
        :param str subnet_id: Subnet id for TMP.
        :param str vpc_id: Vpc id for TMP.
        """
        if custom_prom is not None:
            pulumi.set(__self__, "custom_prom", custom_prom)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="customProm")
    def custom_prom(self) -> Optional['outputs.PrometheusAttachmentPrometheusCustomProm']:
        """
        Third party prometheus.
        """
        return pulumi.get(self, "custom_prom")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Existed TMP id, auto create TMP if empty.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for TMP.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Subnet id for TMP.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Vpc id for TMP.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class PrometheusAttachmentPrometheusCustomProm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "isPublicAddr":
            suggest = "is_public_addr"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusAttachmentPrometheusCustomProm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusAttachmentPrometheusCustomProm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusAttachmentPrometheusCustomProm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 url: str,
                 is_public_addr: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param str auth_type: Authentication type of the prometheus.
        :param str url: Url of the prometheus.
        :param bool is_public_addr: Whether it is public address, default false.
        :param str password: Password of the prometheus, used in basic authentication type.
        :param str username: Username of the prometheus, used in basic authentication type.
        :param str vpc_id: Vpc id.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "url", url)
        if is_public_addr is not None:
            pulumi.set(__self__, "is_public_addr", is_public_addr)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication type of the prometheus.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Url of the prometheus.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="isPublicAddr")
    def is_public_addr(self) -> Optional[bool]:
        """
        Whether it is public address, default false.
        """
        return pulumi.get(self, "is_public_addr")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the prometheus, used in basic authentication type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class TracingConfigApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TracingConfigApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TracingConfigApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TracingConfigApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param bool enable: Whether enable APM.
        :param str instance_id: Instance id of the APM.
        :param str region: Region.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Whether enable APM.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Instance id of the APM.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class TracingConfigZipkin(dict):
    def __init__(__self__, *,
                 address: str):
        """
        :param str address: Zipkin address.
        """
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Zipkin address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetMeshMeshListResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetMeshMeshListConfigResult'],
                 display_name: str,
                 mesh_id: str,
                 tag_lists: Sequence['outputs.GetMeshMeshListTagListResult'],
                 type: str,
                 version: str):
        """
        :param Sequence['GetMeshMeshListConfigArgs'] configs: Mesh configuration.
        :param str display_name: Mesh name.
        :param str mesh_id: Mesh instance Id.
        :param Sequence['GetMeshMeshListTagListArgs'] tag_lists: A list of associated tags.
        :param str type: Mesh type.  Value range:- `STANDALONE`: Standalone mesh- `HOSTED`: hosted the mesh.
        :param str version: Mesh version.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "mesh_id", mesh_id)
        pulumi.set(__self__, "tag_lists", tag_lists)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetMeshMeshListConfigResult']:
        """
        Mesh configuration.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Mesh name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="meshId")
    def mesh_id(self) -> str:
        """
        Mesh instance Id.
        """
        return pulumi.get(self, "mesh_id")

    @property
    @pulumi.getter(name="tagLists")
    def tag_lists(self) -> Sequence['outputs.GetMeshMeshListTagListResult']:
        """
        A list of associated tags.
        """
        return pulumi.get(self, "tag_lists")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Mesh type.  Value range:- `STANDALONE`: Standalone mesh- `HOSTED`: hosted the mesh.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Mesh version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMeshMeshListConfigResult(dict):
    def __init__(__self__, *,
                 istios: Sequence['outputs.GetMeshMeshListConfigIstioResult']):
        """
        :param Sequence['GetMeshMeshListConfigIstioArgs'] istios: Istio configuration.
        """
        pulumi.set(__self__, "istios", istios)

    @property
    @pulumi.getter
    def istios(self) -> Sequence['outputs.GetMeshMeshListConfigIstioResult']:
        """
        Istio configuration.
        """
        return pulumi.get(self, "istios")


@pulumi.output_type
class GetMeshMeshListConfigIstioResult(dict):
    def __init__(__self__, *,
                 disable_http_retry: bool,
                 disable_policy_checks: bool,
                 enable_pilot_http: bool,
                 outbound_traffic_policy: str,
                 smart_dns: Sequence['outputs.GetMeshMeshListConfigIstioSmartDnResult']):
        """
        :param bool disable_http_retry: Disable http retry.
        :param bool disable_policy_checks: Disable policy checks.
        :param bool enable_pilot_http: Enable HTTP/1.0 support.
        :param str outbound_traffic_policy: Outbound traffic policy.
        :param Sequence['GetMeshMeshListConfigIstioSmartDnArgs'] smart_dns: SmartDNS configuration.
        """
        pulumi.set(__self__, "disable_http_retry", disable_http_retry)
        pulumi.set(__self__, "disable_policy_checks", disable_policy_checks)
        pulumi.set(__self__, "enable_pilot_http", enable_pilot_http)
        pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        pulumi.set(__self__, "smart_dns", smart_dns)

    @property
    @pulumi.getter(name="disableHttpRetry")
    def disable_http_retry(self) -> bool:
        """
        Disable http retry.
        """
        return pulumi.get(self, "disable_http_retry")

    @property
    @pulumi.getter(name="disablePolicyChecks")
    def disable_policy_checks(self) -> bool:
        """
        Disable policy checks.
        """
        return pulumi.get(self, "disable_policy_checks")

    @property
    @pulumi.getter(name="enablePilotHttp")
    def enable_pilot_http(self) -> bool:
        """
        Enable HTTP/1.0 support.
        """
        return pulumi.get(self, "enable_pilot_http")

    @property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> str:
        """
        Outbound traffic policy.
        """
        return pulumi.get(self, "outbound_traffic_policy")

    @property
    @pulumi.getter(name="smartDns")
    def smart_dns(self) -> Sequence['outputs.GetMeshMeshListConfigIstioSmartDnResult']:
        """
        SmartDNS configuration.
        """
        return pulumi.get(self, "smart_dns")


@pulumi.output_type
class GetMeshMeshListConfigIstioSmartDnResult(dict):
    def __init__(__self__, *,
                 istio_meta_dns_auto_allocate: bool,
                 istio_meta_dns_capture: bool):
        """
        :param bool istio_meta_dns_auto_allocate: Enable auto allocate address.
        :param bool istio_meta_dns_capture: Enable dns proxy.
        """
        pulumi.set(__self__, "istio_meta_dns_auto_allocate", istio_meta_dns_auto_allocate)
        pulumi.set(__self__, "istio_meta_dns_capture", istio_meta_dns_capture)

    @property
    @pulumi.getter(name="istioMetaDnsAutoAllocate")
    def istio_meta_dns_auto_allocate(self) -> bool:
        """
        Enable auto allocate address.
        """
        return pulumi.get(self, "istio_meta_dns_auto_allocate")

    @property
    @pulumi.getter(name="istioMetaDnsCapture")
    def istio_meta_dns_capture(self) -> bool:
        """
        Enable dns proxy.
        """
        return pulumi.get(self, "istio_meta_dns_capture")


@pulumi.output_type
class GetMeshMeshListTagListResult(dict):
    def __init__(__self__, *,
                 key: str,
                 passthrough: bool,
                 value: str):
        """
        :param str key: Tag key.
        :param bool passthrough: Passthrough to other related product.
        :param str value: Tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "passthrough", passthrough)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def passthrough(self) -> bool:
        """
        Passthrough to other related product.
        """
        return pulumi.get(self, "passthrough")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


