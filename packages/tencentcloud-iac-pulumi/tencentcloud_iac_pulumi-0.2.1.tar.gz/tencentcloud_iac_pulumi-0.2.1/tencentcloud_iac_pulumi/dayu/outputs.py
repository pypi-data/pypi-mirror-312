# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CcHttpPolicyRuleList',
    'CcHttpsPolicyRuleList',
    'CcPolicyV2CcBlackWhiteIp',
    'CcPolicyV2CcGeoIpPolicy',
    'CcPolicyV2CcPrecisionPolicy',
    'CcPolicyV2CcPrecisionPolicyPolicy',
    'CcPolicyV2CcPrecisionReqLimit',
    'CcPolicyV2CcPrecisionReqLimitPolicy',
    'CcPolicyV2Threshold',
    'DdosIpAttachmentV2BoundIpList',
    'DdosPolicyDropOption',
    'DdosPolicyPacketFilter',
    'DdosPolicyPortFilter',
    'DdosPolicyV2Acl',
    'DdosPolicyV2BlackWhiteIp',
    'DdosPolicyV2DdosConnectLimit',
    'DdosPolicyV2DdosGeoIpBlockConfig',
    'DdosPolicyV2DdosSpeedLimitConfig',
    'DdosPolicyV2PacketFilter',
    'DdosPolicyV2ProtocolBlockConfig',
    'DdosPolicyV2WaterPrintConfig',
    'DdosPolicyV2WaterPrintConfigListener',
    'DdosPolicyWatermarkFilter',
    'DdosPolicyWatermarkKey',
    'L4RuleSourceList',
    'L4RuleV2Rules',
    'L4RuleV2RulesSourceList',
    'L7RuleV2Rule',
    'L7RuleV2RuleSourceList',
    'GetCcHttpPoliciesListResult',
    'GetCcHttpPoliciesListRuleListResult',
    'GetCcHttpsPoliciesListResult',
    'GetCcHttpsPoliciesListRuleListResult',
    'GetDdosPoliciesListResult',
    'GetDdosPoliciesListDropOptionResult',
    'GetDdosPoliciesListPacketFilterResult',
    'GetDdosPoliciesListPortFilterResult',
    'GetDdosPoliciesListWatermarkFilterResult',
    'GetDdosPoliciesListWatermarkKeyResult',
    'GetDdosPolicyAttachmentsDayuDdosPolicyAttachmentListResult',
    'GetDdosPolicyCasesListResult',
    'GetEipListResult',
    'GetL4RulesListResult',
    'GetL4RulesListSourceListResult',
    'GetL4RulesV2ListResult',
    'GetL4RulesV2ListSourceListResult',
    'GetL7RulesListResult',
    'GetL7RulesV2ListResult',
    'GetL7RulesV2ListSourceListResult',
]

@pulumi.output_type
class CcHttpPolicyRuleList(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 skey: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the rule. Valid values: `include`, `not_include`, `equal`.
        :param str skey: Key of the rule. Valid values: `host`, `cgi`, `ua`, `referer`.
        :param str value: Rule value, then length should be less than 31 bytes.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if skey is not None:
            pulumi.set(__self__, "skey", skey)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the rule. Valid values: `include`, `not_include`, `equal`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def skey(self) -> Optional[str]:
        """
        Key of the rule. Valid values: `host`, `cgi`, `ua`, `referer`.
        """
        return pulumi.get(self, "skey")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Rule value, then length should be less than 31 bytes.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CcHttpsPolicyRuleList(dict):
    def __init__(__self__, *,
                 operator: str,
                 skey: str,
                 value: str):
        """
        :param str operator: Operator of the rule. Valid values are `include` and `equal`.
        :param str skey: Key of the rule. Valid values are `cgi`, `ua` and `referer`.
        :param str value: Rule value, then length should be less than 31 bytes.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "skey", skey)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the rule. Valid values are `include` and `equal`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def skey(self) -> str:
        """
        Key of the rule. Valid values are `cgi`, `ua` and `referer`.
        """
        return pulumi.get(self, "skey")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Rule value, then length should be less than 31 bytes.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CcPolicyV2CcBlackWhiteIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackWhiteIp":
            suggest = "black_white_ip"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "modifyTime":
            suggest = "modify_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcPolicyV2CcBlackWhiteIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcPolicyV2CcBlackWhiteIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcPolicyV2CcBlackWhiteIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 black_white_ip: str,
                 domain: str,
                 protocol: str,
                 type: str,
                 create_time: Optional[str] = None,
                 modify_time: Optional[str] = None):
        """
        :param str black_white_ip: Blacklist and whitelist IP addresses.
        :param str domain: Domain.
        :param str protocol: Protocol.
        :param str type: IP type, value [black(blacklist IP), white (whitelist IP)].
        :param str create_time: Create time.
        :param str modify_time: Modify time.
        """
        pulumi.set(__self__, "black_white_ip", black_white_ip)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "type", type)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)

    @property
    @pulumi.getter(name="blackWhiteIp")
    def black_white_ip(self) -> str:
        """
        Blacklist and whitelist IP addresses.
        """
        return pulumi.get(self, "black_white_ip")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        IP type, value [black(blacklist IP), white (whitelist IP)].
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[str]:
        """
        Modify time.
        """
        return pulumi.get(self, "modify_time")


@pulumi.output_type
class CcPolicyV2CcGeoIpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionType":
            suggest = "region_type"
        elif key == "areaLists":
            suggest = "area_lists"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "modifyTime":
            suggest = "modify_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcPolicyV2CcGeoIpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcPolicyV2CcGeoIpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcPolicyV2CcGeoIpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 domain: str,
                 protocol: str,
                 region_type: str,
                 area_lists: Optional[Sequence[int]] = None,
                 create_time: Optional[str] = None,
                 modify_time: Optional[str] = None):
        """
        :param str action: User action, drop or arg.
        :param str domain: domain.
        :param str protocol: Protocol, preferably HTTP, HTTPS.
        :param str region_type: Regional types, divided into china, oversea and customized.
        :param Sequence[int] area_lists: The list of region IDs that the user selects to block.
        :param str create_time: Create time.
        :param str modify_time: Modify time.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region_type", region_type)
        if area_lists is not None:
            pulumi.set(__self__, "area_lists", area_lists)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        User action, drop or arg.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol, preferably HTTP, HTTPS.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="regionType")
    def region_type(self) -> str:
        """
        Regional types, divided into china, oversea and customized.
        """
        return pulumi.get(self, "region_type")

    @property
    @pulumi.getter(name="areaLists")
    def area_lists(self) -> Optional[Sequence[int]]:
        """
        The list of region IDs that the user selects to block.
        """
        return pulumi.get(self, "area_lists")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[str]:
        """
        Modify time.
        """
        return pulumi.get(self, "modify_time")


@pulumi.output_type
class CcPolicyV2CcPrecisionPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyAction":
            suggest = "policy_action"
        elif key == "policyId":
            suggest = "policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcPolicyV2CcPrecisionPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcPolicyV2CcPrecisionPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcPolicyV2CcPrecisionPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 ip: str,
                 policy_action: str,
                 policys: Sequence['outputs.CcPolicyV2CcPrecisionPolicyPolicy'],
                 protocol: str,
                 policy_id: Optional[str] = None):
        """
        :param str domain: Domain.
        :param str ip: Ip address.
        :param str policy_action: Policy mode (discard or captcha).
        :param Sequence['CcPolicyV2CcPrecisionPolicyPolicyArgs'] policys: A list of policies.
        :param str protocol: Protocol.
        :param str policy_id: Policy Id.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "policy_action", policy_action)
        pulumi.set(__self__, "policys", policys)
        pulumi.set(__self__, "protocol", protocol)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        Ip address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="policyAction")
    def policy_action(self) -> str:
        """
        Policy mode (discard or captcha).
        """
        return pulumi.get(self, "policy_action")

    @property
    @pulumi.getter
    def policys(self) -> Sequence['outputs.CcPolicyV2CcPrecisionPolicyPolicy']:
        """
        A list of policies.
        """
        return pulumi.get(self, "policys")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        """
        Policy Id.
        """
        return pulumi.get(self, "policy_id")


@pulumi.output_type
class CcPolicyV2CcPrecisionPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"
        elif key == "valueOperator":
            suggest = "value_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcPolicyV2CcPrecisionPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcPolicyV2CcPrecisionPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcPolicyV2CcPrecisionPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 value: str,
                 value_operator: str):
        """
        :param str field_name: Configuration item types, currently only support value.
        :param str field_type: Configuration fields with the desirable values cgi, ua, cookie, referer, accept, srcip.
        :param str value: Configure the value.
        :param str value_operator: Configure the item-value comparison mode, which can be taken as the value of evaluate, not_equal, include.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_operator", value_operator)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Configuration item types, currently only support value.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        """
        Configuration fields with the desirable values cgi, ua, cookie, referer, accept, srcip.
        """
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Configure the value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueOperator")
    def value_operator(self) -> str:
        """
        Configure the item-value comparison mode, which can be taken as the value of evaluate, not_equal, include.
        """
        return pulumi.get(self, "value_operator")


@pulumi.output_type
class CcPolicyV2CcPrecisionReqLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcPolicyV2CcPrecisionReqLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcPolicyV2CcPrecisionReqLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcPolicyV2CcPrecisionReqLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 level: str,
                 policys: Sequence['outputs.CcPolicyV2CcPrecisionReqLimitPolicy'],
                 protocol: str,
                 instance_id: Optional[str] = None,
                 ip: Optional[str] = None):
        """
        :param str domain: Domain.
        :param str level: Protection rating, the optional value of default means default policy, loose means loose, and strict means strict.
        :param Sequence['CcPolicyV2CcPrecisionReqLimitPolicyArgs'] policys: The CC Frequency Limit Policy Item field.
        :param str protocol: Protocol, preferably HTTP, HTTPS.
        :param str instance_id: Instance id.
        :param str ip: Ip address.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "policys", policys)
        pulumi.set(__self__, "protocol", protocol)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        Protection rating, the optional value of default means default policy, loose means loose, and strict means strict.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def policys(self) -> Sequence['outputs.CcPolicyV2CcPrecisionReqLimitPolicy']:
        """
        The CC Frequency Limit Policy Item field.
        """
        return pulumi.get(self, "policys")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol, preferably HTTP, HTTPS.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Ip address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class CcPolicyV2CcPrecisionReqLimitPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executeDuration":
            suggest = "execute_duration"
        elif key == "requestNum":
            suggest = "request_num"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcPolicyV2CcPrecisionReqLimitPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcPolicyV2CcPrecisionReqLimitPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcPolicyV2CcPrecisionReqLimitPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 execute_duration: int,
                 mode: str,
                 period: int,
                 request_num: int,
                 cookie: Optional[str] = None,
                 uri: Optional[str] = None,
                 user_agent: Optional[str] = None):
        """
        :param str action: The frequency limit policy mode, the optional value of arg indicates the verification code, and drop indicates the discard.
        :param int execute_duration: The duration of the frequency limit policy can be taken from 1 to 86400 per second.
        :param str mode: The policy item is compared, and the optional value include indicates inclusion, and equal means equal.
        :param int period: Statistical period, take values 1, 10, 30, 60, in seconds.
        :param int request_num: The number of requests, the value is 1 to 20000.
        :param str cookie: Cookies, one of the three policy entries can only be filled in.
        :param str uri: Uri, one of the three policy entries can only be filled in.
        :param str user_agent: User-Agent, only one of the three policy entries can be filled in.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "execute_duration", execute_duration)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "request_num", request_num)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The frequency limit policy mode, the optional value of arg indicates the verification code, and drop indicates the discard.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="executeDuration")
    def execute_duration(self) -> int:
        """
        The duration of the frequency limit policy can be taken from 1 to 86400 per second.
        """
        return pulumi.get(self, "execute_duration")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The policy item is compared, and the optional value include indicates inclusion, and equal means equal.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def period(self) -> int:
        """
        Statistical period, take values 1, 10, 30, 60, in seconds.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="requestNum")
    def request_num(self) -> int:
        """
        The number of requests, the value is 1 to 20000.
        """
        return pulumi.get(self, "request_num")

    @property
    @pulumi.getter
    def cookie(self) -> Optional[str]:
        """
        Cookies, one of the three policy entries can only be filled in.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Uri, one of the three policy entries can only be filled in.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        """
        User-Agent, only one of the three policy entries can be filled in.
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class CcPolicyV2Threshold(dict):
    def __init__(__self__, *,
                 domain: str,
                 threshold: int):
        """
        :param str domain: domain.
        :param int threshold: Cleaning threshold, -1 indicates that the `default` mode is turned on.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Cleaning threshold, -1 indicates that the `default` mode is turned on.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DdosIpAttachmentV2BoundIpList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bizType":
            suggest = "biz_type"
        elif key == "deviceType":
            suggest = "device_type"
        elif key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosIpAttachmentV2BoundIpList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosIpAttachmentV2BoundIpList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosIpAttachmentV2BoundIpList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 biz_type: Optional[str] = None,
                 device_type: Optional[str] = None,
                 instance_id: Optional[str] = None):
        """
        :param str ip: IP address.
        :param str biz_type: Category of product that can be bound. Valid values: public (CVM and CLB), bm (BM), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), and other (hosted IP). This field is required when you perform binding.
        :param str device_type: Sub-product category. Valid values: cvm (CVM), lb (Load balancer), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), eip (BM EIP) and other (managed IP). This field is required when you perform binding.
        :param str instance_id: Anti-DDoS instance ID of the IP. This field is required only when the instance is bound to an IP. For example, this field InstanceId will be eni-* if the instance ID is bound to an ENI IP; none if there is no instance to bind to a managed IP.
        """
        pulumi.set(__self__, "ip", ip)
        if biz_type is not None:
            pulumi.set(__self__, "biz_type", biz_type)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="bizType")
    def biz_type(self) -> Optional[str]:
        """
        Category of product that can be bound. Valid values: public (CVM and CLB), bm (BM), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), and other (hosted IP). This field is required when you perform binding.
        """
        return pulumi.get(self, "biz_type")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[str]:
        """
        Sub-product category. Valid values: cvm (CVM), lb (Load balancer), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), eip (BM EIP) and other (managed IP). This field is required when you perform binding.
        """
        return pulumi.get(self, "device_type")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        Anti-DDoS instance ID of the IP. This field is required only when the instance is bound to an IP. For example, this field InstanceId will be eni-* if the instance ID is bound to an ENI IP; none if there is no instance to bind to a managed IP.
        """
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class DdosPolicyDropOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "badConnThreshold":
            suggest = "bad_conn_threshold"
        elif key == "checkSyncConn":
            suggest = "check_sync_conn"
        elif key == "connTimeout":
            suggest = "conn_timeout"
        elif key == "dConnLimit":
            suggest = "d_conn_limit"
        elif key == "dNewLimit":
            suggest = "d_new_limit"
        elif key == "dropAbroad":
            suggest = "drop_abroad"
        elif key == "dropIcmp":
            suggest = "drop_icmp"
        elif key == "dropOther":
            suggest = "drop_other"
        elif key == "dropTcp":
            suggest = "drop_tcp"
        elif key == "dropUdp":
            suggest = "drop_udp"
        elif key == "icmpMbpsLimit":
            suggest = "icmp_mbps_limit"
        elif key == "nullConnEnable":
            suggest = "null_conn_enable"
        elif key == "otherMbpsLimit":
            suggest = "other_mbps_limit"
        elif key == "sConnLimit":
            suggest = "s_conn_limit"
        elif key == "sNewLimit":
            suggest = "s_new_limit"
        elif key == "synLimit":
            suggest = "syn_limit"
        elif key == "tcpMbpsLimit":
            suggest = "tcp_mbps_limit"
        elif key == "udpMbpsLimit":
            suggest = "udp_mbps_limit"
        elif key == "synRate":
            suggest = "syn_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyDropOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyDropOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyDropOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bad_conn_threshold: int,
                 check_sync_conn: bool,
                 conn_timeout: int,
                 d_conn_limit: int,
                 d_new_limit: int,
                 drop_abroad: bool,
                 drop_icmp: bool,
                 drop_other: bool,
                 drop_tcp: bool,
                 drop_udp: bool,
                 icmp_mbps_limit: int,
                 null_conn_enable: bool,
                 other_mbps_limit: int,
                 s_conn_limit: int,
                 s_new_limit: int,
                 syn_limit: int,
                 tcp_mbps_limit: int,
                 udp_mbps_limit: int,
                 syn_rate: Optional[int] = None):
        """
        :param int bad_conn_threshold: The number of new connections based on destination IP that trigger suppression of connections. Valid value ranges: (0~4294967295).
        :param bool check_sync_conn: Indicate whether to check null connection or not.
        :param int conn_timeout: Connection timeout of abnormal connection check. Valid value ranges: (0~65535).
        :param int d_conn_limit: The limit of concurrent connections based on destination IP. Valid value ranges: (0~4294967295).
        :param int d_new_limit: The limit of new connections based on destination IP. Valid value ranges: (0~4294967295).
        :param bool drop_abroad: Indicate whether to drop abroad traffic or not.
        :param bool drop_icmp: Indicate whether to drop ICMP protocol or not.
        :param bool drop_other: Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
        :param bool drop_tcp: Indicate whether to drop TCP protocol or not.
        :param bool drop_udp: Indicate to drop UDP protocol or not.
        :param int icmp_mbps_limit: The limit of ICMP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        :param bool null_conn_enable: Indicate to enable null connection or not.
        :param int other_mbps_limit: The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        :param int s_conn_limit: The limit of concurrent connections based on source IP. Valid value ranges: (0~4294967295).
        :param int s_new_limit: The limit of new connections based on source IP. Valid value ranges: (0~4294967295).
        :param int syn_limit: The limit of syn of abnormal connection check. Valid value ranges: (0~100).
        :param int tcp_mbps_limit: The limit of TCP traffic. Valid value ranges: (0~4294967295)(Mbps).
        :param int udp_mbps_limit: The limit of UDP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        :param int syn_rate: The percentage of syn in ack of abnormal connection check. Valid value ranges: (0~100).
        """
        pulumi.set(__self__, "bad_conn_threshold", bad_conn_threshold)
        pulumi.set(__self__, "check_sync_conn", check_sync_conn)
        pulumi.set(__self__, "conn_timeout", conn_timeout)
        pulumi.set(__self__, "d_conn_limit", d_conn_limit)
        pulumi.set(__self__, "d_new_limit", d_new_limit)
        pulumi.set(__self__, "drop_abroad", drop_abroad)
        pulumi.set(__self__, "drop_icmp", drop_icmp)
        pulumi.set(__self__, "drop_other", drop_other)
        pulumi.set(__self__, "drop_tcp", drop_tcp)
        pulumi.set(__self__, "drop_udp", drop_udp)
        pulumi.set(__self__, "icmp_mbps_limit", icmp_mbps_limit)
        pulumi.set(__self__, "null_conn_enable", null_conn_enable)
        pulumi.set(__self__, "other_mbps_limit", other_mbps_limit)
        pulumi.set(__self__, "s_conn_limit", s_conn_limit)
        pulumi.set(__self__, "s_new_limit", s_new_limit)
        pulumi.set(__self__, "syn_limit", syn_limit)
        pulumi.set(__self__, "tcp_mbps_limit", tcp_mbps_limit)
        pulumi.set(__self__, "udp_mbps_limit", udp_mbps_limit)
        if syn_rate is not None:
            pulumi.set(__self__, "syn_rate", syn_rate)

    @property
    @pulumi.getter(name="badConnThreshold")
    def bad_conn_threshold(self) -> int:
        """
        The number of new connections based on destination IP that trigger suppression of connections. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "bad_conn_threshold")

    @property
    @pulumi.getter(name="checkSyncConn")
    def check_sync_conn(self) -> bool:
        """
        Indicate whether to check null connection or not.
        """
        return pulumi.get(self, "check_sync_conn")

    @property
    @pulumi.getter(name="connTimeout")
    def conn_timeout(self) -> int:
        """
        Connection timeout of abnormal connection check. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "conn_timeout")

    @property
    @pulumi.getter(name="dConnLimit")
    def d_conn_limit(self) -> int:
        """
        The limit of concurrent connections based on destination IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "d_conn_limit")

    @property
    @pulumi.getter(name="dNewLimit")
    def d_new_limit(self) -> int:
        """
        The limit of new connections based on destination IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "d_new_limit")

    @property
    @pulumi.getter(name="dropAbroad")
    def drop_abroad(self) -> bool:
        """
        Indicate whether to drop abroad traffic or not.
        """
        return pulumi.get(self, "drop_abroad")

    @property
    @pulumi.getter(name="dropIcmp")
    def drop_icmp(self) -> bool:
        """
        Indicate whether to drop ICMP protocol or not.
        """
        return pulumi.get(self, "drop_icmp")

    @property
    @pulumi.getter(name="dropOther")
    def drop_other(self) -> bool:
        """
        Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
        """
        return pulumi.get(self, "drop_other")

    @property
    @pulumi.getter(name="dropTcp")
    def drop_tcp(self) -> bool:
        """
        Indicate whether to drop TCP protocol or not.
        """
        return pulumi.get(self, "drop_tcp")

    @property
    @pulumi.getter(name="dropUdp")
    def drop_udp(self) -> bool:
        """
        Indicate to drop UDP protocol or not.
        """
        return pulumi.get(self, "drop_udp")

    @property
    @pulumi.getter(name="icmpMbpsLimit")
    def icmp_mbps_limit(self) -> int:
        """
        The limit of ICMP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "icmp_mbps_limit")

    @property
    @pulumi.getter(name="nullConnEnable")
    def null_conn_enable(self) -> bool:
        """
        Indicate to enable null connection or not.
        """
        return pulumi.get(self, "null_conn_enable")

    @property
    @pulumi.getter(name="otherMbpsLimit")
    def other_mbps_limit(self) -> int:
        """
        The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "other_mbps_limit")

    @property
    @pulumi.getter(name="sConnLimit")
    def s_conn_limit(self) -> int:
        """
        The limit of concurrent connections based on source IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "s_conn_limit")

    @property
    @pulumi.getter(name="sNewLimit")
    def s_new_limit(self) -> int:
        """
        The limit of new connections based on source IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "s_new_limit")

    @property
    @pulumi.getter(name="synLimit")
    def syn_limit(self) -> int:
        """
        The limit of syn of abnormal connection check. Valid value ranges: (0~100).
        """
        return pulumi.get(self, "syn_limit")

    @property
    @pulumi.getter(name="tcpMbpsLimit")
    def tcp_mbps_limit(self) -> int:
        """
        The limit of TCP traffic. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "tcp_mbps_limit")

    @property
    @pulumi.getter(name="udpMbpsLimit")
    def udp_mbps_limit(self) -> int:
        """
        The limit of UDP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "udp_mbps_limit")

    @property
    @pulumi.getter(name="synRate")
    def syn_rate(self) -> Optional[int]:
        """
        The percentage of syn in ack of abnormal connection check. Valid value ranges: (0~100).
        """
        return pulumi.get(self, "syn_rate")


@pulumi.output_type
class DdosPolicyPacketFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dEndPort":
            suggest = "d_end_port"
        elif key == "dStartPort":
            suggest = "d_start_port"
        elif key == "isInclude":
            suggest = "is_include"
        elif key == "matchBegin":
            suggest = "match_begin"
        elif key == "matchStr":
            suggest = "match_str"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "pktLengthMax":
            suggest = "pkt_length_max"
        elif key == "pktLengthMin":
            suggest = "pkt_length_min"
        elif key == "sEndPort":
            suggest = "s_end_port"
        elif key == "sStartPort":
            suggest = "s_start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyPacketFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyPacketFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyPacketFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 d_end_port: Optional[int] = None,
                 d_start_port: Optional[int] = None,
                 depth: Optional[int] = None,
                 is_include: Optional[bool] = None,
                 match_begin: Optional[str] = None,
                 match_str: Optional[str] = None,
                 match_type: Optional[str] = None,
                 offset: Optional[int] = None,
                 pkt_length_max: Optional[int] = None,
                 pkt_length_min: Optional[int] = None,
                 protocol: Optional[str] = None,
                 s_end_port: Optional[int] = None,
                 s_start_port: Optional[int] = None):
        """
        :param str action: Action of port to take. Valid values: `drop`, `drop_black`,`drop_rst`,`drop_black_rst`,`transmit`.`drop`(drop the packet), `drop_black`(drop the packet and black the ip),`drop_rst`(drop the packet and disconnect),`drop_black_rst`(drop the packet, black the ip and disconnect),`transmit`(transmit the packet).
        :param int d_end_port: End port of the destination. Valid value ranges: (0~65535). It must be greater than `d_start_port`.
        :param int d_start_port: Start port of the destination. Valid value ranges: (0~65535).
        :param int depth: The depth of match. Valid value ranges: (0~1500).
        :param bool is_include: Indicate whether to include the key word/regular expression or not.
        :param str match_begin: Indicate whether to check load or not, `begin_l5` means to match and `no_match` means not.
        :param str match_str: The key word or regular expression.
        :param str match_type: Match type. Valid values: `sunday` and `pcre`. `sunday` means key word match while `pcre` means regular match.
        :param int offset: The offset of match. Valid value ranges: (0~1500).
        :param int pkt_length_max: The max length of the packet. Valid value ranges: (0~1500)(Mbps). It must be greater than `pkt_length_min`.
        :param int pkt_length_min: The minimum length of the packet. Valid value ranges: (0~1500)(Mbps).
        :param str protocol: Protocol. Valid values: `tcp`, `udp`, `icmp`, `all`.
        :param int s_end_port: End port of the source. Valid value ranges: (0~65535). It must be greater than `s_start_port`.
        :param int s_start_port: Start port of the source. Valid value ranges: (0~65535).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if d_end_port is not None:
            pulumi.set(__self__, "d_end_port", d_end_port)
        if d_start_port is not None:
            pulumi.set(__self__, "d_start_port", d_start_port)
        if depth is not None:
            pulumi.set(__self__, "depth", depth)
        if is_include is not None:
            pulumi.set(__self__, "is_include", is_include)
        if match_begin is not None:
            pulumi.set(__self__, "match_begin", match_begin)
        if match_str is not None:
            pulumi.set(__self__, "match_str", match_str)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if pkt_length_max is not None:
            pulumi.set(__self__, "pkt_length_max", pkt_length_max)
        if pkt_length_min is not None:
            pulumi.set(__self__, "pkt_length_min", pkt_length_min)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if s_end_port is not None:
            pulumi.set(__self__, "s_end_port", s_end_port)
        if s_start_port is not None:
            pulumi.set(__self__, "s_start_port", s_start_port)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action of port to take. Valid values: `drop`, `drop_black`,`drop_rst`,`drop_black_rst`,`transmit`.`drop`(drop the packet), `drop_black`(drop the packet and black the ip),`drop_rst`(drop the packet and disconnect),`drop_black_rst`(drop the packet, black the ip and disconnect),`transmit`(transmit the packet).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="dEndPort")
    def d_end_port(self) -> Optional[int]:
        """
        End port of the destination. Valid value ranges: (0~65535). It must be greater than `d_start_port`.
        """
        return pulumi.get(self, "d_end_port")

    @property
    @pulumi.getter(name="dStartPort")
    def d_start_port(self) -> Optional[int]:
        """
        Start port of the destination. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "d_start_port")

    @property
    @pulumi.getter
    def depth(self) -> Optional[int]:
        """
        The depth of match. Valid value ranges: (0~1500).
        """
        return pulumi.get(self, "depth")

    @property
    @pulumi.getter(name="isInclude")
    def is_include(self) -> Optional[bool]:
        """
        Indicate whether to include the key word/regular expression or not.
        """
        return pulumi.get(self, "is_include")

    @property
    @pulumi.getter(name="matchBegin")
    def match_begin(self) -> Optional[str]:
        """
        Indicate whether to check load or not, `begin_l5` means to match and `no_match` means not.
        """
        return pulumi.get(self, "match_begin")

    @property
    @pulumi.getter(name="matchStr")
    def match_str(self) -> Optional[str]:
        """
        The key word or regular expression.
        """
        return pulumi.get(self, "match_str")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        Match type. Valid values: `sunday` and `pcre`. `sunday` means key word match while `pcre` means regular match.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def offset(self) -> Optional[int]:
        """
        The offset of match. Valid value ranges: (0~1500).
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter(name="pktLengthMax")
    def pkt_length_max(self) -> Optional[int]:
        """
        The max length of the packet. Valid value ranges: (0~1500)(Mbps). It must be greater than `pkt_length_min`.
        """
        return pulumi.get(self, "pkt_length_max")

    @property
    @pulumi.getter(name="pktLengthMin")
    def pkt_length_min(self) -> Optional[int]:
        """
        The minimum length of the packet. Valid value ranges: (0~1500)(Mbps).
        """
        return pulumi.get(self, "pkt_length_min")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol. Valid values: `tcp`, `udp`, `icmp`, `all`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sEndPort")
    def s_end_port(self) -> Optional[int]:
        """
        End port of the source. Valid value ranges: (0~65535). It must be greater than `s_start_port`.
        """
        return pulumi.get(self, "s_end_port")

    @property
    @pulumi.getter(name="sStartPort")
    def s_start_port(self) -> Optional[int]:
        """
        Start port of the source. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "s_start_port")


@pulumi.output_type
class DdosPolicyPortFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyPortFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyPortFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyPortFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 end_port: Optional[int] = None,
                 kind: Optional[int] = None,
                 protocol: Optional[str] = None,
                 start_port: Optional[int] = None):
        """
        :param str action: Action of port to take. Valid values: `drop`, `transmit`.
        :param int end_port: End port. Valid value ranges: (0~65535). It must be greater than `start_port`.
        :param int kind: The type of forbidden port. Valid values: `0`, `1`, `2`. `0` for destination ports make effect, `1` for source ports make effect. `2` for both destination and source ports.
        :param str protocol: Protocol. Valid values are `tcp`, `udp`, `icmp`, `all`.
        :param int start_port: Start port. Valid value ranges: (0~65535).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action of port to take. Valid values: `drop`, `transmit`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        End port. Valid value ranges: (0~65535). It must be greater than `start_port`.
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def kind(self) -> Optional[int]:
        """
        The type of forbidden port. Valid values: `0`, `1`, `2`. `0` for destination ports make effect, `1` for source ports make effect. `2` for both destination and source ports.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol. Valid values are `tcp`, `udp`, `icmp`, `all`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Start port. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class DdosPolicyV2Acl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dPortEnd":
            suggest = "d_port_end"
        elif key == "dPortStart":
            suggest = "d_port_start"
        elif key == "forwardProtocol":
            suggest = "forward_protocol"
        elif key == "sPortEnd":
            suggest = "s_port_end"
        elif key == "sPortStart":
            suggest = "s_port_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2Acl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2Acl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2Acl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 d_port_end: int,
                 d_port_start: int,
                 forward_protocol: str,
                 priority: int,
                 s_port_end: int,
                 s_port_start: int):
        """
        :param str action: Action, optional values: drop, transmit, forward.
        :param int d_port_end: The destination port ends, and the value range is 0~65535.
        :param int d_port_start: The destination port starts, and the value range is 0~65535.
        :param str forward_protocol: Protocol type, desirable values tcp, udp, all.
        :param int priority: Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
        :param int s_port_end: The source port ends, and the acceptable value ranges from 0 to 65535.
        :param int s_port_start: The source port starts, and the value range is 0~65535.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "d_port_end", d_port_end)
        pulumi.set(__self__, "d_port_start", d_port_start)
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "s_port_end", s_port_end)
        pulumi.set(__self__, "s_port_start", s_port_start)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action, optional values: drop, transmit, forward.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="dPortEnd")
    def d_port_end(self) -> int:
        """
        The destination port ends, and the value range is 0~65535.
        """
        return pulumi.get(self, "d_port_end")

    @property
    @pulumi.getter(name="dPortStart")
    def d_port_start(self) -> int:
        """
        The destination port starts, and the value range is 0~65535.
        """
        return pulumi.get(self, "d_port_start")

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> str:
        """
        Protocol type, desirable values tcp, udp, all.
        """
        return pulumi.get(self, "forward_protocol")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="sPortEnd")
    def s_port_end(self) -> int:
        """
        The source port ends, and the acceptable value ranges from 0 to 65535.
        """
        return pulumi.get(self, "s_port_end")

    @property
    @pulumi.getter(name="sPortStart")
    def s_port_start(self) -> int:
        """
        The source port starts, and the value range is 0~65535.
        """
        return pulumi.get(self, "s_port_start")


@pulumi.output_type
class DdosPolicyV2BlackWhiteIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2BlackWhiteIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2BlackWhiteIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2BlackWhiteIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 ip_type: str):
        """
        :param str ip: Ip of resource instance.
        :param str ip_type: IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_type", ip_type)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        Ip of resource instance.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> str:
        """
        IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
        """
        return pulumi.get(self, "ip_type")


@pulumi.output_type
class DdosPolicyV2DdosConnectLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "badConnThreshold":
            suggest = "bad_conn_threshold"
        elif key == "connTimeout":
            suggest = "conn_timeout"
        elif key == "dstConnLimit":
            suggest = "dst_conn_limit"
        elif key == "dstNewLimit":
            suggest = "dst_new_limit"
        elif key == "nullConnEnable":
            suggest = "null_conn_enable"
        elif key == "sdConnLimit":
            suggest = "sd_conn_limit"
        elif key == "sdNewLimit":
            suggest = "sd_new_limit"
        elif key == "synLimit":
            suggest = "syn_limit"
        elif key == "synRate":
            suggest = "syn_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2DdosConnectLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2DdosConnectLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2DdosConnectLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bad_conn_threshold: int,
                 conn_timeout: int,
                 dst_conn_limit: int,
                 dst_new_limit: int,
                 null_conn_enable: int,
                 sd_conn_limit: int,
                 sd_new_limit: int,
                 syn_limit: int,
                 syn_rate: int):
        """
        :param int bad_conn_threshold: Based on connection suppression trigger threshold, value range [0,4294967295].
        :param int conn_timeout: Abnormal connection detection condition, connection timeout, value range [0,65535].
        :param int dst_conn_limit: Concurrent connection control based on destination IP+ destination port.
        :param int dst_new_limit: Limit on the number of news per second based on the destination IP.
        :param int null_conn_enable: Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
        :param int sd_conn_limit: Concurrent connection control based on source IP + destination IP.
        :param int sd_new_limit: The limit on the number of news per second based on source IP + destination IP.
        :param int syn_limit: Anomaly connection detection condition, syn threshold, value range [0,100].
        :param int syn_rate: Anomalous connection detection condition, percentage of syn ack, value range [0,100].
        """
        pulumi.set(__self__, "bad_conn_threshold", bad_conn_threshold)
        pulumi.set(__self__, "conn_timeout", conn_timeout)
        pulumi.set(__self__, "dst_conn_limit", dst_conn_limit)
        pulumi.set(__self__, "dst_new_limit", dst_new_limit)
        pulumi.set(__self__, "null_conn_enable", null_conn_enable)
        pulumi.set(__self__, "sd_conn_limit", sd_conn_limit)
        pulumi.set(__self__, "sd_new_limit", sd_new_limit)
        pulumi.set(__self__, "syn_limit", syn_limit)
        pulumi.set(__self__, "syn_rate", syn_rate)

    @property
    @pulumi.getter(name="badConnThreshold")
    def bad_conn_threshold(self) -> int:
        """
        Based on connection suppression trigger threshold, value range [0,4294967295].
        """
        return pulumi.get(self, "bad_conn_threshold")

    @property
    @pulumi.getter(name="connTimeout")
    def conn_timeout(self) -> int:
        """
        Abnormal connection detection condition, connection timeout, value range [0,65535].
        """
        return pulumi.get(self, "conn_timeout")

    @property
    @pulumi.getter(name="dstConnLimit")
    def dst_conn_limit(self) -> int:
        """
        Concurrent connection control based on destination IP+ destination port.
        """
        return pulumi.get(self, "dst_conn_limit")

    @property
    @pulumi.getter(name="dstNewLimit")
    def dst_new_limit(self) -> int:
        """
        Limit on the number of news per second based on the destination IP.
        """
        return pulumi.get(self, "dst_new_limit")

    @property
    @pulumi.getter(name="nullConnEnable")
    def null_conn_enable(self) -> int:
        """
        Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
        """
        return pulumi.get(self, "null_conn_enable")

    @property
    @pulumi.getter(name="sdConnLimit")
    def sd_conn_limit(self) -> int:
        """
        Concurrent connection control based on source IP + destination IP.
        """
        return pulumi.get(self, "sd_conn_limit")

    @property
    @pulumi.getter(name="sdNewLimit")
    def sd_new_limit(self) -> int:
        """
        The limit on the number of news per second based on source IP + destination IP.
        """
        return pulumi.get(self, "sd_new_limit")

    @property
    @pulumi.getter(name="synLimit")
    def syn_limit(self) -> int:
        """
        Anomaly connection detection condition, syn threshold, value range [0,100].
        """
        return pulumi.get(self, "syn_limit")

    @property
    @pulumi.getter(name="synRate")
    def syn_rate(self) -> int:
        """
        Anomalous connection detection condition, percentage of syn ack, value range [0,100].
        """
        return pulumi.get(self, "syn_rate")


@pulumi.output_type
class DdosPolicyV2DdosGeoIpBlockConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaLists":
            suggest = "area_lists"
        elif key == "regionType":
            suggest = "region_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2DdosGeoIpBlockConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2DdosGeoIpBlockConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2DdosGeoIpBlockConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 area_lists: Sequence[int],
                 region_type: str):
        """
        :param str action: Block action, take the value [`drop`, `trans`].
        :param Sequence[int] area_lists: When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
        :param str region_type: Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "area_lists", area_lists)
        pulumi.set(__self__, "region_type", region_type)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Block action, take the value [`drop`, `trans`].
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="areaLists")
    def area_lists(self) -> Sequence[int]:
        """
        When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
        """
        return pulumi.get(self, "area_lists")

    @property
    @pulumi.getter(name="regionType")
    def region_type(self) -> str:
        """
        Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
        """
        return pulumi.get(self, "region_type")


@pulumi.output_type
class DdosPolicyV2DdosSpeedLimitConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstPortList":
            suggest = "dst_port_list"
        elif key == "packetRate":
            suggest = "packet_rate"
        elif key == "protocolList":
            suggest = "protocol_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2DdosSpeedLimitConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2DdosSpeedLimitConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2DdosSpeedLimitConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: int,
                 dst_port_list: str,
                 mode: int,
                 packet_rate: int,
                 protocol_list: str):
        """
        :param int bandwidth: Bandwidth bps.
        :param str dst_port_list: List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
        :param int mode: Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
        :param int packet_rate: Packet rate pps.
        :param str protocol_list: IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "dst_port_list", dst_port_list)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "packet_rate", packet_rate)
        pulumi.set(__self__, "protocol_list", protocol_list)

    @property
    @pulumi.getter
    def bandwidth(self) -> int:
        """
        Bandwidth bps.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="dstPortList")
    def dst_port_list(self) -> str:
        """
        List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
        """
        return pulumi.get(self, "dst_port_list")

    @property
    @pulumi.getter
    def mode(self) -> int:
        """
        Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="packetRate")
    def packet_rate(self) -> int:
        """
        Packet rate pps.
        """
        return pulumi.get(self, "packet_rate")

    @property
    @pulumi.getter(name="protocolList")
    def protocol_list(self) -> str:
        """
        IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
        """
        return pulumi.get(self, "protocol_list")


@pulumi.output_type
class DdosPolicyV2PacketFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dPortEnd":
            suggest = "d_port_end"
        elif key == "dPortStart":
            suggest = "d_port_start"
        elif key == "isNot":
            suggest = "is_not"
        elif key == "isNot2":
            suggest = "is_not2"
        elif key == "matchBegin":
            suggest = "match_begin"
        elif key == "matchBegin2":
            suggest = "match_begin2"
        elif key == "matchLogic":
            suggest = "match_logic"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "matchType2":
            suggest = "match_type2"
        elif key == "pktlenMax":
            suggest = "pktlen_max"
        elif key == "pktlenMin":
            suggest = "pktlen_min"
        elif key == "sPortEnd":
            suggest = "s_port_end"
        elif key == "sPortStart":
            suggest = "s_port_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2PacketFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2PacketFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2PacketFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 d_port_end: int,
                 d_port_start: int,
                 depth: int,
                 depth2: int,
                 is_not: int,
                 is_not2: int,
                 match_begin: str,
                 match_begin2: str,
                 match_logic: str,
                 match_type: str,
                 match_type2: str,
                 offset: int,
                 offset2: int,
                 pktlen_max: int,
                 pktlen_min: int,
                 protocol: str,
                 s_port_end: int,
                 s_port_start: int,
                 str: str,
                 str2: str):
        """
        :param str action: Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
        :param int d_port_end: The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
        :param int d_port_start: From the destination port, take the value 0~65535.
        :param int depth: Detection depth from the detection position, value [0,1500].
        :param int depth2: Second detection depth starting from the second detection position, value [0,1500].
        :param int is_not: Whether to include the detected value, take the value [0 (included),1 (not included)].
        :param int is_not2: Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
        :param str match_begin: Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        :param str match_begin2: The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        :param str match_logic: When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
        :param str match_type: Detection type, value [sunday (keyword),pcre (regular expression)].
        :param str match_type2: The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
        :param int offset: Offset from detection position, value range [0, Depth].
        :param int offset2: Offset from the second detection position, value range [0,Depth2].
        :param int pktlen_max: The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
        :param int pktlen_min: Minimum message length, 1-1500.
        :param str protocol: Protocol, value [tcp udp icmp all].
        :param int s_port_end: End source port, take the value 1~65535, must be greater than or equal to the starting source port.
        :param int s_port_start: Start the source port, take the value 0~65535.
        :param str str: Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        :param str str2: The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "d_port_end", d_port_end)
        pulumi.set(__self__, "d_port_start", d_port_start)
        pulumi.set(__self__, "depth", depth)
        pulumi.set(__self__, "depth2", depth2)
        pulumi.set(__self__, "is_not", is_not)
        pulumi.set(__self__, "is_not2", is_not2)
        pulumi.set(__self__, "match_begin", match_begin)
        pulumi.set(__self__, "match_begin2", match_begin2)
        pulumi.set(__self__, "match_logic", match_logic)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "match_type2", match_type2)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "offset2", offset2)
        pulumi.set(__self__, "pktlen_max", pktlen_max)
        pulumi.set(__self__, "pktlen_min", pktlen_min)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "s_port_end", s_port_end)
        pulumi.set(__self__, "s_port_start", s_port_start)
        pulumi.set(__self__, "str", str)
        pulumi.set(__self__, "str2", str2)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="dPortEnd")
    def d_port_end(self) -> int:
        """
        The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
        """
        return pulumi.get(self, "d_port_end")

    @property
    @pulumi.getter(name="dPortStart")
    def d_port_start(self) -> int:
        """
        From the destination port, take the value 0~65535.
        """
        return pulumi.get(self, "d_port_start")

    @property
    @pulumi.getter
    def depth(self) -> int:
        """
        Detection depth from the detection position, value [0,1500].
        """
        return pulumi.get(self, "depth")

    @property
    @pulumi.getter
    def depth2(self) -> int:
        """
        Second detection depth starting from the second detection position, value [0,1500].
        """
        return pulumi.get(self, "depth2")

    @property
    @pulumi.getter(name="isNot")
    def is_not(self) -> int:
        """
        Whether to include the detected value, take the value [0 (included),1 (not included)].
        """
        return pulumi.get(self, "is_not")

    @property
    @pulumi.getter(name="isNot2")
    def is_not2(self) -> int:
        """
        Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
        """
        return pulumi.get(self, "is_not2")

    @property
    @pulumi.getter(name="matchBegin")
    def match_begin(self) -> str:
        """
        Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        """
        return pulumi.get(self, "match_begin")

    @property
    @pulumi.getter(name="matchBegin2")
    def match_begin2(self) -> str:
        """
        The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        """
        return pulumi.get(self, "match_begin2")

    @property
    @pulumi.getter(name="matchLogic")
    def match_logic(self) -> str:
        """
        When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
        """
        return pulumi.get(self, "match_logic")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        """
        Detection type, value [sunday (keyword),pcre (regular expression)].
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="matchType2")
    def match_type2(self) -> str:
        """
        The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
        """
        return pulumi.get(self, "match_type2")

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        Offset from detection position, value range [0, Depth].
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter
    def offset2(self) -> int:
        """
        Offset from the second detection position, value range [0,Depth2].
        """
        return pulumi.get(self, "offset2")

    @property
    @pulumi.getter(name="pktlenMax")
    def pktlen_max(self) -> int:
        """
        The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
        """
        return pulumi.get(self, "pktlen_max")

    @property
    @pulumi.getter(name="pktlenMin")
    def pktlen_min(self) -> int:
        """
        Minimum message length, 1-1500.
        """
        return pulumi.get(self, "pktlen_min")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol, value [tcp udp icmp all].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sPortEnd")
    def s_port_end(self) -> int:
        """
        End source port, take the value 1~65535, must be greater than or equal to the starting source port.
        """
        return pulumi.get(self, "s_port_end")

    @property
    @pulumi.getter(name="sPortStart")
    def s_port_start(self) -> int:
        """
        Start the source port, take the value 0~65535.
        """
        return pulumi.get(self, "s_port_start")

    @property
    @pulumi.getter
    def str(self) -> str:
        """
        Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        """
        return pulumi.get(self, "str")

    @property
    @pulumi.getter
    def str2(self) -> str:
        """
        The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        """
        return pulumi.get(self, "str2")


@pulumi.output_type
class DdosPolicyV2ProtocolBlockConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropIcmp":
            suggest = "drop_icmp"
        elif key == "dropOther":
            suggest = "drop_other"
        elif key == "dropTcp":
            suggest = "drop_tcp"
        elif key == "dropUdp":
            suggest = "drop_udp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2ProtocolBlockConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2ProtocolBlockConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2ProtocolBlockConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drop_icmp: int,
                 drop_other: int,
                 drop_tcp: int,
                 drop_udp: int):
        """
        :param int drop_icmp: ICMP block, value [0 (block off), 1 (block on)].
        :param int drop_other: Other block, value [0 (block off), 1 (block on)].
        :param int drop_tcp: TCP block, value [0 (block off), 1 (block on)].
        :param int drop_udp: UDP block, value [0 (block off), 1 (block on)].
        """
        pulumi.set(__self__, "drop_icmp", drop_icmp)
        pulumi.set(__self__, "drop_other", drop_other)
        pulumi.set(__self__, "drop_tcp", drop_tcp)
        pulumi.set(__self__, "drop_udp", drop_udp)

    @property
    @pulumi.getter(name="dropIcmp")
    def drop_icmp(self) -> int:
        """
        ICMP block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_icmp")

    @property
    @pulumi.getter(name="dropOther")
    def drop_other(self) -> int:
        """
        Other block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_other")

    @property
    @pulumi.getter(name="dropTcp")
    def drop_tcp(self) -> int:
        """
        TCP block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_tcp")

    @property
    @pulumi.getter(name="dropUdp")
    def drop_udp(self) -> int:
        """
        UDP block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_udp")


@pulumi.output_type
class DdosPolicyV2WaterPrintConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openStatus":
            suggest = "open_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2WaterPrintConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2WaterPrintConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2WaterPrintConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 listeners: Sequence['outputs.DdosPolicyV2WaterPrintConfigListener'],
                 offset: int,
                 open_status: int,
                 verify: str):
        """
        :param Sequence['DdosPolicyV2WaterPrintConfigListenerArgs'] listeners: List of forwarding listeners to which the watermark belongs.
        :param int offset: Watermark offset, value range: [0-100].
        :param int open_status: Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
        :param str verify: Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
        """
        pulumi.set(__self__, "listeners", listeners)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "open_status", open_status)
        pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def listeners(self) -> Sequence['outputs.DdosPolicyV2WaterPrintConfigListener']:
        """
        List of forwarding listeners to which the watermark belongs.
        """
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        Watermark offset, value range: [0-100].
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter(name="openStatus")
    def open_status(self) -> int:
        """
        Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
        """
        return pulumi.get(self, "open_status")

    @property
    @pulumi.getter
    def verify(self) -> str:
        """
        Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DdosPolicyV2WaterPrintConfigListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardProtocol":
            suggest = "forward_protocol"
        elif key == "frontendPort":
            suggest = "frontend_port"
        elif key == "frontendPortEnd":
            suggest = "frontend_port_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyV2WaterPrintConfigListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyV2WaterPrintConfigListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyV2WaterPrintConfigListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward_protocol: str,
                 frontend_port: int,
                 frontend_port_end: int):
        """
        :param str forward_protocol: Forwarding protocol, value [TCP, UDP].
        :param int frontend_port: Lower limit of forwarding listening port. Values: [1-65535].
        :param int frontend_port_end: Upper limit of forwarding listening port. Values: [1-65535].
        """
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "frontend_port", frontend_port)
        pulumi.set(__self__, "frontend_port_end", frontend_port_end)

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> str:
        """
        Forwarding protocol, value [TCP, UDP].
        """
        return pulumi.get(self, "forward_protocol")

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> int:
        """
        Lower limit of forwarding listening port. Values: [1-65535].
        """
        return pulumi.get(self, "frontend_port")

    @property
    @pulumi.getter(name="frontendPortEnd")
    def frontend_port_end(self) -> int:
        """
        Upper limit of forwarding listening port. Values: [1-65535].
        """
        return pulumi.get(self, "frontend_port_end")


@pulumi.output_type
class DdosPolicyWatermarkFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRemove":
            suggest = "auto_remove"
        elif key == "openSwitch":
            suggest = "open_switch"
        elif key == "tcpPortLists":
            suggest = "tcp_port_lists"
        elif key == "udpPortLists":
            suggest = "udp_port_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyWatermarkFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyWatermarkFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyWatermarkFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_remove: Optional[bool] = None,
                 offset: Optional[int] = None,
                 open_switch: Optional[bool] = None,
                 tcp_port_lists: Optional[Sequence[str]] = None,
                 udp_port_lists: Optional[Sequence[str]] = None):
        """
        :param bool auto_remove: Indicate whether to auto-remove the watermark or not.
        :param int offset: The offset of watermark. Valid value ranges: (0~1500).
        :param bool open_switch: Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        :param Sequence[str] tcp_port_lists: Port range of TCP, the format is like `2000-3000`.
        :param Sequence[str] udp_port_lists: Port range of TCP, the format is like `2000-3000`.
        """
        if auto_remove is not None:
            pulumi.set(__self__, "auto_remove", auto_remove)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if open_switch is not None:
            pulumi.set(__self__, "open_switch", open_switch)
        if tcp_port_lists is not None:
            pulumi.set(__self__, "tcp_port_lists", tcp_port_lists)
        if udp_port_lists is not None:
            pulumi.set(__self__, "udp_port_lists", udp_port_lists)

    @property
    @pulumi.getter(name="autoRemove")
    def auto_remove(self) -> Optional[bool]:
        """
        Indicate whether to auto-remove the watermark or not.
        """
        return pulumi.get(self, "auto_remove")

    @property
    @pulumi.getter
    def offset(self) -> Optional[int]:
        """
        The offset of watermark. Valid value ranges: (0~1500).
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter(name="openSwitch")
    def open_switch(self) -> Optional[bool]:
        """
        Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        """
        return pulumi.get(self, "open_switch")

    @property
    @pulumi.getter(name="tcpPortLists")
    def tcp_port_lists(self) -> Optional[Sequence[str]]:
        """
        Port range of TCP, the format is like `2000-3000`.
        """
        return pulumi.get(self, "tcp_port_lists")

    @property
    @pulumi.getter(name="udpPortLists")
    def udp_port_lists(self) -> Optional[Sequence[str]]:
        """
        Port range of TCP, the format is like `2000-3000`.
        """
        return pulumi.get(self, "udp_port_lists")


@pulumi.output_type
class DdosPolicyWatermarkKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "openSwitch":
            suggest = "open_switch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosPolicyWatermarkKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosPolicyWatermarkKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosPolicyWatermarkKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[str] = None,
                 create_time: Optional[str] = None,
                 id: Optional[str] = None,
                 open_switch: Optional[bool] = None):
        """
        :param str content: Content of the watermark.
        :param str create_time: Create time of the DDoS policy.
        :param str id: Id of the watermark.
        :param bool open_switch: Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if open_switch is not None:
            pulumi.set(__self__, "open_switch", open_switch)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Content of the watermark.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        """
        Create time of the DDoS policy.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the watermark.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="openSwitch")
    def open_switch(self) -> Optional[bool]:
        """
        Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        """
        return pulumi.get(self, "open_switch")


@pulumi.output_type
class L4RuleSourceList(dict):
    def __init__(__self__, *,
                 source: str,
                 weight: int):
        """
        :param str source: Source IP or domain, valid format of ip is like `1.1.1.1` and valid format of host source is like `abc.com`.
        :param int weight: Weight of the source, the valid value ranges from 0 to 100.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source IP or domain, valid format of ip is like `1.1.1.1` and valid format of host source is like `abc.com`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the source, the valid value ranges from 0 to 100.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class L4RuleV2Rules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepEnable":
            suggest = "keep_enable"
        elif key == "lbType":
            suggest = "lb_type"
        elif key == "removeSwitch":
            suggest = "remove_switch"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "sourceLists":
            suggest = "source_lists"
        elif key == "sourcePort":
            suggest = "source_port"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "virtualPort":
            suggest = "virtual_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L4RuleV2Rules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L4RuleV2Rules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L4RuleV2Rules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_enable: bool,
                 keeptime: int,
                 lb_type: int,
                 protocol: str,
                 region: int,
                 remove_switch: bool,
                 rule_name: str,
                 source_lists: Sequence['outputs.L4RuleV2RulesSourceList'],
                 source_port: int,
                 source_type: int,
                 virtual_port: int):
        """
        :param bool keep_enable: session hold switch.
        :param int keeptime: The keeptime of the layer 4 rule.
        :param int lb_type: LB type of the rule, `1` for weight cycling and `2` for IP hash.
        :param str protocol: Protocol of the rule.
        :param int region: Corresponding regional information.
        :param bool remove_switch: Remove the watermark state.
        :param str rule_name: Name of the rule.
        :param Sequence['L4RuleV2RulesSourceListArgs'] source_lists: Source list of the rule.
        :param int source_port: The source port of the layer 4 rule.
        :param int source_type: Source type, `1` for source of host, `2` for source of IP.
        :param int virtual_port: The virtual port of the layer 4 rule.
        """
        pulumi.set(__self__, "keep_enable", keep_enable)
        pulumi.set(__self__, "keeptime", keeptime)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "remove_switch", remove_switch)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_port", source_port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "virtual_port", virtual_port)

    @property
    @pulumi.getter(name="keepEnable")
    def keep_enable(self) -> bool:
        """
        session hold switch.
        """
        return pulumi.get(self, "keep_enable")

    @property
    @pulumi.getter
    def keeptime(self) -> int:
        """
        The keeptime of the layer 4 rule.
        """
        return pulumi.get(self, "keeptime")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        LB type of the rule, `1` for weight cycling and `2` for IP hash.
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def region(self) -> int:
        """
        Corresponding regional information.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="removeSwitch")
    def remove_switch(self) -> bool:
        """
        Remove the watermark state.
        """
        return pulumi.get(self, "remove_switch")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        Name of the rule.
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> Sequence['outputs.L4RuleV2RulesSourceList']:
        """
        Source list of the rule.
        """
        return pulumi.get(self, "source_lists")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> int:
        """
        The source port of the layer 4 rule.
        """
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> int:
        """
        Source type, `1` for source of host, `2` for source of IP.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> int:
        """
        The virtual port of the layer 4 rule.
        """
        return pulumi.get(self, "virtual_port")


@pulumi.output_type
class L4RuleV2RulesSourceList(dict):
    def __init__(__self__, *,
                 source: str,
                 weight: int):
        """
        :param str source: Source IP or domain.
        :param int weight: Weight of the source.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source IP or domain.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the source.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class L7RuleV2Rule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepEnable":
            suggest = "keep_enable"
        elif key == "lbType":
            suggest = "lb_type"
        elif key == "sourceLists":
            suggest = "source_lists"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "ccEnable":
            suggest = "cc_enable"
        elif key == "certType":
            suggest = "cert_type"
        elif key == "httpsToHttpEnable":
            suggest = "https_to_http_enable"
        elif key == "sslId":
            suggest = "ssl_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L7RuleV2Rule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L7RuleV2Rule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L7RuleV2Rule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 keep_enable: int,
                 keeptime: int,
                 lb_type: int,
                 protocol: str,
                 source_lists: Sequence['outputs.L7RuleV2RuleSourceList'],
                 source_type: int,
                 cc_enable: Optional[int] = None,
                 cert_type: Optional[int] = None,
                 https_to_http_enable: Optional[int] = None,
                 ssl_id: Optional[str] = None):
        """
        :param str domain: Domain of the rule.
        :param int keep_enable: session hold switch.
        :param int keeptime: The keeptime of the layer 4 rule.
        :param int lb_type: LB type of the rule, `1` for weight cycling and `2` for IP hash.
        :param str protocol: Protocol of the rule.
        :param int source_type: Source type, `1` for source of host, `2` for source of IP.
        :param int cc_enable: HTTPS protocol CC protection status, value [0 (off), 1 (on)], defaule is 0.
        :param int cert_type: The source of the certificate must be filled in when the forwarding protocol is https, the value [2 (Tencent Cloud Hosting Certificate)], and 0 when the forwarding protocol is http.
        :param int https_to_http_enable: Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], do not fill in the default is off, defaule is 0.
        :param str ssl_id: When the certificate source is a Tencent Cloud managed certificate, this field must be filled in with the managed certificate ID.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "keep_enable", keep_enable)
        pulumi.set(__self__, "keeptime", keeptime)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_type", source_type)
        if cc_enable is not None:
            pulumi.set(__self__, "cc_enable", cc_enable)
        if cert_type is not None:
            pulumi.set(__self__, "cert_type", cert_type)
        if https_to_http_enable is not None:
            pulumi.set(__self__, "https_to_http_enable", https_to_http_enable)
        if ssl_id is not None:
            pulumi.set(__self__, "ssl_id", ssl_id)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain of the rule.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="keepEnable")
    def keep_enable(self) -> int:
        """
        session hold switch.
        """
        return pulumi.get(self, "keep_enable")

    @property
    @pulumi.getter
    def keeptime(self) -> int:
        """
        The keeptime of the layer 4 rule.
        """
        return pulumi.get(self, "keeptime")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        LB type of the rule, `1` for weight cycling and `2` for IP hash.
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> Sequence['outputs.L7RuleV2RuleSourceList']:
        return pulumi.get(self, "source_lists")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> int:
        """
        Source type, `1` for source of host, `2` for source of IP.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="ccEnable")
    def cc_enable(self) -> Optional[int]:
        """
        HTTPS protocol CC protection status, value [0 (off), 1 (on)], defaule is 0.
        """
        return pulumi.get(self, "cc_enable")

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> Optional[int]:
        """
        The source of the certificate must be filled in when the forwarding protocol is https, the value [2 (Tencent Cloud Hosting Certificate)], and 0 when the forwarding protocol is http.
        """
        return pulumi.get(self, "cert_type")

    @property
    @pulumi.getter(name="httpsToHttpEnable")
    def https_to_http_enable(self) -> Optional[int]:
        """
        Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], do not fill in the default is off, defaule is 0.
        """
        return pulumi.get(self, "https_to_http_enable")

    @property
    @pulumi.getter(name="sslId")
    def ssl_id(self) -> Optional[str]:
        """
        When the certificate source is a Tencent Cloud managed certificate, this field must be filled in with the managed certificate ID.
        """
        return pulumi.get(self, "ssl_id")


@pulumi.output_type
class L7RuleV2RuleSourceList(dict):
    def __init__(__self__, *,
                 source: str,
                 weight: int):
        """
        :param str source: Source IP or domain.
        :param int weight: Weight of the source.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source IP or domain.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the source.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetCcHttpPoliciesListResult(dict):
    def __init__(__self__, *,
                 action: str,
                 create_time: str,
                 frequency: int,
                 ip_lists: Sequence[str],
                 name: str,
                 policy_id: str,
                 resource_id: str,
                 resource_type: str,
                 rule_lists: Sequence['outputs.GetCcHttpPoliciesListRuleListResult'],
                 smode: str,
                 switch: bool):
        """
        :param str action: Action mode.
        :param str create_time: Create time of the CC self-define http policy.
        :param int frequency: Max frequency per minute.
        :param Sequence[str] ip_lists: IP of the CC self-define http policy.
        :param str name: Name of the CC http policy to be queried.
        :param str policy_id: Id of the CC http policy to be queried.
        :param str resource_id: ID of the resource that the CC http policy works for.
        :param str resource_type: Type of the resource that the CC http policy works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
        :param Sequence['GetCcHttpPoliciesListRuleListArgs'] rule_lists: Rule list of the CC self-define http policy.
        :param str smode: Match mode.
        :param bool switch: Indicate the CC self-define http policy takes effect or not.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "ip_lists", ip_lists)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "rule_lists", rule_lists)
        pulumi.set(__self__, "smode", smode)
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action mode.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time of the CC self-define http policy.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def frequency(self) -> int:
        """
        Max frequency per minute.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Sequence[str]:
        """
        IP of the CC self-define http policy.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the CC http policy to be queried.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        Id of the CC http policy to be queried.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        ID of the resource that the CC http policy works for.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of the resource that the CC http policy works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="ruleLists")
    def rule_lists(self) -> Sequence['outputs.GetCcHttpPoliciesListRuleListResult']:
        """
        Rule list of the CC self-define http policy.
        """
        return pulumi.get(self, "rule_lists")

    @property
    @pulumi.getter
    def smode(self) -> str:
        """
        Match mode.
        """
        return pulumi.get(self, "smode")

    @property
    @pulumi.getter
    def switch(self) -> bool:
        """
        Indicate the CC self-define http policy takes effect or not.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class GetCcHttpPoliciesListRuleListResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 skey: str,
                 value: str):
        """
        :param str operator: Operator of the rule.
        :param str skey: Key of the rule.
        :param str value: Rule value.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "skey", skey)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the rule.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def skey(self) -> str:
        """
        Key of the rule.
        """
        return pulumi.get(self, "skey")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Rule value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCcHttpsPoliciesListResult(dict):
    def __init__(__self__, *,
                 action: str,
                 create_time: str,
                 domain: str,
                 ip_lists: Sequence[str],
                 name: str,
                 policy_id: str,
                 resource_id: str,
                 resource_type: str,
                 rule_id: str,
                 rule_lists: Sequence['outputs.GetCcHttpsPoliciesListRuleListResult'],
                 switch: bool):
        """
        :param str action: Action mode.
        :param str create_time: Create time of the CC self-define https policy.
        :param str domain: Domain that the CC self-define https policy works for.
        :param Sequence[str] ip_lists: Ip of the CC self-define https policy.
        :param str name: Name of the CC https policy to be queried.
        :param str policy_id: Id of the CC https policy to be queried.
        :param str resource_id: Id of the resource that the CC https policy works for.
        :param str resource_type: Type of the resource that the CC https policy works for, valid value is `bgpip`.
        :param str rule_id: Rule id of the domain that the CC self-define https policy works for.
        :param Sequence['GetCcHttpsPoliciesListRuleListArgs'] rule_lists: Rule list of the CC self-define https policy.
        :param bool switch: Indicate the CC self-define https policy takes effect or not.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "ip_lists", ip_lists)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "rule_lists", rule_lists)
        pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action mode.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time of the CC self-define https policy.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain that the CC self-define https policy works for.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="ipLists")
    def ip_lists(self) -> Sequence[str]:
        """
        Ip of the CC self-define https policy.
        """
        return pulumi.get(self, "ip_lists")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the CC https policy to be queried.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        Id of the CC https policy to be queried.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        Id of the resource that the CC https policy works for.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of the resource that the CC https policy works for, valid value is `bgpip`.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Rule id of the domain that the CC self-define https policy works for.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="ruleLists")
    def rule_lists(self) -> Sequence['outputs.GetCcHttpsPoliciesListRuleListResult']:
        """
        Rule list of the CC self-define https policy.
        """
        return pulumi.get(self, "rule_lists")

    @property
    @pulumi.getter
    def switch(self) -> bool:
        """
        Indicate the CC self-define https policy takes effect or not.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class GetCcHttpsPoliciesListRuleListResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 skey: str,
                 value: str):
        """
        :param str operator: Operator of the rule.
        :param str skey: Key of the rule.
        :param str value: Rule value.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "skey", skey)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the rule.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def skey(self) -> str:
        """
        Key of the rule.
        """
        return pulumi.get(self, "skey")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Rule value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDdosPoliciesListResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 drop_options: Sequence['outputs.GetDdosPoliciesListDropOptionResult'],
                 name: str,
                 packet_filters: Sequence['outputs.GetDdosPoliciesListPacketFilterResult'],
                 policy_id: str,
                 port_filters: Sequence['outputs.GetDdosPoliciesListPortFilterResult'],
                 scene_id: str,
                 watermark_filters: Sequence['outputs.GetDdosPoliciesListWatermarkFilterResult'],
                 watermark_keys: Sequence['outputs.GetDdosPoliciesListWatermarkKeyResult'],
                 black_ips: Optional[Sequence[str]] = None,
                 white_ips: Optional[Sequence[str]] = None):
        """
        :param str create_time: Create time of the DDoS policy.
        :param Sequence['GetDdosPoliciesListDropOptionArgs'] drop_options: Option list of abnormal check of the DDoS policy.
        :param str name: Name of the DDoS policy.
        :param Sequence['GetDdosPoliciesListPacketFilterArgs'] packet_filters: Message filter options list.
        :param str policy_id: ID of the DDoS policy to be query.
        :param Sequence['GetDdosPoliciesListPortFilterArgs'] port_filters: Port limits of abnormal check of the DDoS policy.
        :param str scene_id: Id of policy case that the DDoS policy works for.
        :param Sequence['GetDdosPoliciesListWatermarkFilterArgs'] watermark_filters: Watermark policy options, and only support one watermark policy at most.
        :param Sequence['GetDdosPoliciesListWatermarkKeyArgs'] watermark_keys: Watermark content.
        :param Sequence[str] black_ips: Black ip list.
        :param Sequence[str] white_ips: White ip list.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "drop_options", drop_options)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "packet_filters", packet_filters)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "port_filters", port_filters)
        pulumi.set(__self__, "scene_id", scene_id)
        pulumi.set(__self__, "watermark_filters", watermark_filters)
        pulumi.set(__self__, "watermark_keys", watermark_keys)
        if black_ips is not None:
            pulumi.set(__self__, "black_ips", black_ips)
        if white_ips is not None:
            pulumi.set(__self__, "white_ips", white_ips)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time of the DDoS policy.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dropOptions")
    def drop_options(self) -> Sequence['outputs.GetDdosPoliciesListDropOptionResult']:
        """
        Option list of abnormal check of the DDoS policy.
        """
        return pulumi.get(self, "drop_options")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the DDoS policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packetFilters")
    def packet_filters(self) -> Sequence['outputs.GetDdosPoliciesListPacketFilterResult']:
        """
        Message filter options list.
        """
        return pulumi.get(self, "packet_filters")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        ID of the DDoS policy to be query.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="portFilters")
    def port_filters(self) -> Sequence['outputs.GetDdosPoliciesListPortFilterResult']:
        """
        Port limits of abnormal check of the DDoS policy.
        """
        return pulumi.get(self, "port_filters")

    @property
    @pulumi.getter(name="sceneId")
    def scene_id(self) -> str:
        """
        Id of policy case that the DDoS policy works for.
        """
        return pulumi.get(self, "scene_id")

    @property
    @pulumi.getter(name="watermarkFilters")
    def watermark_filters(self) -> Sequence['outputs.GetDdosPoliciesListWatermarkFilterResult']:
        """
        Watermark policy options, and only support one watermark policy at most.
        """
        return pulumi.get(self, "watermark_filters")

    @property
    @pulumi.getter(name="watermarkKeys")
    def watermark_keys(self) -> Sequence['outputs.GetDdosPoliciesListWatermarkKeyResult']:
        """
        Watermark content.
        """
        return pulumi.get(self, "watermark_keys")

    @property
    @pulumi.getter(name="blackIps")
    def black_ips(self) -> Optional[Sequence[str]]:
        """
        Black ip list.
        """
        return pulumi.get(self, "black_ips")

    @property
    @pulumi.getter(name="whiteIps")
    def white_ips(self) -> Optional[Sequence[str]]:
        """
        White ip list.
        """
        return pulumi.get(self, "white_ips")


@pulumi.output_type
class GetDdosPoliciesListDropOptionResult(dict):
    def __init__(__self__, *,
                 bad_conn_threshold: int,
                 check_sync_conn: bool,
                 conn_timeout: int,
                 d_conn_limit: int,
                 d_new_limit: int,
                 drop_abroad: bool,
                 drop_icmp: bool,
                 drop_other: bool,
                 drop_tcp: bool,
                 drop_udp: bool,
                 icmp_mbps_limit: int,
                 null_conn_enable: bool,
                 other_mbps_limit: int,
                 s_conn_limit: int,
                 s_new_limit: int,
                 syn_limit: int,
                 syn_rate: int,
                 tcp_mbps_limit: int,
                 udp_mbps_limit: int):
        """
        :param int bad_conn_threshold: The number of new connections based on destination IP that trigger suppression of connections.
        :param bool check_sync_conn: Indicate whether to check null connection or not.
        :param int conn_timeout: Connection timeout of abnormal connection check.
        :param int d_conn_limit: The limit of concurrent connections based on destination IP.
        :param int d_new_limit: The limit of new connections based on destination IP.
        :param bool drop_abroad: Indicate whether to drop abroad traffic or not.
        :param bool drop_icmp: Indicate whether to drop ICMP protocol or not.
        :param bool drop_other: Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
        :param bool drop_tcp: Indicate whether to drop TCP protocol or not.
        :param bool drop_udp: Indicate to drop UDP protocol or not.
        :param int icmp_mbps_limit: The limit of ICMP traffic rate.
        :param bool null_conn_enable: Indicate to enable null connection or not.
        :param int other_mbps_limit: The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate.
        :param int s_conn_limit: The limit of concurrent connections based on source IP.
        :param int s_new_limit: The limit of new connections based on source IP.
        :param int syn_limit: The limit of syn of abnormal connection check.
        :param int syn_rate: The percentage of syn in ack of abnormal connection check.
        :param int tcp_mbps_limit: The limit of TCP traffic.
        :param int udp_mbps_limit: The limit of UDP traffic rate.
        """
        pulumi.set(__self__, "bad_conn_threshold", bad_conn_threshold)
        pulumi.set(__self__, "check_sync_conn", check_sync_conn)
        pulumi.set(__self__, "conn_timeout", conn_timeout)
        pulumi.set(__self__, "d_conn_limit", d_conn_limit)
        pulumi.set(__self__, "d_new_limit", d_new_limit)
        pulumi.set(__self__, "drop_abroad", drop_abroad)
        pulumi.set(__self__, "drop_icmp", drop_icmp)
        pulumi.set(__self__, "drop_other", drop_other)
        pulumi.set(__self__, "drop_tcp", drop_tcp)
        pulumi.set(__self__, "drop_udp", drop_udp)
        pulumi.set(__self__, "icmp_mbps_limit", icmp_mbps_limit)
        pulumi.set(__self__, "null_conn_enable", null_conn_enable)
        pulumi.set(__self__, "other_mbps_limit", other_mbps_limit)
        pulumi.set(__self__, "s_conn_limit", s_conn_limit)
        pulumi.set(__self__, "s_new_limit", s_new_limit)
        pulumi.set(__self__, "syn_limit", syn_limit)
        pulumi.set(__self__, "syn_rate", syn_rate)
        pulumi.set(__self__, "tcp_mbps_limit", tcp_mbps_limit)
        pulumi.set(__self__, "udp_mbps_limit", udp_mbps_limit)

    @property
    @pulumi.getter(name="badConnThreshold")
    def bad_conn_threshold(self) -> int:
        """
        The number of new connections based on destination IP that trigger suppression of connections.
        """
        return pulumi.get(self, "bad_conn_threshold")

    @property
    @pulumi.getter(name="checkSyncConn")
    def check_sync_conn(self) -> bool:
        """
        Indicate whether to check null connection or not.
        """
        return pulumi.get(self, "check_sync_conn")

    @property
    @pulumi.getter(name="connTimeout")
    def conn_timeout(self) -> int:
        """
        Connection timeout of abnormal connection check.
        """
        return pulumi.get(self, "conn_timeout")

    @property
    @pulumi.getter(name="dConnLimit")
    def d_conn_limit(self) -> int:
        """
        The limit of concurrent connections based on destination IP.
        """
        return pulumi.get(self, "d_conn_limit")

    @property
    @pulumi.getter(name="dNewLimit")
    def d_new_limit(self) -> int:
        """
        The limit of new connections based on destination IP.
        """
        return pulumi.get(self, "d_new_limit")

    @property
    @pulumi.getter(name="dropAbroad")
    def drop_abroad(self) -> bool:
        """
        Indicate whether to drop abroad traffic or not.
        """
        return pulumi.get(self, "drop_abroad")

    @property
    @pulumi.getter(name="dropIcmp")
    def drop_icmp(self) -> bool:
        """
        Indicate whether to drop ICMP protocol or not.
        """
        return pulumi.get(self, "drop_icmp")

    @property
    @pulumi.getter(name="dropOther")
    def drop_other(self) -> bool:
        """
        Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
        """
        return pulumi.get(self, "drop_other")

    @property
    @pulumi.getter(name="dropTcp")
    def drop_tcp(self) -> bool:
        """
        Indicate whether to drop TCP protocol or not.
        """
        return pulumi.get(self, "drop_tcp")

    @property
    @pulumi.getter(name="dropUdp")
    def drop_udp(self) -> bool:
        """
        Indicate to drop UDP protocol or not.
        """
        return pulumi.get(self, "drop_udp")

    @property
    @pulumi.getter(name="icmpMbpsLimit")
    def icmp_mbps_limit(self) -> int:
        """
        The limit of ICMP traffic rate.
        """
        return pulumi.get(self, "icmp_mbps_limit")

    @property
    @pulumi.getter(name="nullConnEnable")
    def null_conn_enable(self) -> bool:
        """
        Indicate to enable null connection or not.
        """
        return pulumi.get(self, "null_conn_enable")

    @property
    @pulumi.getter(name="otherMbpsLimit")
    def other_mbps_limit(self) -> int:
        """
        The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate.
        """
        return pulumi.get(self, "other_mbps_limit")

    @property
    @pulumi.getter(name="sConnLimit")
    def s_conn_limit(self) -> int:
        """
        The limit of concurrent connections based on source IP.
        """
        return pulumi.get(self, "s_conn_limit")

    @property
    @pulumi.getter(name="sNewLimit")
    def s_new_limit(self) -> int:
        """
        The limit of new connections based on source IP.
        """
        return pulumi.get(self, "s_new_limit")

    @property
    @pulumi.getter(name="synLimit")
    def syn_limit(self) -> int:
        """
        The limit of syn of abnormal connection check.
        """
        return pulumi.get(self, "syn_limit")

    @property
    @pulumi.getter(name="synRate")
    def syn_rate(self) -> int:
        """
        The percentage of syn in ack of abnormal connection check.
        """
        return pulumi.get(self, "syn_rate")

    @property
    @pulumi.getter(name="tcpMbpsLimit")
    def tcp_mbps_limit(self) -> int:
        """
        The limit of TCP traffic.
        """
        return pulumi.get(self, "tcp_mbps_limit")

    @property
    @pulumi.getter(name="udpMbpsLimit")
    def udp_mbps_limit(self) -> int:
        """
        The limit of UDP traffic rate.
        """
        return pulumi.get(self, "udp_mbps_limit")


@pulumi.output_type
class GetDdosPoliciesListPacketFilterResult(dict):
    def __init__(__self__, *,
                 action: str,
                 d_end_port: int,
                 d_start_port: int,
                 depth: int,
                 is_include: bool,
                 match_begin: str,
                 match_str: str,
                 match_type: str,
                 offset: int,
                 pkt_length_max: int,
                 pkt_length_min: int,
                 protocol: str,
                 s_end_port: int,
                 s_start_port: int):
        """
        :param str action: Action of port to take.
        :param int d_end_port: End port of the destination.
        :param int d_start_port: Start port of the destination.
        :param int depth: The depth of match.
        :param bool is_include: Indicate whether to include the key word/regular expression or not.
        :param str match_begin: Indicate whether to check load or not.
        :param str match_str: The key word or regular expression.
        :param str match_type: Match type.
        :param int offset: The offset of watermark.
        :param int pkt_length_max: The max length of the packet.
        :param int pkt_length_min: The minimum length of the packet.
        :param str protocol: Protocol.
        :param int s_end_port: End port of the source.
        :param int s_start_port: Start port of the source.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "d_end_port", d_end_port)
        pulumi.set(__self__, "d_start_port", d_start_port)
        pulumi.set(__self__, "depth", depth)
        pulumi.set(__self__, "is_include", is_include)
        pulumi.set(__self__, "match_begin", match_begin)
        pulumi.set(__self__, "match_str", match_str)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "pkt_length_max", pkt_length_max)
        pulumi.set(__self__, "pkt_length_min", pkt_length_min)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "s_end_port", s_end_port)
        pulumi.set(__self__, "s_start_port", s_start_port)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action of port to take.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="dEndPort")
    def d_end_port(self) -> int:
        """
        End port of the destination.
        """
        return pulumi.get(self, "d_end_port")

    @property
    @pulumi.getter(name="dStartPort")
    def d_start_port(self) -> int:
        """
        Start port of the destination.
        """
        return pulumi.get(self, "d_start_port")

    @property
    @pulumi.getter
    def depth(self) -> int:
        """
        The depth of match.
        """
        return pulumi.get(self, "depth")

    @property
    @pulumi.getter(name="isInclude")
    def is_include(self) -> bool:
        """
        Indicate whether to include the key word/regular expression or not.
        """
        return pulumi.get(self, "is_include")

    @property
    @pulumi.getter(name="matchBegin")
    def match_begin(self) -> str:
        """
        Indicate whether to check load or not.
        """
        return pulumi.get(self, "match_begin")

    @property
    @pulumi.getter(name="matchStr")
    def match_str(self) -> str:
        """
        The key word or regular expression.
        """
        return pulumi.get(self, "match_str")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        """
        Match type.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        The offset of watermark.
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter(name="pktLengthMax")
    def pkt_length_max(self) -> int:
        """
        The max length of the packet.
        """
        return pulumi.get(self, "pkt_length_max")

    @property
    @pulumi.getter(name="pktLengthMin")
    def pkt_length_min(self) -> int:
        """
        The minimum length of the packet.
        """
        return pulumi.get(self, "pkt_length_min")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sEndPort")
    def s_end_port(self) -> int:
        """
        End port of the source.
        """
        return pulumi.get(self, "s_end_port")

    @property
    @pulumi.getter(name="sStartPort")
    def s_start_port(self) -> int:
        """
        Start port of the source.
        """
        return pulumi.get(self, "s_start_port")


@pulumi.output_type
class GetDdosPoliciesListPortFilterResult(dict):
    def __init__(__self__, *,
                 action: str,
                 end_port: int,
                 kind: int,
                 protocol: str,
                 start_port: int):
        """
        :param str action: Action of port to take.
        :param int end_port: End port.
        :param int kind: The type of forbidden port, and valid values are 0, 1, 2. 0 for destination port, 1 for source port and 2 for both destination and source posts.
        :param str protocol: Protocol.
        :param int start_port: Start port.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action of port to take.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> int:
        """
        End port.
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def kind(self) -> int:
        """
        The type of forbidden port, and valid values are 0, 1, 2. 0 for destination port, 1 for source port and 2 for both destination and source posts.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Start port.
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class GetDdosPoliciesListWatermarkFilterResult(dict):
    def __init__(__self__, *,
                 auto_remove: bool,
                 offset: int,
                 open_switch: bool,
                 tcp_port_lists: Sequence[str],
                 udp_port_lists: Sequence[str]):
        """
        :param bool auto_remove: Indicate whether to auto-remove the watermark or not.
        :param int offset: The offset of watermark.
        :param bool open_switch: Indicate whether to auto-remove the watermark or not.
        :param Sequence[str] tcp_port_lists: Port range of TCP.
        :param Sequence[str] udp_port_lists: Port range of TCP.
        """
        pulumi.set(__self__, "auto_remove", auto_remove)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "open_switch", open_switch)
        pulumi.set(__self__, "tcp_port_lists", tcp_port_lists)
        pulumi.set(__self__, "udp_port_lists", udp_port_lists)

    @property
    @pulumi.getter(name="autoRemove")
    def auto_remove(self) -> bool:
        """
        Indicate whether to auto-remove the watermark or not.
        """
        return pulumi.get(self, "auto_remove")

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        The offset of watermark.
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter(name="openSwitch")
    def open_switch(self) -> bool:
        """
        Indicate whether to auto-remove the watermark or not.
        """
        return pulumi.get(self, "open_switch")

    @property
    @pulumi.getter(name="tcpPortLists")
    def tcp_port_lists(self) -> Sequence[str]:
        """
        Port range of TCP.
        """
        return pulumi.get(self, "tcp_port_lists")

    @property
    @pulumi.getter(name="udpPortLists")
    def udp_port_lists(self) -> Sequence[str]:
        """
        Port range of TCP.
        """
        return pulumi.get(self, "udp_port_lists")


@pulumi.output_type
class GetDdosPoliciesListWatermarkKeyResult(dict):
    def __init__(__self__, *,
                 content: str,
                 id: str,
                 open_switch: bool,
                 create_time: Optional[str] = None):
        """
        :param str content: Content of the watermark.
        :param str id: Id of the watermark.
        :param bool open_switch: Indicate whether to auto-remove the watermark or not.
        :param str create_time: Create time of the DDoS policy.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "open_switch", open_switch)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the watermark.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the watermark.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="openSwitch")
    def open_switch(self) -> bool:
        """
        Indicate whether to auto-remove the watermark or not.
        """
        return pulumi.get(self, "open_switch")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[str]:
        """
        Create time of the DDoS policy.
        """
        return pulumi.get(self, "create_time")


@pulumi.output_type
class GetDdosPolicyAttachmentsDayuDdosPolicyAttachmentListResult(dict):
    def __init__(__self__, *,
                 policy_id: str,
                 resource_id: str,
                 resource_type: str):
        """
        :param str policy_id: Id of the policy to be queried.
        :param str resource_id: ID of the attached resource to be queried.
        :param str resource_type: Type of the resource that the DDoS policy works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
        """
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        Id of the policy to be queried.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        ID of the attached resource to be queried.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of the resource that the DDoS policy works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetDdosPolicyCasesListResult(dict):
    def __init__(__self__, *,
                 app_protocols: Sequence[str],
                 app_type: str,
                 create_time: str,
                 has_abroad: str,
                 has_initiate_tcp: str,
                 has_initiate_udp: str,
                 has_vpn: str,
                 max_tcp_package_len: str,
                 max_udp_package_len: str,
                 min_tcp_package_len: str,
                 min_udp_package_len: str,
                 name: str,
                 peer_tcp_port: str,
                 peer_udp_port: str,
                 platform_types: Sequence[str],
                 resource_type: str,
                 scene_id: str,
                 tcp_end_port: str,
                 tcp_footprint: str,
                 tcp_start_port: str,
                 udp_end_port: str,
                 udp_footprint: str,
                 udp_start_port: str,
                 web_api_urls: Sequence[str]):
        """
        :param Sequence[str] app_protocols: App protocol set of the DDoS policy case.
        :param str app_type: App type of the DDoS policy case.
        :param str create_time: Create time of the DDoS policy case.
        :param str has_abroad: Indicate whether the service involves overseas or not.
        :param str has_initiate_tcp: Indicate whether the service actively initiates TCP requests or not.
        :param str has_initiate_udp: Indicate whether the actively initiate UDP requests or not.
        :param str has_vpn: Indicate whether the service involves VPN service or not.
        :param str max_tcp_package_len: The max length of TCP message package.
        :param str max_udp_package_len: The max length of UDP message package.
        :param str min_tcp_package_len: The minimum length of TCP message package.
        :param str min_udp_package_len: The minimum length of UDP message package.
        :param str name: Name of the DDoS policy case.
        :param str peer_tcp_port: The port that actively initiates TCP requests.
        :param str peer_udp_port: The port that actively initiates UDP requests.
        :param Sequence[str] platform_types: Platform set of the DDoS policy case.
        :param str resource_type: Type of the resource that the DDoS policy case works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
        :param str scene_id: ID of the DDoS policy case to be query.
        :param str tcp_end_port: End port of the TCP service.
        :param str tcp_footprint: The fixed signature of TCP protocol load.
        :param str tcp_start_port: Start port of the TCP service.
        :param str udp_end_port: End port of the UDP service.
        :param str udp_footprint: The fixed signature of TCP protocol load.
        :param str udp_start_port: Start port of the UDP service.
        :param Sequence[str] web_api_urls: Web API url set.
        """
        pulumi.set(__self__, "app_protocols", app_protocols)
        pulumi.set(__self__, "app_type", app_type)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "has_abroad", has_abroad)
        pulumi.set(__self__, "has_initiate_tcp", has_initiate_tcp)
        pulumi.set(__self__, "has_initiate_udp", has_initiate_udp)
        pulumi.set(__self__, "has_vpn", has_vpn)
        pulumi.set(__self__, "max_tcp_package_len", max_tcp_package_len)
        pulumi.set(__self__, "max_udp_package_len", max_udp_package_len)
        pulumi.set(__self__, "min_tcp_package_len", min_tcp_package_len)
        pulumi.set(__self__, "min_udp_package_len", min_udp_package_len)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "peer_tcp_port", peer_tcp_port)
        pulumi.set(__self__, "peer_udp_port", peer_udp_port)
        pulumi.set(__self__, "platform_types", platform_types)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "scene_id", scene_id)
        pulumi.set(__self__, "tcp_end_port", tcp_end_port)
        pulumi.set(__self__, "tcp_footprint", tcp_footprint)
        pulumi.set(__self__, "tcp_start_port", tcp_start_port)
        pulumi.set(__self__, "udp_end_port", udp_end_port)
        pulumi.set(__self__, "udp_footprint", udp_footprint)
        pulumi.set(__self__, "udp_start_port", udp_start_port)
        pulumi.set(__self__, "web_api_urls", web_api_urls)

    @property
    @pulumi.getter(name="appProtocols")
    def app_protocols(self) -> Sequence[str]:
        """
        App protocol set of the DDoS policy case.
        """
        return pulumi.get(self, "app_protocols")

    @property
    @pulumi.getter(name="appType")
    def app_type(self) -> str:
        """
        App type of the DDoS policy case.
        """
        return pulumi.get(self, "app_type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time of the DDoS policy case.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="hasAbroad")
    def has_abroad(self) -> str:
        """
        Indicate whether the service involves overseas or not.
        """
        return pulumi.get(self, "has_abroad")

    @property
    @pulumi.getter(name="hasInitiateTcp")
    def has_initiate_tcp(self) -> str:
        """
        Indicate whether the service actively initiates TCP requests or not.
        """
        return pulumi.get(self, "has_initiate_tcp")

    @property
    @pulumi.getter(name="hasInitiateUdp")
    def has_initiate_udp(self) -> str:
        """
        Indicate whether the actively initiate UDP requests or not.
        """
        return pulumi.get(self, "has_initiate_udp")

    @property
    @pulumi.getter(name="hasVpn")
    def has_vpn(self) -> str:
        """
        Indicate whether the service involves VPN service or not.
        """
        return pulumi.get(self, "has_vpn")

    @property
    @pulumi.getter(name="maxTcpPackageLen")
    def max_tcp_package_len(self) -> str:
        """
        The max length of TCP message package.
        """
        return pulumi.get(self, "max_tcp_package_len")

    @property
    @pulumi.getter(name="maxUdpPackageLen")
    def max_udp_package_len(self) -> str:
        """
        The max length of UDP message package.
        """
        return pulumi.get(self, "max_udp_package_len")

    @property
    @pulumi.getter(name="minTcpPackageLen")
    def min_tcp_package_len(self) -> str:
        """
        The minimum length of TCP message package.
        """
        return pulumi.get(self, "min_tcp_package_len")

    @property
    @pulumi.getter(name="minUdpPackageLen")
    def min_udp_package_len(self) -> str:
        """
        The minimum length of UDP message package.
        """
        return pulumi.get(self, "min_udp_package_len")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the DDoS policy case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="peerTcpPort")
    def peer_tcp_port(self) -> str:
        """
        The port that actively initiates TCP requests.
        """
        return pulumi.get(self, "peer_tcp_port")

    @property
    @pulumi.getter(name="peerUdpPort")
    def peer_udp_port(self) -> str:
        """
        The port that actively initiates UDP requests.
        """
        return pulumi.get(self, "peer_udp_port")

    @property
    @pulumi.getter(name="platformTypes")
    def platform_types(self) -> Sequence[str]:
        """
        Platform set of the DDoS policy case.
        """
        return pulumi.get(self, "platform_types")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of the resource that the DDoS policy case works for, valid values are `bgpip`, `bgp`, `bgp-multip` and `net`.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="sceneId")
    def scene_id(self) -> str:
        """
        ID of the DDoS policy case to be query.
        """
        return pulumi.get(self, "scene_id")

    @property
    @pulumi.getter(name="tcpEndPort")
    def tcp_end_port(self) -> str:
        """
        End port of the TCP service.
        """
        return pulumi.get(self, "tcp_end_port")

    @property
    @pulumi.getter(name="tcpFootprint")
    def tcp_footprint(self) -> str:
        """
        The fixed signature of TCP protocol load.
        """
        return pulumi.get(self, "tcp_footprint")

    @property
    @pulumi.getter(name="tcpStartPort")
    def tcp_start_port(self) -> str:
        """
        Start port of the TCP service.
        """
        return pulumi.get(self, "tcp_start_port")

    @property
    @pulumi.getter(name="udpEndPort")
    def udp_end_port(self) -> str:
        """
        End port of the UDP service.
        """
        return pulumi.get(self, "udp_end_port")

    @property
    @pulumi.getter(name="udpFootprint")
    def udp_footprint(self) -> str:
        """
        The fixed signature of TCP protocol load.
        """
        return pulumi.get(self, "udp_footprint")

    @property
    @pulumi.getter(name="udpStartPort")
    def udp_start_port(self) -> str:
        """
        Start port of the UDP service.
        """
        return pulumi.get(self, "udp_start_port")

    @property
    @pulumi.getter(name="webApiUrls")
    def web_api_urls(self) -> Sequence[str]:
        """
        Web API url set.
        """
        return pulumi.get(self, "web_api_urls")


@pulumi.output_type
class GetEipListResult(dict):
    def __init__(__self__, *,
                 created_time: str,
                 eip_address_status: str,
                 eip_bound_rsc_eni: str,
                 eip_bound_rsc_vip: str,
                 eip_lists: Sequence[str],
                 expired_time: str,
                 modify_time: str,
                 protection_status: str,
                 region: str,
                 eip_bound_rsc_ins: Optional[str] = None,
                 instance_id: Optional[str] = None):
        """
        :param str created_time: The created time of resource.
        :param str eip_address_status: Eip PUBLIC IP status.
        :param str eip_bound_rsc_eni: The ID of the bound ENI.
        :param str eip_bound_rsc_vip: Bind the resource intranet IP.
        :param str expired_time: The expired time of resource.
        :param str modify_time: The modify time of resource.
        :param str protection_status: The protection status of the asset instance.
        :param str region: The region where the asset instance is located.
        :param str eip_bound_rsc_ins: The ID of the resource instance for the binding.
        :param str instance_id: ID of the resource instance.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "eip_address_status", eip_address_status)
        pulumi.set(__self__, "eip_bound_rsc_eni", eip_bound_rsc_eni)
        pulumi.set(__self__, "eip_bound_rsc_vip", eip_bound_rsc_vip)
        pulumi.set(__self__, "eip_lists", eip_lists)
        pulumi.set(__self__, "expired_time", expired_time)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "protection_status", protection_status)
        pulumi.set(__self__, "region", region)
        if eip_bound_rsc_ins is not None:
            pulumi.set(__self__, "eip_bound_rsc_ins", eip_bound_rsc_ins)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The created time of resource.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="eipAddressStatus")
    def eip_address_status(self) -> str:
        """
        Eip PUBLIC IP status.
        """
        return pulumi.get(self, "eip_address_status")

    @property
    @pulumi.getter(name="eipBoundRscEni")
    def eip_bound_rsc_eni(self) -> str:
        """
        The ID of the bound ENI.
        """
        return pulumi.get(self, "eip_bound_rsc_eni")

    @property
    @pulumi.getter(name="eipBoundRscVip")
    def eip_bound_rsc_vip(self) -> str:
        """
        Bind the resource intranet IP.
        """
        return pulumi.get(self, "eip_bound_rsc_vip")

    @property
    @pulumi.getter(name="eipLists")
    def eip_lists(self) -> Sequence[str]:
        return pulumi.get(self, "eip_lists")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        """
        The expired time of resource.
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> str:
        """
        The modify time of resource.
        """
        return pulumi.get(self, "modify_time")

    @property
    @pulumi.getter(name="protectionStatus")
    def protection_status(self) -> str:
        """
        The protection status of the asset instance.
        """
        return pulumi.get(self, "protection_status")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region where the asset instance is located.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="eipBoundRscIns")
    def eip_bound_rsc_ins(self) -> Optional[str]:
        """
        The ID of the resource instance for the binding.
        """
        return pulumi.get(self, "eip_bound_rsc_ins")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        ID of the resource instance.
        """
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class GetL4RulesListResult(dict):
    def __init__(__self__, *,
                 d_port: int,
                 health_check_health_num: int,
                 health_check_interval: int,
                 health_check_switch: bool,
                 health_check_timeout: int,
                 health_check_unhealth_num: int,
                 lb_type: int,
                 name: str,
                 protocol: str,
                 rule_id: str,
                 s_port: int,
                 session_switch: bool,
                 session_time: int,
                 source_lists: Sequence['outputs.GetL4RulesListSourceListResult'],
                 source_type: int):
        """
        :param int d_port: The destination port of the layer 4 rule.
        :param int health_check_health_num: Health threshold of health check.
        :param int health_check_interval: Interval time of health check.
        :param bool health_check_switch: Indicates whether health check is enabled.
        :param int health_check_timeout: HTTP Status Code. `1` means the return value `1xx` is health. `2` means the return value `2xx` is health. `4` means the return value `3xx` is health. `8` means the return value `4xx` is health. `16` means the return value `5xx` is health. If you want multiple return codes to indicate health, need to add the corresponding values.
        :param int health_check_unhealth_num: Unhealthy threshold of health check.
        :param int lb_type: LB type of the rule, `1` for weight cycling and `2` for IP hash.
        :param str name: Name of the layer 4 rule to be queried.
        :param str protocol: Protocol of the rule.
        :param str rule_id: Id of the layer 4 rule to be queried.
        :param int s_port: The source port of the layer 4 rule.
        :param bool session_switch: Indicate that the session will keep or not.
        :param int session_time: Session keep time, only valid when `session_switch` is true, the available value ranges from 1 to 300 and unit is second.
        :param Sequence['GetL4RulesListSourceListArgs'] source_lists: Source list of the rule.
        :param int source_type: Source type, `1` for source of host, `2` for source of IP.
        """
        pulumi.set(__self__, "d_port", d_port)
        pulumi.set(__self__, "health_check_health_num", health_check_health_num)
        pulumi.set(__self__, "health_check_interval", health_check_interval)
        pulumi.set(__self__, "health_check_switch", health_check_switch)
        pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        pulumi.set(__self__, "health_check_unhealth_num", health_check_unhealth_num)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "s_port", s_port)
        pulumi.set(__self__, "session_switch", session_switch)
        pulumi.set(__self__, "session_time", session_time)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="dPort")
    def d_port(self) -> int:
        """
        The destination port of the layer 4 rule.
        """
        return pulumi.get(self, "d_port")

    @property
    @pulumi.getter(name="healthCheckHealthNum")
    def health_check_health_num(self) -> int:
        """
        Health threshold of health check.
        """
        return pulumi.get(self, "health_check_health_num")

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> int:
        """
        Interval time of health check.
        """
        return pulumi.get(self, "health_check_interval")

    @property
    @pulumi.getter(name="healthCheckSwitch")
    def health_check_switch(self) -> bool:
        """
        Indicates whether health check is enabled.
        """
        return pulumi.get(self, "health_check_switch")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> int:
        """
        HTTP Status Code. `1` means the return value `1xx` is health. `2` means the return value `2xx` is health. `4` means the return value `3xx` is health. `8` means the return value `4xx` is health. `16` means the return value `5xx` is health. If you want multiple return codes to indicate health, need to add the corresponding values.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter(name="healthCheckUnhealthNum")
    def health_check_unhealth_num(self) -> int:
        """
        Unhealthy threshold of health check.
        """
        return pulumi.get(self, "health_check_unhealth_num")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        LB type of the rule, `1` for weight cycling and `2` for IP hash.
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the layer 4 rule to be queried.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Id of the layer 4 rule to be queried.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="sPort")
    def s_port(self) -> int:
        """
        The source port of the layer 4 rule.
        """
        return pulumi.get(self, "s_port")

    @property
    @pulumi.getter(name="sessionSwitch")
    def session_switch(self) -> bool:
        """
        Indicate that the session will keep or not.
        """
        return pulumi.get(self, "session_switch")

    @property
    @pulumi.getter(name="sessionTime")
    def session_time(self) -> int:
        """
        Session keep time, only valid when `session_switch` is true, the available value ranges from 1 to 300 and unit is second.
        """
        return pulumi.get(self, "session_time")

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> Sequence['outputs.GetL4RulesListSourceListResult']:
        """
        Source list of the rule.
        """
        return pulumi.get(self, "source_lists")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> int:
        """
        Source type, `1` for source of host, `2` for source of IP.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class GetL4RulesListSourceListResult(dict):
    def __init__(__self__, *,
                 source: str,
                 weight: int):
        """
        :param str source: Source IP or domain.
        :param int weight: Weight of the source.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source IP or domain.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the source.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetL4RulesV2ListResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip: str,
                 keep_enable: bool,
                 keeptime: int,
                 lb_type: int,
                 modify_time: str,
                 protocol: str,
                 region: int,
                 remove_switch: bool,
                 rule_id: str,
                 rule_name: str,
                 source_lists: Sequence['outputs.GetL4RulesV2ListSourceListResult'],
                 source_port: int,
                 source_type: int,
                 virtual_port: int):
        """
        :param str id: Bind the resource ID information.
        :param str ip: Ip of the resource.
        :param bool keep_enable: session hold switch.
        :param int keeptime: The keeptime of the layer 4 rule.
        :param int lb_type: LB type of the rule, `1` for weight cycling and `2` for IP hash.
        :param str modify_time: Rule modification time.
        :param str protocol: Protocol of the rule.
        :param int region: Corresponding regional information.
        :param bool remove_switch: Remove the watermark state.
        :param str rule_id: ID of the 4 layer rule.
        :param str rule_name: Name of the rule.
        :param Sequence['GetL4RulesV2ListSourceListArgs'] source_lists: Source list of the rule.
        :param int source_port: The source port of the layer 4 rule.
        :param int source_type: Source type, `1` for source of host, `2` for source of IP.
        :param int virtual_port: Virtual port of resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "keep_enable", keep_enable)
        pulumi.set(__self__, "keeptime", keeptime)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "remove_switch", remove_switch)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_port", source_port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "virtual_port", virtual_port)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Bind the resource ID information.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        Ip of the resource.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="keepEnable")
    def keep_enable(self) -> bool:
        """
        session hold switch.
        """
        return pulumi.get(self, "keep_enable")

    @property
    @pulumi.getter
    def keeptime(self) -> int:
        """
        The keeptime of the layer 4 rule.
        """
        return pulumi.get(self, "keeptime")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        LB type of the rule, `1` for weight cycling and `2` for IP hash.
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> str:
        """
        Rule modification time.
        """
        return pulumi.get(self, "modify_time")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def region(self) -> int:
        """
        Corresponding regional information.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="removeSwitch")
    def remove_switch(self) -> bool:
        """
        Remove the watermark state.
        """
        return pulumi.get(self, "remove_switch")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        ID of the 4 layer rule.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        Name of the rule.
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> Sequence['outputs.GetL4RulesV2ListSourceListResult']:
        """
        Source list of the rule.
        """
        return pulumi.get(self, "source_lists")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> int:
        """
        The source port of the layer 4 rule.
        """
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> int:
        """
        Source type, `1` for source of host, `2` for source of IP.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> int:
        """
        Virtual port of resource.
        """
        return pulumi.get(self, "virtual_port")


@pulumi.output_type
class GetL4RulesV2ListSourceListResult(dict):
    def __init__(__self__, *,
                 source: str,
                 weight: int):
        """
        :param str source: Source IP or domain.
        :param int weight: Weight of the source.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source IP or domain.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the source.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetL7RulesListResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 health_check_code: int,
                 health_check_health_num: int,
                 health_check_interval: int,
                 health_check_method: str,
                 health_check_path: str,
                 health_check_switch: bool,
                 health_check_unhealth_num: int,
                 name: str,
                 protocol: str,
                 rule_id: str,
                 source_lists: Sequence[str],
                 source_type: int,
                 ssl_id: str,
                 status: int,
                 switch: bool,
                 threshold: int):
        """
        :param str domain: Domain of the layer 7 rule to be queried.
        :param int health_check_code: HTTP Status Code. `1` means the return value `1xx` is health. `2` means the return value `2xx` is health. `4` means the return value `3xx` is health. `8` means the return value `4xx` is health. `16` means the return value `5xx` is health. If you want multiple return codes to indicate health, need to add the corresponding values.
        :param int health_check_health_num: Health threshold of health check.
        :param int health_check_interval: Interval time of health check.
        :param str health_check_method: Methods of health check.
        :param str health_check_path: Path of health check.
        :param bool health_check_switch: Indicates whether health check is enabled.
        :param int health_check_unhealth_num: Unhealthy threshold of health check.
        :param str name: Name of the rule.
        :param str protocol: Protocol of the rule.
        :param str rule_id: Id of the layer 7 rule to be queried.
        :param Sequence[str] source_lists: Source list of the rule.
        :param int source_type: Source type, 1 for source of host, 2 for source of ip.
        :param str ssl_id: SSL id.
        :param int status: Status of the rule. `0` for create/modify success, `2` for create/modify fail, `3` for delete success, `5` for waiting to be created/modified, `7` for waiting to be deleted and `8` for waiting to get SSL id.
        :param bool switch: Indicate the rule will take effect or not.
        :param int threshold: Threshold of the rule.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "health_check_code", health_check_code)
        pulumi.set(__self__, "health_check_health_num", health_check_health_num)
        pulumi.set(__self__, "health_check_interval", health_check_interval)
        pulumi.set(__self__, "health_check_method", health_check_method)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "health_check_switch", health_check_switch)
        pulumi.set(__self__, "health_check_unhealth_num", health_check_unhealth_num)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_id", ssl_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "switch", switch)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain of the layer 7 rule to be queried.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="healthCheckCode")
    def health_check_code(self) -> int:
        """
        HTTP Status Code. `1` means the return value `1xx` is health. `2` means the return value `2xx` is health. `4` means the return value `3xx` is health. `8` means the return value `4xx` is health. `16` means the return value `5xx` is health. If you want multiple return codes to indicate health, need to add the corresponding values.
        """
        return pulumi.get(self, "health_check_code")

    @property
    @pulumi.getter(name="healthCheckHealthNum")
    def health_check_health_num(self) -> int:
        """
        Health threshold of health check.
        """
        return pulumi.get(self, "health_check_health_num")

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> int:
        """
        Interval time of health check.
        """
        return pulumi.get(self, "health_check_interval")

    @property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> str:
        """
        Methods of health check.
        """
        return pulumi.get(self, "health_check_method")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        Path of health check.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="healthCheckSwitch")
    def health_check_switch(self) -> bool:
        """
        Indicates whether health check is enabled.
        """
        return pulumi.get(self, "health_check_switch")

    @property
    @pulumi.getter(name="healthCheckUnhealthNum")
    def health_check_unhealth_num(self) -> int:
        """
        Unhealthy threshold of health check.
        """
        return pulumi.get(self, "health_check_unhealth_num")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Id of the layer 7 rule to be queried.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> Sequence[str]:
        """
        Source list of the rule.
        """
        return pulumi.get(self, "source_lists")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> int:
        """
        Source type, 1 for source of host, 2 for source of ip.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslId")
    def ssl_id(self) -> str:
        """
        SSL id.
        """
        return pulumi.get(self, "ssl_id")

    @property
    @pulumi.getter
    def status(self) -> int:
        """
        Status of the rule. `0` for create/modify success, `2` for create/modify fail, `3` for delete success, `5` for waiting to be created/modified, `7` for waiting to be deleted and `8` for waiting to get SSL id.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def switch(self) -> bool:
        """
        Indicate the rule will take effect or not.
        """
        return pulumi.get(self, "switch")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Threshold of the rule.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetL7RulesV2ListResult(dict):
    def __init__(__self__, *,
                 cc_enable: int,
                 cc_level: str,
                 cc_status: int,
                 cc_threshold: int,
                 cert_type: int,
                 domain: str,
                 https_to_http_enable: int,
                 id: str,
                 ip: str,
                 keep_enable: int,
                 keep_time: int,
                 lb_type: int,
                 modify_time: str,
                 protocol: str,
                 region: int,
                 rule_name: str,
                 source_lists: Sequence['outputs.GetL7RulesV2ListSourceListResult'],
                 source_type: int,
                 ssl_id: str,
                 status: int,
                 virtual_port: int):
        """
        :param int cc_enable: CC protection status of HTTPS protocol, the value is [0 (off), 1 (on)].
        :param str cc_level: CC protection level of HTTPS protocol.
        :param int cc_status: CC protection status, value [0(off), 1(on)].
        :param int cc_threshold: CC protection threshold of HTTPS protocol.
        :param int cert_type: The source of the certificate.
        :param str domain: Domain of resource.
        :param int https_to_http_enable: Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], default is off.
        :param str id: Id of the resource.
        :param str ip: Ip of the resource.
        :param int keep_enable: Session keep switch, value [0 (session keep closed), 1 (session keep open)].
        :param int keep_time: Session hold time, in seconds.
        :param int lb_type: Load balancing mode, the value is [1 (weighted round-robin)].
        :param str modify_time: Modify time of resource.
        :param str protocol: Protocol of resource, value range [`http`, `https`].
        :param int region: The area code.
        :param str rule_name: Rule description.
        :param Sequence['GetL7RulesV2ListSourceListArgs'] source_lists: Source list of the rule.
        :param int source_type: Back-to-origin method, value [1 (domain name back-to-source), 2 (IP back-to-source)].
        :param str ssl_id: SSL id of the resource.
        :param int status: Rule status, value [0 (rule configuration is successful), 1 (rule configuration is in effect), 2 (rule configuration fails), 3 (rule deletion is in effect), 5 (rule deletion fails), 6 (rule is waiting to be configured), 7 (rule pending deletion), 8 (rule pending configuration certificate)].
        :param int virtual_port: Virtual port of resource.
        """
        pulumi.set(__self__, "cc_enable", cc_enable)
        pulumi.set(__self__, "cc_level", cc_level)
        pulumi.set(__self__, "cc_status", cc_status)
        pulumi.set(__self__, "cc_threshold", cc_threshold)
        pulumi.set(__self__, "cert_type", cert_type)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "https_to_http_enable", https_to_http_enable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "keep_enable", keep_enable)
        pulumi.set(__self__, "keep_time", keep_time)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_id", ssl_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "virtual_port", virtual_port)

    @property
    @pulumi.getter(name="ccEnable")
    def cc_enable(self) -> int:
        """
        CC protection status of HTTPS protocol, the value is [0 (off), 1 (on)].
        """
        return pulumi.get(self, "cc_enable")

    @property
    @pulumi.getter(name="ccLevel")
    def cc_level(self) -> str:
        """
        CC protection level of HTTPS protocol.
        """
        return pulumi.get(self, "cc_level")

    @property
    @pulumi.getter(name="ccStatus")
    def cc_status(self) -> int:
        """
        CC protection status, value [0(off), 1(on)].
        """
        return pulumi.get(self, "cc_status")

    @property
    @pulumi.getter(name="ccThreshold")
    def cc_threshold(self) -> int:
        """
        CC protection threshold of HTTPS protocol.
        """
        return pulumi.get(self, "cc_threshold")

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> int:
        """
        The source of the certificate.
        """
        return pulumi.get(self, "cert_type")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain of resource.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="httpsToHttpEnable")
    def https_to_http_enable(self) -> int:
        """
        Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], default is off.
        """
        return pulumi.get(self, "https_to_http_enable")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        Ip of the resource.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="keepEnable")
    def keep_enable(self) -> int:
        """
        Session keep switch, value [0 (session keep closed), 1 (session keep open)].
        """
        return pulumi.get(self, "keep_enable")

    @property
    @pulumi.getter(name="keepTime")
    def keep_time(self) -> int:
        """
        Session hold time, in seconds.
        """
        return pulumi.get(self, "keep_time")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        Load balancing mode, the value is [1 (weighted round-robin)].
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> str:
        """
        Modify time of resource.
        """
        return pulumi.get(self, "modify_time")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of resource, value range [`http`, `https`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def region(self) -> int:
        """
        The area code.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        Rule description.
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> Sequence['outputs.GetL7RulesV2ListSourceListResult']:
        """
        Source list of the rule.
        """
        return pulumi.get(self, "source_lists")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> int:
        """
        Back-to-origin method, value [1 (domain name back-to-source), 2 (IP back-to-source)].
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sslId")
    def ssl_id(self) -> str:
        """
        SSL id of the resource.
        """
        return pulumi.get(self, "ssl_id")

    @property
    @pulumi.getter
    def status(self) -> int:
        """
        Rule status, value [0 (rule configuration is successful), 1 (rule configuration is in effect), 2 (rule configuration fails), 3 (rule deletion is in effect), 5 (rule deletion fails), 6 (rule is waiting to be configured), 7 (rule pending deletion), 8 (rule pending configuration certificate)].
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> int:
        """
        Virtual port of resource.
        """
        return pulumi.get(self, "virtual_port")


@pulumi.output_type
class GetL7RulesV2ListSourceListResult(dict):
    def __init__(__self__, *,
                 source: str,
                 weight: int):
        """
        :param str source: Back-to-source IP or domain name.
        :param int weight: Weight value, take value [0,100].
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Back-to-source IP or domain name.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight value, take value [0,100].
        """
        return pulumi.get(self, "weight")


