# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CcHttpPolicyRuleListArgs',
    'CcHttpsPolicyRuleListArgs',
    'CcPolicyV2CcBlackWhiteIpArgs',
    'CcPolicyV2CcGeoIpPolicyArgs',
    'CcPolicyV2CcPrecisionPolicyArgs',
    'CcPolicyV2CcPrecisionPolicyPolicyArgs',
    'CcPolicyV2CcPrecisionReqLimitArgs',
    'CcPolicyV2CcPrecisionReqLimitPolicyArgs',
    'CcPolicyV2ThresholdArgs',
    'DdosIpAttachmentV2BoundIpListArgs',
    'DdosPolicyDropOptionArgs',
    'DdosPolicyPacketFilterArgs',
    'DdosPolicyPortFilterArgs',
    'DdosPolicyV2AclArgs',
    'DdosPolicyV2BlackWhiteIpArgs',
    'DdosPolicyV2DdosConnectLimitArgs',
    'DdosPolicyV2DdosGeoIpBlockConfigArgs',
    'DdosPolicyV2DdosSpeedLimitConfigArgs',
    'DdosPolicyV2PacketFilterArgs',
    'DdosPolicyV2ProtocolBlockConfigArgs',
    'DdosPolicyV2WaterPrintConfigArgs',
    'DdosPolicyV2WaterPrintConfigListenerArgs',
    'DdosPolicyWatermarkFilterArgs',
    'DdosPolicyWatermarkKeyArgs',
    'L4RuleSourceListArgs',
    'L4RuleV2RulesArgs',
    'L4RuleV2RulesSourceListArgs',
    'L7RuleV2RuleArgs',
    'L7RuleV2RuleSourceListArgs',
]

@pulumi.input_type
class CcHttpPolicyRuleListArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 skey: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: Operator of the rule. Valid values: `include`, `not_include`, `equal`.
        :param pulumi.Input[str] skey: Key of the rule. Valid values: `host`, `cgi`, `ua`, `referer`.
        :param pulumi.Input[str] value: Rule value, then length should be less than 31 bytes.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if skey is not None:
            pulumi.set(__self__, "skey", skey)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator of the rule. Valid values: `include`, `not_include`, `equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def skey(self) -> Optional[pulumi.Input[str]]:
        """
        Key of the rule. Valid values: `host`, `cgi`, `ua`, `referer`.
        """
        return pulumi.get(self, "skey")

    @skey.setter
    def skey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "skey", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Rule value, then length should be less than 31 bytes.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CcHttpsPolicyRuleListArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 skey: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] operator: Operator of the rule. Valid values are `include` and `equal`.
        :param pulumi.Input[str] skey: Key of the rule. Valid values are `cgi`, `ua` and `referer`.
        :param pulumi.Input[str] value: Rule value, then length should be less than 31 bytes.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "skey", skey)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Operator of the rule. Valid values are `include` and `equal`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def skey(self) -> pulumi.Input[str]:
        """
        Key of the rule. Valid values are `cgi`, `ua` and `referer`.
        """
        return pulumi.get(self, "skey")

    @skey.setter
    def skey(self, value: pulumi.Input[str]):
        pulumi.set(self, "skey", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Rule value, then length should be less than 31 bytes.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CcPolicyV2CcBlackWhiteIpArgs:
    def __init__(__self__, *,
                 black_white_ip: pulumi.Input[str],
                 domain: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 type: pulumi.Input[str],
                 create_time: Optional[pulumi.Input[str]] = None,
                 modify_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] black_white_ip: Blacklist and whitelist IP addresses.
        :param pulumi.Input[str] domain: Domain.
        :param pulumi.Input[str] protocol: Protocol.
        :param pulumi.Input[str] type: IP type, value [black(blacklist IP), white (whitelist IP)].
        :param pulumi.Input[str] create_time: Create time.
        :param pulumi.Input[str] modify_time: Modify time.
        """
        pulumi.set(__self__, "black_white_ip", black_white_ip)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "type", type)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)

    @property
    @pulumi.getter(name="blackWhiteIp")
    def black_white_ip(self) -> pulumi.Input[str]:
        """
        Blacklist and whitelist IP addresses.
        """
        return pulumi.get(self, "black_white_ip")

    @black_white_ip.setter
    def black_white_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "black_white_ip", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        IP type, value [black(blacklist IP), white (whitelist IP)].
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[pulumi.Input[str]]:
        """
        Modify time.
        """
        return pulumi.get(self, "modify_time")

    @modify_time.setter
    def modify_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modify_time", value)


@pulumi.input_type
class CcPolicyV2CcGeoIpPolicyArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 domain: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 region_type: pulumi.Input[str],
                 area_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 create_time: Optional[pulumi.Input[str]] = None,
                 modify_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: User action, drop or arg.
        :param pulumi.Input[str] domain: domain.
        :param pulumi.Input[str] protocol: Protocol, preferably HTTP, HTTPS.
        :param pulumi.Input[str] region_type: Regional types, divided into china, oversea and customized.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] area_lists: The list of region IDs that the user selects to block.
        :param pulumi.Input[str] create_time: Create time.
        :param pulumi.Input[str] modify_time: Modify time.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region_type", region_type)
        if area_lists is not None:
            pulumi.set(__self__, "area_lists", area_lists)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        User action, drop or arg.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol, preferably HTTP, HTTPS.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="regionType")
    def region_type(self) -> pulumi.Input[str]:
        """
        Regional types, divided into china, oversea and customized.
        """
        return pulumi.get(self, "region_type")

    @region_type.setter
    def region_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_type", value)

    @property
    @pulumi.getter(name="areaLists")
    def area_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The list of region IDs that the user selects to block.
        """
        return pulumi.get(self, "area_lists")

    @area_lists.setter
    def area_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "area_lists", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        Create time.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[pulumi.Input[str]]:
        """
        Modify time.
        """
        return pulumi.get(self, "modify_time")

    @modify_time.setter
    def modify_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modify_time", value)


@pulumi.input_type
class CcPolicyV2CcPrecisionPolicyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 ip: pulumi.Input[str],
                 policy_action: pulumi.Input[str],
                 policys: pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionPolicyPolicyArgs']]],
                 protocol: pulumi.Input[str],
                 policy_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Domain.
        :param pulumi.Input[str] ip: Ip address.
        :param pulumi.Input[str] policy_action: Policy mode (discard or captcha).
        :param pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionPolicyPolicyArgs']]] policys: A list of policies.
        :param pulumi.Input[str] protocol: Protocol.
        :param pulumi.Input[str] policy_id: Policy Id.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "policy_action", policy_action)
        pulumi.set(__self__, "policys", policys)
        pulumi.set(__self__, "protocol", protocol)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        Ip address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="policyAction")
    def policy_action(self) -> pulumi.Input[str]:
        """
        Policy mode (discard or captcha).
        """
        return pulumi.get(self, "policy_action")

    @policy_action.setter
    def policy_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_action", value)

    @property
    @pulumi.getter
    def policys(self) -> pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionPolicyPolicyArgs']]]:
        """
        A list of policies.
        """
        return pulumi.get(self, "policys")

    @policys.setter
    def policys(self, value: pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionPolicyPolicyArgs']]]):
        pulumi.set(self, "policys", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Policy Id.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)


@pulumi.input_type
class CcPolicyV2CcPrecisionPolicyPolicyArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 field_type: pulumi.Input[str],
                 value: pulumi.Input[str],
                 value_operator: pulumi.Input[str]):
        """
        :param pulumi.Input[str] field_name: Configuration item types, currently only support value.
        :param pulumi.Input[str] field_type: Configuration fields with the desirable values cgi, ua, cookie, referer, accept, srcip.
        :param pulumi.Input[str] value: Configure the value.
        :param pulumi.Input[str] value_operator: Configure the item-value comparison mode, which can be taken as the value of evaluate, not_equal, include.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_operator", value_operator)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        """
        Configuration item types, currently only support value.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[str]:
        """
        Configuration fields with the desirable values cgi, ua, cookie, referer, accept, srcip.
        """
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Configure the value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueOperator")
    def value_operator(self) -> pulumi.Input[str]:
        """
        Configure the item-value comparison mode, which can be taken as the value of evaluate, not_equal, include.
        """
        return pulumi.get(self, "value_operator")

    @value_operator.setter
    def value_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_operator", value)


@pulumi.input_type
class CcPolicyV2CcPrecisionReqLimitArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 level: pulumi.Input[str],
                 policys: pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionReqLimitPolicyArgs']]],
                 protocol: pulumi.Input[str],
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Domain.
        :param pulumi.Input[str] level: Protection rating, the optional value of default means default policy, loose means loose, and strict means strict.
        :param pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionReqLimitPolicyArgs']]] policys: The CC Frequency Limit Policy Item field.
        :param pulumi.Input[str] protocol: Protocol, preferably HTTP, HTTPS.
        :param pulumi.Input[str] instance_id: Instance id.
        :param pulumi.Input[str] ip: Ip address.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "policys", policys)
        pulumi.set(__self__, "protocol", protocol)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        Protection rating, the optional value of default means default policy, loose means loose, and strict means strict.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def policys(self) -> pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionReqLimitPolicyArgs']]]:
        """
        The CC Frequency Limit Policy Item field.
        """
        return pulumi.get(self, "policys")

    @policys.setter
    def policys(self, value: pulumi.Input[Sequence[pulumi.Input['CcPolicyV2CcPrecisionReqLimitPolicyArgs']]]):
        pulumi.set(self, "policys", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol, preferably HTTP, HTTPS.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Ip address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class CcPolicyV2CcPrecisionReqLimitPolicyArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 execute_duration: pulumi.Input[int],
                 mode: pulumi.Input[str],
                 period: pulumi.Input[int],
                 request_num: pulumi.Input[int],
                 cookie: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None,
                 user_agent: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The frequency limit policy mode, the optional value of arg indicates the verification code, and drop indicates the discard.
        :param pulumi.Input[int] execute_duration: The duration of the frequency limit policy can be taken from 1 to 86400 per second.
        :param pulumi.Input[str] mode: The policy item is compared, and the optional value include indicates inclusion, and equal means equal.
        :param pulumi.Input[int] period: Statistical period, take values 1, 10, 30, 60, in seconds.
        :param pulumi.Input[int] request_num: The number of requests, the value is 1 to 20000.
        :param pulumi.Input[str] cookie: Cookies, one of the three policy entries can only be filled in.
        :param pulumi.Input[str] uri: Uri, one of the three policy entries can only be filled in.
        :param pulumi.Input[str] user_agent: User-Agent, only one of the three policy entries can be filled in.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "execute_duration", execute_duration)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "request_num", request_num)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The frequency limit policy mode, the optional value of arg indicates the verification code, and drop indicates the discard.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="executeDuration")
    def execute_duration(self) -> pulumi.Input[int]:
        """
        The duration of the frequency limit policy can be taken from 1 to 86400 per second.
        """
        return pulumi.get(self, "execute_duration")

    @execute_duration.setter
    def execute_duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "execute_duration", value)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The policy item is compared, and the optional value include indicates inclusion, and equal means equal.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[int]:
        """
        Statistical period, take values 1, 10, 30, 60, in seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="requestNum")
    def request_num(self) -> pulumi.Input[int]:
        """
        The number of requests, the value is 1 to 20000.
        """
        return pulumi.get(self, "request_num")

    @request_num.setter
    def request_num(self, value: pulumi.Input[int]):
        pulumi.set(self, "request_num", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input[str]]:
        """
        Cookies, one of the three policy entries can only be filled in.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        Uri, one of the three policy entries can only be filled in.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[str]]:
        """
        User-Agent, only one of the three policy entries can be filled in.
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_agent", value)


@pulumi.input_type
class CcPolicyV2ThresholdArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 threshold: pulumi.Input[int]):
        """
        :param pulumi.Input[str] domain: domain.
        :param pulumi.Input[int] threshold: Cleaning threshold, -1 indicates that the `default` mode is turned on.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        """
        Cleaning threshold, -1 indicates that the `default` mode is turned on.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class DdosIpAttachmentV2BoundIpListArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 biz_type: Optional[pulumi.Input[str]] = None,
                 device_type: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: IP address.
        :param pulumi.Input[str] biz_type: Category of product that can be bound. Valid values: public (CVM and CLB), bm (BM), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), and other (hosted IP). This field is required when you perform binding.
        :param pulumi.Input[str] device_type: Sub-product category. Valid values: cvm (CVM), lb (Load balancer), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), eip (BM EIP) and other (managed IP). This field is required when you perform binding.
        :param pulumi.Input[str] instance_id: Anti-DDoS instance ID of the IP. This field is required only when the instance is bound to an IP. For example, this field InstanceId will be eni-* if the instance ID is bound to an ENI IP; none if there is no instance to bind to a managed IP.
        """
        pulumi.set(__self__, "ip", ip)
        if biz_type is not None:
            pulumi.set(__self__, "biz_type", biz_type)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="bizType")
    def biz_type(self) -> Optional[pulumi.Input[str]]:
        """
        Category of product that can be bound. Valid values: public (CVM and CLB), bm (BM), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), and other (hosted IP). This field is required when you perform binding.
        """
        return pulumi.get(self, "biz_type")

    @biz_type.setter
    def biz_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "biz_type", value)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[str]]:
        """
        Sub-product category. Valid values: cvm (CVM), lb (Load balancer), eni (ENI), vpngw (VPN gateway), natgw (NAT gateway), waf (WAF), fpc (financial products), gaap (GAAP), eip (BM EIP) and other (managed IP). This field is required when you perform binding.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Anti-DDoS instance ID of the IP. This field is required only when the instance is bound to an IP. For example, this field InstanceId will be eni-* if the instance ID is bound to an ENI IP; none if there is no instance to bind to a managed IP.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)


@pulumi.input_type
class DdosPolicyDropOptionArgs:
    def __init__(__self__, *,
                 bad_conn_threshold: pulumi.Input[int],
                 check_sync_conn: pulumi.Input[bool],
                 conn_timeout: pulumi.Input[int],
                 d_conn_limit: pulumi.Input[int],
                 d_new_limit: pulumi.Input[int],
                 drop_abroad: pulumi.Input[bool],
                 drop_icmp: pulumi.Input[bool],
                 drop_other: pulumi.Input[bool],
                 drop_tcp: pulumi.Input[bool],
                 drop_udp: pulumi.Input[bool],
                 icmp_mbps_limit: pulumi.Input[int],
                 null_conn_enable: pulumi.Input[bool],
                 other_mbps_limit: pulumi.Input[int],
                 s_conn_limit: pulumi.Input[int],
                 s_new_limit: pulumi.Input[int],
                 syn_limit: pulumi.Input[int],
                 tcp_mbps_limit: pulumi.Input[int],
                 udp_mbps_limit: pulumi.Input[int],
                 syn_rate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bad_conn_threshold: The number of new connections based on destination IP that trigger suppression of connections. Valid value ranges: (0~4294967295).
        :param pulumi.Input[bool] check_sync_conn: Indicate whether to check null connection or not.
        :param pulumi.Input[int] conn_timeout: Connection timeout of abnormal connection check. Valid value ranges: (0~65535).
        :param pulumi.Input[int] d_conn_limit: The limit of concurrent connections based on destination IP. Valid value ranges: (0~4294967295).
        :param pulumi.Input[int] d_new_limit: The limit of new connections based on destination IP. Valid value ranges: (0~4294967295).
        :param pulumi.Input[bool] drop_abroad: Indicate whether to drop abroad traffic or not.
        :param pulumi.Input[bool] drop_icmp: Indicate whether to drop ICMP protocol or not.
        :param pulumi.Input[bool] drop_other: Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
        :param pulumi.Input[bool] drop_tcp: Indicate whether to drop TCP protocol or not.
        :param pulumi.Input[bool] drop_udp: Indicate to drop UDP protocol or not.
        :param pulumi.Input[int] icmp_mbps_limit: The limit of ICMP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        :param pulumi.Input[bool] null_conn_enable: Indicate to enable null connection or not.
        :param pulumi.Input[int] other_mbps_limit: The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        :param pulumi.Input[int] s_conn_limit: The limit of concurrent connections based on source IP. Valid value ranges: (0~4294967295).
        :param pulumi.Input[int] s_new_limit: The limit of new connections based on source IP. Valid value ranges: (0~4294967295).
        :param pulumi.Input[int] syn_limit: The limit of syn of abnormal connection check. Valid value ranges: (0~100).
        :param pulumi.Input[int] tcp_mbps_limit: The limit of TCP traffic. Valid value ranges: (0~4294967295)(Mbps).
        :param pulumi.Input[int] udp_mbps_limit: The limit of UDP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        :param pulumi.Input[int] syn_rate: The percentage of syn in ack of abnormal connection check. Valid value ranges: (0~100).
        """
        pulumi.set(__self__, "bad_conn_threshold", bad_conn_threshold)
        pulumi.set(__self__, "check_sync_conn", check_sync_conn)
        pulumi.set(__self__, "conn_timeout", conn_timeout)
        pulumi.set(__self__, "d_conn_limit", d_conn_limit)
        pulumi.set(__self__, "d_new_limit", d_new_limit)
        pulumi.set(__self__, "drop_abroad", drop_abroad)
        pulumi.set(__self__, "drop_icmp", drop_icmp)
        pulumi.set(__self__, "drop_other", drop_other)
        pulumi.set(__self__, "drop_tcp", drop_tcp)
        pulumi.set(__self__, "drop_udp", drop_udp)
        pulumi.set(__self__, "icmp_mbps_limit", icmp_mbps_limit)
        pulumi.set(__self__, "null_conn_enable", null_conn_enable)
        pulumi.set(__self__, "other_mbps_limit", other_mbps_limit)
        pulumi.set(__self__, "s_conn_limit", s_conn_limit)
        pulumi.set(__self__, "s_new_limit", s_new_limit)
        pulumi.set(__self__, "syn_limit", syn_limit)
        pulumi.set(__self__, "tcp_mbps_limit", tcp_mbps_limit)
        pulumi.set(__self__, "udp_mbps_limit", udp_mbps_limit)
        if syn_rate is not None:
            pulumi.set(__self__, "syn_rate", syn_rate)

    @property
    @pulumi.getter(name="badConnThreshold")
    def bad_conn_threshold(self) -> pulumi.Input[int]:
        """
        The number of new connections based on destination IP that trigger suppression of connections. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "bad_conn_threshold")

    @bad_conn_threshold.setter
    def bad_conn_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "bad_conn_threshold", value)

    @property
    @pulumi.getter(name="checkSyncConn")
    def check_sync_conn(self) -> pulumi.Input[bool]:
        """
        Indicate whether to check null connection or not.
        """
        return pulumi.get(self, "check_sync_conn")

    @check_sync_conn.setter
    def check_sync_conn(self, value: pulumi.Input[bool]):
        pulumi.set(self, "check_sync_conn", value)

    @property
    @pulumi.getter(name="connTimeout")
    def conn_timeout(self) -> pulumi.Input[int]:
        """
        Connection timeout of abnormal connection check. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "conn_timeout")

    @conn_timeout.setter
    def conn_timeout(self, value: pulumi.Input[int]):
        pulumi.set(self, "conn_timeout", value)

    @property
    @pulumi.getter(name="dConnLimit")
    def d_conn_limit(self) -> pulumi.Input[int]:
        """
        The limit of concurrent connections based on destination IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "d_conn_limit")

    @d_conn_limit.setter
    def d_conn_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "d_conn_limit", value)

    @property
    @pulumi.getter(name="dNewLimit")
    def d_new_limit(self) -> pulumi.Input[int]:
        """
        The limit of new connections based on destination IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "d_new_limit")

    @d_new_limit.setter
    def d_new_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "d_new_limit", value)

    @property
    @pulumi.getter(name="dropAbroad")
    def drop_abroad(self) -> pulumi.Input[bool]:
        """
        Indicate whether to drop abroad traffic or not.
        """
        return pulumi.get(self, "drop_abroad")

    @drop_abroad.setter
    def drop_abroad(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_abroad", value)

    @property
    @pulumi.getter(name="dropIcmp")
    def drop_icmp(self) -> pulumi.Input[bool]:
        """
        Indicate whether to drop ICMP protocol or not.
        """
        return pulumi.get(self, "drop_icmp")

    @drop_icmp.setter
    def drop_icmp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_icmp", value)

    @property
    @pulumi.getter(name="dropOther")
    def drop_other(self) -> pulumi.Input[bool]:
        """
        Indicate whether to drop other protocols(exclude TCP/UDP/ICMP) or not.
        """
        return pulumi.get(self, "drop_other")

    @drop_other.setter
    def drop_other(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_other", value)

    @property
    @pulumi.getter(name="dropTcp")
    def drop_tcp(self) -> pulumi.Input[bool]:
        """
        Indicate whether to drop TCP protocol or not.
        """
        return pulumi.get(self, "drop_tcp")

    @drop_tcp.setter
    def drop_tcp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_tcp", value)

    @property
    @pulumi.getter(name="dropUdp")
    def drop_udp(self) -> pulumi.Input[bool]:
        """
        Indicate to drop UDP protocol or not.
        """
        return pulumi.get(self, "drop_udp")

    @drop_udp.setter
    def drop_udp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "drop_udp", value)

    @property
    @pulumi.getter(name="icmpMbpsLimit")
    def icmp_mbps_limit(self) -> pulumi.Input[int]:
        """
        The limit of ICMP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "icmp_mbps_limit")

    @icmp_mbps_limit.setter
    def icmp_mbps_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "icmp_mbps_limit", value)

    @property
    @pulumi.getter(name="nullConnEnable")
    def null_conn_enable(self) -> pulumi.Input[bool]:
        """
        Indicate to enable null connection or not.
        """
        return pulumi.get(self, "null_conn_enable")

    @null_conn_enable.setter
    def null_conn_enable(self, value: pulumi.Input[bool]):
        pulumi.set(self, "null_conn_enable", value)

    @property
    @pulumi.getter(name="otherMbpsLimit")
    def other_mbps_limit(self) -> pulumi.Input[int]:
        """
        The limit of other protocols(exclude TCP/UDP/ICMP) traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "other_mbps_limit")

    @other_mbps_limit.setter
    def other_mbps_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "other_mbps_limit", value)

    @property
    @pulumi.getter(name="sConnLimit")
    def s_conn_limit(self) -> pulumi.Input[int]:
        """
        The limit of concurrent connections based on source IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "s_conn_limit")

    @s_conn_limit.setter
    def s_conn_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "s_conn_limit", value)

    @property
    @pulumi.getter(name="sNewLimit")
    def s_new_limit(self) -> pulumi.Input[int]:
        """
        The limit of new connections based on source IP. Valid value ranges: (0~4294967295).
        """
        return pulumi.get(self, "s_new_limit")

    @s_new_limit.setter
    def s_new_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "s_new_limit", value)

    @property
    @pulumi.getter(name="synLimit")
    def syn_limit(self) -> pulumi.Input[int]:
        """
        The limit of syn of abnormal connection check. Valid value ranges: (0~100).
        """
        return pulumi.get(self, "syn_limit")

    @syn_limit.setter
    def syn_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "syn_limit", value)

    @property
    @pulumi.getter(name="tcpMbpsLimit")
    def tcp_mbps_limit(self) -> pulumi.Input[int]:
        """
        The limit of TCP traffic. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "tcp_mbps_limit")

    @tcp_mbps_limit.setter
    def tcp_mbps_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "tcp_mbps_limit", value)

    @property
    @pulumi.getter(name="udpMbpsLimit")
    def udp_mbps_limit(self) -> pulumi.Input[int]:
        """
        The limit of UDP traffic rate. Valid value ranges: (0~4294967295)(Mbps).
        """
        return pulumi.get(self, "udp_mbps_limit")

    @udp_mbps_limit.setter
    def udp_mbps_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "udp_mbps_limit", value)

    @property
    @pulumi.getter(name="synRate")
    def syn_rate(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of syn in ack of abnormal connection check. Valid value ranges: (0~100).
        """
        return pulumi.get(self, "syn_rate")

    @syn_rate.setter
    def syn_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "syn_rate", value)


@pulumi.input_type
class DdosPolicyPacketFilterArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 d_end_port: Optional[pulumi.Input[int]] = None,
                 d_start_port: Optional[pulumi.Input[int]] = None,
                 depth: Optional[pulumi.Input[int]] = None,
                 is_include: Optional[pulumi.Input[bool]] = None,
                 match_begin: Optional[pulumi.Input[str]] = None,
                 match_str: Optional[pulumi.Input[str]] = None,
                 match_type: Optional[pulumi.Input[str]] = None,
                 offset: Optional[pulumi.Input[int]] = None,
                 pkt_length_max: Optional[pulumi.Input[int]] = None,
                 pkt_length_min: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 s_end_port: Optional[pulumi.Input[int]] = None,
                 s_start_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: Action of port to take. Valid values: `drop`, `drop_black`,`drop_rst`,`drop_black_rst`,`transmit`.`drop`(drop the packet), `drop_black`(drop the packet and black the ip),`drop_rst`(drop the packet and disconnect),`drop_black_rst`(drop the packet, black the ip and disconnect),`transmit`(transmit the packet).
        :param pulumi.Input[int] d_end_port: End port of the destination. Valid value ranges: (0~65535). It must be greater than `d_start_port`.
        :param pulumi.Input[int] d_start_port: Start port of the destination. Valid value ranges: (0~65535).
        :param pulumi.Input[int] depth: The depth of match. Valid value ranges: (0~1500).
        :param pulumi.Input[bool] is_include: Indicate whether to include the key word/regular expression or not.
        :param pulumi.Input[str] match_begin: Indicate whether to check load or not, `begin_l5` means to match and `no_match` means not.
        :param pulumi.Input[str] match_str: The key word or regular expression.
        :param pulumi.Input[str] match_type: Match type. Valid values: `sunday` and `pcre`. `sunday` means key word match while `pcre` means regular match.
        :param pulumi.Input[int] offset: The offset of match. Valid value ranges: (0~1500).
        :param pulumi.Input[int] pkt_length_max: The max length of the packet. Valid value ranges: (0~1500)(Mbps). It must be greater than `pkt_length_min`.
        :param pulumi.Input[int] pkt_length_min: The minimum length of the packet. Valid value ranges: (0~1500)(Mbps).
        :param pulumi.Input[str] protocol: Protocol. Valid values: `tcp`, `udp`, `icmp`, `all`.
        :param pulumi.Input[int] s_end_port: End port of the source. Valid value ranges: (0~65535). It must be greater than `s_start_port`.
        :param pulumi.Input[int] s_start_port: Start port of the source. Valid value ranges: (0~65535).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if d_end_port is not None:
            pulumi.set(__self__, "d_end_port", d_end_port)
        if d_start_port is not None:
            pulumi.set(__self__, "d_start_port", d_start_port)
        if depth is not None:
            pulumi.set(__self__, "depth", depth)
        if is_include is not None:
            pulumi.set(__self__, "is_include", is_include)
        if match_begin is not None:
            pulumi.set(__self__, "match_begin", match_begin)
        if match_str is not None:
            pulumi.set(__self__, "match_str", match_str)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if pkt_length_max is not None:
            pulumi.set(__self__, "pkt_length_max", pkt_length_max)
        if pkt_length_min is not None:
            pulumi.set(__self__, "pkt_length_min", pkt_length_min)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if s_end_port is not None:
            pulumi.set(__self__, "s_end_port", s_end_port)
        if s_start_port is not None:
            pulumi.set(__self__, "s_start_port", s_start_port)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action of port to take. Valid values: `drop`, `drop_black`,`drop_rst`,`drop_black_rst`,`transmit`.`drop`(drop the packet), `drop_black`(drop the packet and black the ip),`drop_rst`(drop the packet and disconnect),`drop_black_rst`(drop the packet, black the ip and disconnect),`transmit`(transmit the packet).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="dEndPort")
    def d_end_port(self) -> Optional[pulumi.Input[int]]:
        """
        End port of the destination. Valid value ranges: (0~65535). It must be greater than `d_start_port`.
        """
        return pulumi.get(self, "d_end_port")

    @d_end_port.setter
    def d_end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "d_end_port", value)

    @property
    @pulumi.getter(name="dStartPort")
    def d_start_port(self) -> Optional[pulumi.Input[int]]:
        """
        Start port of the destination. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "d_start_port")

    @d_start_port.setter
    def d_start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "d_start_port", value)

    @property
    @pulumi.getter
    def depth(self) -> Optional[pulumi.Input[int]]:
        """
        The depth of match. Valid value ranges: (0~1500).
        """
        return pulumi.get(self, "depth")

    @depth.setter
    def depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "depth", value)

    @property
    @pulumi.getter(name="isInclude")
    def is_include(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate whether to include the key word/regular expression or not.
        """
        return pulumi.get(self, "is_include")

    @is_include.setter
    def is_include(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_include", value)

    @property
    @pulumi.getter(name="matchBegin")
    def match_begin(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether to check load or not, `begin_l5` means to match and `no_match` means not.
        """
        return pulumi.get(self, "match_begin")

    @match_begin.setter
    def match_begin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_begin", value)

    @property
    @pulumi.getter(name="matchStr")
    def match_str(self) -> Optional[pulumi.Input[str]]:
        """
        The key word or regular expression.
        """
        return pulumi.get(self, "match_str")

    @match_str.setter
    def match_str(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_str", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        Match type. Valid values: `sunday` and `pcre`. `sunday` means key word match while `pcre` means regular match.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[int]]:
        """
        The offset of match. Valid value ranges: (0~1500).
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="pktLengthMax")
    def pkt_length_max(self) -> Optional[pulumi.Input[int]]:
        """
        The max length of the packet. Valid value ranges: (0~1500)(Mbps). It must be greater than `pkt_length_min`.
        """
        return pulumi.get(self, "pkt_length_max")

    @pkt_length_max.setter
    def pkt_length_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pkt_length_max", value)

    @property
    @pulumi.getter(name="pktLengthMin")
    def pkt_length_min(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum length of the packet. Valid value ranges: (0~1500)(Mbps).
        """
        return pulumi.get(self, "pkt_length_min")

    @pkt_length_min.setter
    def pkt_length_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pkt_length_min", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol. Valid values: `tcp`, `udp`, `icmp`, `all`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sEndPort")
    def s_end_port(self) -> Optional[pulumi.Input[int]]:
        """
        End port of the source. Valid value ranges: (0~65535). It must be greater than `s_start_port`.
        """
        return pulumi.get(self, "s_end_port")

    @s_end_port.setter
    def s_end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "s_end_port", value)

    @property
    @pulumi.getter(name="sStartPort")
    def s_start_port(self) -> Optional[pulumi.Input[int]]:
        """
        Start port of the source. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "s_start_port")

    @s_start_port.setter
    def s_start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "s_start_port", value)


@pulumi.input_type
class DdosPolicyPortFilterArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 end_port: Optional[pulumi.Input[int]] = None,
                 kind: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: Action of port to take. Valid values: `drop`, `transmit`.
        :param pulumi.Input[int] end_port: End port. Valid value ranges: (0~65535). It must be greater than `start_port`.
        :param pulumi.Input[int] kind: The type of forbidden port. Valid values: `0`, `1`, `2`. `0` for destination ports make effect, `1` for source ports make effect. `2` for both destination and source ports.
        :param pulumi.Input[str] protocol: Protocol. Valid values are `tcp`, `udp`, `icmp`, `all`.
        :param pulumi.Input[int] start_port: Start port. Valid value ranges: (0~65535).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action of port to take. Valid values: `drop`, `transmit`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        """
        End port. Valid value ranges: (0~65535). It must be greater than `start_port`.
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[int]]:
        """
        The type of forbidden port. Valid values: `0`, `1`, `2`. `0` for destination ports make effect, `1` for source ports make effect. `2` for both destination and source ports.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol. Valid values are `tcp`, `udp`, `icmp`, `all`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        """
        Start port. Valid value ranges: (0~65535).
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


@pulumi.input_type
class DdosPolicyV2AclArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 d_port_end: pulumi.Input[int],
                 d_port_start: pulumi.Input[int],
                 forward_protocol: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 s_port_end: pulumi.Input[int],
                 s_port_start: pulumi.Input[int]):
        """
        :param pulumi.Input[str] action: Action, optional values: drop, transmit, forward.
        :param pulumi.Input[int] d_port_end: The destination port ends, and the value range is 0~65535.
        :param pulumi.Input[int] d_port_start: The destination port starts, and the value range is 0~65535.
        :param pulumi.Input[str] forward_protocol: Protocol type, desirable values tcp, udp, all.
        :param pulumi.Input[int] priority: Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
        :param pulumi.Input[int] s_port_end: The source port ends, and the acceptable value ranges from 0 to 65535.
        :param pulumi.Input[int] s_port_start: The source port starts, and the value range is 0~65535.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "d_port_end", d_port_end)
        pulumi.set(__self__, "d_port_start", d_port_start)
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "s_port_end", s_port_end)
        pulumi.set(__self__, "s_port_start", s_port_start)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action, optional values: drop, transmit, forward.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="dPortEnd")
    def d_port_end(self) -> pulumi.Input[int]:
        """
        The destination port ends, and the value range is 0~65535.
        """
        return pulumi.get(self, "d_port_end")

    @d_port_end.setter
    def d_port_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "d_port_end", value)

    @property
    @pulumi.getter(name="dPortStart")
    def d_port_start(self) -> pulumi.Input[int]:
        """
        The destination port starts, and the value range is 0~65535.
        """
        return pulumi.get(self, "d_port_start")

    @d_port_start.setter
    def d_port_start(self, value: pulumi.Input[int]):
        pulumi.set(self, "d_port_start", value)

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> pulumi.Input[str]:
        """
        Protocol type, desirable values tcp, udp, all.
        """
        return pulumi.get(self, "forward_protocol")

    @forward_protocol.setter
    def forward_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "forward_protocol", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="sPortEnd")
    def s_port_end(self) -> pulumi.Input[int]:
        """
        The source port ends, and the acceptable value ranges from 0 to 65535.
        """
        return pulumi.get(self, "s_port_end")

    @s_port_end.setter
    def s_port_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "s_port_end", value)

    @property
    @pulumi.getter(name="sPortStart")
    def s_port_start(self) -> pulumi.Input[int]:
        """
        The source port starts, and the value range is 0~65535.
        """
        return pulumi.get(self, "s_port_start")

    @s_port_start.setter
    def s_port_start(self, value: pulumi.Input[int]):
        pulumi.set(self, "s_port_start", value)


@pulumi.input_type
class DdosPolicyV2BlackWhiteIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 ip_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: Ip of resource instance.
        :param pulumi.Input[str] ip_type: IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_type", ip_type)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        Ip of resource instance.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> pulumi.Input[str]:
        """
        IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
        """
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_type", value)


@pulumi.input_type
class DdosPolicyV2DdosConnectLimitArgs:
    def __init__(__self__, *,
                 bad_conn_threshold: pulumi.Input[int],
                 conn_timeout: pulumi.Input[int],
                 dst_conn_limit: pulumi.Input[int],
                 dst_new_limit: pulumi.Input[int],
                 null_conn_enable: pulumi.Input[int],
                 sd_conn_limit: pulumi.Input[int],
                 sd_new_limit: pulumi.Input[int],
                 syn_limit: pulumi.Input[int],
                 syn_rate: pulumi.Input[int]):
        """
        :param pulumi.Input[int] bad_conn_threshold: Based on connection suppression trigger threshold, value range [0,4294967295].
        :param pulumi.Input[int] conn_timeout: Abnormal connection detection condition, connection timeout, value range [0,65535].
        :param pulumi.Input[int] dst_conn_limit: Concurrent connection control based on destination IP+ destination port.
        :param pulumi.Input[int] dst_new_limit: Limit on the number of news per second based on the destination IP.
        :param pulumi.Input[int] null_conn_enable: Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
        :param pulumi.Input[int] sd_conn_limit: Concurrent connection control based on source IP + destination IP.
        :param pulumi.Input[int] sd_new_limit: The limit on the number of news per second based on source IP + destination IP.
        :param pulumi.Input[int] syn_limit: Anomaly connection detection condition, syn threshold, value range [0,100].
        :param pulumi.Input[int] syn_rate: Anomalous connection detection condition, percentage of syn ack, value range [0,100].
        """
        pulumi.set(__self__, "bad_conn_threshold", bad_conn_threshold)
        pulumi.set(__self__, "conn_timeout", conn_timeout)
        pulumi.set(__self__, "dst_conn_limit", dst_conn_limit)
        pulumi.set(__self__, "dst_new_limit", dst_new_limit)
        pulumi.set(__self__, "null_conn_enable", null_conn_enable)
        pulumi.set(__self__, "sd_conn_limit", sd_conn_limit)
        pulumi.set(__self__, "sd_new_limit", sd_new_limit)
        pulumi.set(__self__, "syn_limit", syn_limit)
        pulumi.set(__self__, "syn_rate", syn_rate)

    @property
    @pulumi.getter(name="badConnThreshold")
    def bad_conn_threshold(self) -> pulumi.Input[int]:
        """
        Based on connection suppression trigger threshold, value range [0,4294967295].
        """
        return pulumi.get(self, "bad_conn_threshold")

    @bad_conn_threshold.setter
    def bad_conn_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "bad_conn_threshold", value)

    @property
    @pulumi.getter(name="connTimeout")
    def conn_timeout(self) -> pulumi.Input[int]:
        """
        Abnormal connection detection condition, connection timeout, value range [0,65535].
        """
        return pulumi.get(self, "conn_timeout")

    @conn_timeout.setter
    def conn_timeout(self, value: pulumi.Input[int]):
        pulumi.set(self, "conn_timeout", value)

    @property
    @pulumi.getter(name="dstConnLimit")
    def dst_conn_limit(self) -> pulumi.Input[int]:
        """
        Concurrent connection control based on destination IP+ destination port.
        """
        return pulumi.get(self, "dst_conn_limit")

    @dst_conn_limit.setter
    def dst_conn_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "dst_conn_limit", value)

    @property
    @pulumi.getter(name="dstNewLimit")
    def dst_new_limit(self) -> pulumi.Input[int]:
        """
        Limit on the number of news per second based on the destination IP.
        """
        return pulumi.get(self, "dst_new_limit")

    @dst_new_limit.setter
    def dst_new_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "dst_new_limit", value)

    @property
    @pulumi.getter(name="nullConnEnable")
    def null_conn_enable(self) -> pulumi.Input[int]:
        """
        Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
        """
        return pulumi.get(self, "null_conn_enable")

    @null_conn_enable.setter
    def null_conn_enable(self, value: pulumi.Input[int]):
        pulumi.set(self, "null_conn_enable", value)

    @property
    @pulumi.getter(name="sdConnLimit")
    def sd_conn_limit(self) -> pulumi.Input[int]:
        """
        Concurrent connection control based on source IP + destination IP.
        """
        return pulumi.get(self, "sd_conn_limit")

    @sd_conn_limit.setter
    def sd_conn_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "sd_conn_limit", value)

    @property
    @pulumi.getter(name="sdNewLimit")
    def sd_new_limit(self) -> pulumi.Input[int]:
        """
        The limit on the number of news per second based on source IP + destination IP.
        """
        return pulumi.get(self, "sd_new_limit")

    @sd_new_limit.setter
    def sd_new_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "sd_new_limit", value)

    @property
    @pulumi.getter(name="synLimit")
    def syn_limit(self) -> pulumi.Input[int]:
        """
        Anomaly connection detection condition, syn threshold, value range [0,100].
        """
        return pulumi.get(self, "syn_limit")

    @syn_limit.setter
    def syn_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "syn_limit", value)

    @property
    @pulumi.getter(name="synRate")
    def syn_rate(self) -> pulumi.Input[int]:
        """
        Anomalous connection detection condition, percentage of syn ack, value range [0,100].
        """
        return pulumi.get(self, "syn_rate")

    @syn_rate.setter
    def syn_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "syn_rate", value)


@pulumi.input_type
class DdosPolicyV2DdosGeoIpBlockConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 area_lists: pulumi.Input[Sequence[pulumi.Input[int]]],
                 region_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: Block action, take the value [`drop`, `trans`].
        :param pulumi.Input[Sequence[pulumi.Input[int]]] area_lists: When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
        :param pulumi.Input[str] region_type: Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "area_lists", area_lists)
        pulumi.set(__self__, "region_type", region_type)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Block action, take the value [`drop`, `trans`].
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="areaLists")
    def area_lists(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
        """
        return pulumi.get(self, "area_lists")

    @area_lists.setter
    def area_lists(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "area_lists", value)

    @property
    @pulumi.getter(name="regionType")
    def region_type(self) -> pulumi.Input[str]:
        """
        Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
        """
        return pulumi.get(self, "region_type")

    @region_type.setter
    def region_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_type", value)


@pulumi.input_type
class DdosPolicyV2DdosSpeedLimitConfigArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input[int],
                 dst_port_list: pulumi.Input[str],
                 mode: pulumi.Input[int],
                 packet_rate: pulumi.Input[int],
                 protocol_list: pulumi.Input[str]):
        """
        :param pulumi.Input[int] bandwidth: Bandwidth bps.
        :param pulumi.Input[str] dst_port_list: List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
        :param pulumi.Input[int] mode: Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
        :param pulumi.Input[int] packet_rate: Packet rate pps.
        :param pulumi.Input[str] protocol_list: IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "dst_port_list", dst_port_list)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "packet_rate", packet_rate)
        pulumi.set(__self__, "protocol_list", protocol_list)

    @property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input[int]:
        """
        Bandwidth bps.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input[int]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter(name="dstPortList")
    def dst_port_list(self) -> pulumi.Input[str]:
        """
        List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
        """
        return pulumi.get(self, "dst_port_list")

    @dst_port_list.setter
    def dst_port_list(self, value: pulumi.Input[str]):
        pulumi.set(self, "dst_port_list", value)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[int]:
        """
        Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[int]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="packetRate")
    def packet_rate(self) -> pulumi.Input[int]:
        """
        Packet rate pps.
        """
        return pulumi.get(self, "packet_rate")

    @packet_rate.setter
    def packet_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "packet_rate", value)

    @property
    @pulumi.getter(name="protocolList")
    def protocol_list(self) -> pulumi.Input[str]:
        """
        IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
        """
        return pulumi.get(self, "protocol_list")

    @protocol_list.setter
    def protocol_list(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol_list", value)


@pulumi.input_type
class DdosPolicyV2PacketFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 d_port_end: pulumi.Input[int],
                 d_port_start: pulumi.Input[int],
                 depth: pulumi.Input[int],
                 depth2: pulumi.Input[int],
                 is_not: pulumi.Input[int],
                 is_not2: pulumi.Input[int],
                 match_begin: pulumi.Input[str],
                 match_begin2: pulumi.Input[str],
                 match_logic: pulumi.Input[str],
                 match_type: pulumi.Input[str],
                 match_type2: pulumi.Input[str],
                 offset: pulumi.Input[int],
                 offset2: pulumi.Input[int],
                 pktlen_max: pulumi.Input[int],
                 pktlen_min: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 s_port_end: pulumi.Input[int],
                 s_port_start: pulumi.Input[int],
                 str: pulumi.Input[str],
                 str2: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
        :param pulumi.Input[int] d_port_end: The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
        :param pulumi.Input[int] d_port_start: From the destination port, take the value 0~65535.
        :param pulumi.Input[int] depth: Detection depth from the detection position, value [0,1500].
        :param pulumi.Input[int] depth2: Second detection depth starting from the second detection position, value [0,1500].
        :param pulumi.Input[int] is_not: Whether to include the detected value, take the value [0 (included),1 (not included)].
        :param pulumi.Input[int] is_not2: Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
        :param pulumi.Input[str] match_begin: Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        :param pulumi.Input[str] match_begin2: The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        :param pulumi.Input[str] match_logic: When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
        :param pulumi.Input[str] match_type: Detection type, value [sunday (keyword),pcre (regular expression)].
        :param pulumi.Input[str] match_type2: The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
        :param pulumi.Input[int] offset: Offset from detection position, value range [0, Depth].
        :param pulumi.Input[int] offset2: Offset from the second detection position, value range [0,Depth2].
        :param pulumi.Input[int] pktlen_max: The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
        :param pulumi.Input[int] pktlen_min: Minimum message length, 1-1500.
        :param pulumi.Input[str] protocol: Protocol, value [tcp udp icmp all].
        :param pulumi.Input[int] s_port_end: End source port, take the value 1~65535, must be greater than or equal to the starting source port.
        :param pulumi.Input[int] s_port_start: Start the source port, take the value 0~65535.
        :param pulumi.Input[str] str: Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        :param pulumi.Input[str] str2: The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "d_port_end", d_port_end)
        pulumi.set(__self__, "d_port_start", d_port_start)
        pulumi.set(__self__, "depth", depth)
        pulumi.set(__self__, "depth2", depth2)
        pulumi.set(__self__, "is_not", is_not)
        pulumi.set(__self__, "is_not2", is_not2)
        pulumi.set(__self__, "match_begin", match_begin)
        pulumi.set(__self__, "match_begin2", match_begin2)
        pulumi.set(__self__, "match_logic", match_logic)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "match_type2", match_type2)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "offset2", offset2)
        pulumi.set(__self__, "pktlen_max", pktlen_max)
        pulumi.set(__self__, "pktlen_min", pktlen_min)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "s_port_end", s_port_end)
        pulumi.set(__self__, "s_port_start", s_port_start)
        pulumi.set(__self__, "str", str)
        pulumi.set(__self__, "str2", str2)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="dPortEnd")
    def d_port_end(self) -> pulumi.Input[int]:
        """
        The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
        """
        return pulumi.get(self, "d_port_end")

    @d_port_end.setter
    def d_port_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "d_port_end", value)

    @property
    @pulumi.getter(name="dPortStart")
    def d_port_start(self) -> pulumi.Input[int]:
        """
        From the destination port, take the value 0~65535.
        """
        return pulumi.get(self, "d_port_start")

    @d_port_start.setter
    def d_port_start(self, value: pulumi.Input[int]):
        pulumi.set(self, "d_port_start", value)

    @property
    @pulumi.getter
    def depth(self) -> pulumi.Input[int]:
        """
        Detection depth from the detection position, value [0,1500].
        """
        return pulumi.get(self, "depth")

    @depth.setter
    def depth(self, value: pulumi.Input[int]):
        pulumi.set(self, "depth", value)

    @property
    @pulumi.getter
    def depth2(self) -> pulumi.Input[int]:
        """
        Second detection depth starting from the second detection position, value [0,1500].
        """
        return pulumi.get(self, "depth2")

    @depth2.setter
    def depth2(self, value: pulumi.Input[int]):
        pulumi.set(self, "depth2", value)

    @property
    @pulumi.getter(name="isNot")
    def is_not(self) -> pulumi.Input[int]:
        """
        Whether to include the detected value, take the value [0 (included),1 (not included)].
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: pulumi.Input[int]):
        pulumi.set(self, "is_not", value)

    @property
    @pulumi.getter(name="isNot2")
    def is_not2(self) -> pulumi.Input[int]:
        """
        Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
        """
        return pulumi.get(self, "is_not2")

    @is_not2.setter
    def is_not2(self, value: pulumi.Input[int]):
        pulumi.set(self, "is_not2", value)

    @property
    @pulumi.getter(name="matchBegin")
    def match_begin(self) -> pulumi.Input[str]:
        """
        Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        """
        return pulumi.get(self, "match_begin")

    @match_begin.setter
    def match_begin(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_begin", value)

    @property
    @pulumi.getter(name="matchBegin2")
    def match_begin2(self) -> pulumi.Input[str]:
        """
        The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
        """
        return pulumi.get(self, "match_begin2")

    @match_begin2.setter
    def match_begin2(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_begin2", value)

    @property
    @pulumi.getter(name="matchLogic")
    def match_logic(self) -> pulumi.Input[str]:
        """
        When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
        """
        return pulumi.get(self, "match_logic")

    @match_logic.setter
    def match_logic(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_logic", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        Detection type, value [sunday (keyword),pcre (regular expression)].
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchType2")
    def match_type2(self) -> pulumi.Input[str]:
        """
        The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
        """
        return pulumi.get(self, "match_type2")

    @match_type2.setter
    def match_type2(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type2", value)

    @property
    @pulumi.getter
    def offset(self) -> pulumi.Input[int]:
        """
        Offset from detection position, value range [0, Depth].
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: pulumi.Input[int]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter
    def offset2(self) -> pulumi.Input[int]:
        """
        Offset from the second detection position, value range [0,Depth2].
        """
        return pulumi.get(self, "offset2")

    @offset2.setter
    def offset2(self, value: pulumi.Input[int]):
        pulumi.set(self, "offset2", value)

    @property
    @pulumi.getter(name="pktlenMax")
    def pktlen_max(self) -> pulumi.Input[int]:
        """
        The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
        """
        return pulumi.get(self, "pktlen_max")

    @pktlen_max.setter
    def pktlen_max(self, value: pulumi.Input[int]):
        pulumi.set(self, "pktlen_max", value)

    @property
    @pulumi.getter(name="pktlenMin")
    def pktlen_min(self) -> pulumi.Input[int]:
        """
        Minimum message length, 1-1500.
        """
        return pulumi.get(self, "pktlen_min")

    @pktlen_min.setter
    def pktlen_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "pktlen_min", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol, value [tcp udp icmp all].
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sPortEnd")
    def s_port_end(self) -> pulumi.Input[int]:
        """
        End source port, take the value 1~65535, must be greater than or equal to the starting source port.
        """
        return pulumi.get(self, "s_port_end")

    @s_port_end.setter
    def s_port_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "s_port_end", value)

    @property
    @pulumi.getter(name="sPortStart")
    def s_port_start(self) -> pulumi.Input[int]:
        """
        Start the source port, take the value 0~65535.
        """
        return pulumi.get(self, "s_port_start")

    @s_port_start.setter
    def s_port_start(self, value: pulumi.Input[int]):
        pulumi.set(self, "s_port_start", value)

    @property
    @pulumi.getter
    def str(self) -> pulumi.Input[str]:
        """
        Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        """
        return pulumi.get(self, "str")

    @str.setter
    def str(self, value: pulumi.Input[str]):
        pulumi.set(self, "str", value)

    @property
    @pulumi.getter
    def str2(self) -> pulumi.Input[str]:
        """
        The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
        """
        return pulumi.get(self, "str2")

    @str2.setter
    def str2(self, value: pulumi.Input[str]):
        pulumi.set(self, "str2", value)


@pulumi.input_type
class DdosPolicyV2ProtocolBlockConfigArgs:
    def __init__(__self__, *,
                 drop_icmp: pulumi.Input[int],
                 drop_other: pulumi.Input[int],
                 drop_tcp: pulumi.Input[int],
                 drop_udp: pulumi.Input[int]):
        """
        :param pulumi.Input[int] drop_icmp: ICMP block, value [0 (block off), 1 (block on)].
        :param pulumi.Input[int] drop_other: Other block, value [0 (block off), 1 (block on)].
        :param pulumi.Input[int] drop_tcp: TCP block, value [0 (block off), 1 (block on)].
        :param pulumi.Input[int] drop_udp: UDP block, value [0 (block off), 1 (block on)].
        """
        pulumi.set(__self__, "drop_icmp", drop_icmp)
        pulumi.set(__self__, "drop_other", drop_other)
        pulumi.set(__self__, "drop_tcp", drop_tcp)
        pulumi.set(__self__, "drop_udp", drop_udp)

    @property
    @pulumi.getter(name="dropIcmp")
    def drop_icmp(self) -> pulumi.Input[int]:
        """
        ICMP block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_icmp")

    @drop_icmp.setter
    def drop_icmp(self, value: pulumi.Input[int]):
        pulumi.set(self, "drop_icmp", value)

    @property
    @pulumi.getter(name="dropOther")
    def drop_other(self) -> pulumi.Input[int]:
        """
        Other block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_other")

    @drop_other.setter
    def drop_other(self, value: pulumi.Input[int]):
        pulumi.set(self, "drop_other", value)

    @property
    @pulumi.getter(name="dropTcp")
    def drop_tcp(self) -> pulumi.Input[int]:
        """
        TCP block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_tcp")

    @drop_tcp.setter
    def drop_tcp(self, value: pulumi.Input[int]):
        pulumi.set(self, "drop_tcp", value)

    @property
    @pulumi.getter(name="dropUdp")
    def drop_udp(self) -> pulumi.Input[int]:
        """
        UDP block, value [0 (block off), 1 (block on)].
        """
        return pulumi.get(self, "drop_udp")

    @drop_udp.setter
    def drop_udp(self, value: pulumi.Input[int]):
        pulumi.set(self, "drop_udp", value)


@pulumi.input_type
class DdosPolicyV2WaterPrintConfigArgs:
    def __init__(__self__, *,
                 listeners: pulumi.Input[Sequence[pulumi.Input['DdosPolicyV2WaterPrintConfigListenerArgs']]],
                 offset: pulumi.Input[int],
                 open_status: pulumi.Input[int],
                 verify: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DdosPolicyV2WaterPrintConfigListenerArgs']]] listeners: List of forwarding listeners to which the watermark belongs.
        :param pulumi.Input[int] offset: Watermark offset, value range: [0-100].
        :param pulumi.Input[int] open_status: Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
        :param pulumi.Input[str] verify: Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
        """
        pulumi.set(__self__, "listeners", listeners)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "open_status", open_status)
        pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def listeners(self) -> pulumi.Input[Sequence[pulumi.Input['DdosPolicyV2WaterPrintConfigListenerArgs']]]:
        """
        List of forwarding listeners to which the watermark belongs.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: pulumi.Input[Sequence[pulumi.Input['DdosPolicyV2WaterPrintConfigListenerArgs']]]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter
    def offset(self) -> pulumi.Input[int]:
        """
        Watermark offset, value range: [0-100].
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: pulumi.Input[int]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="openStatus")
    def open_status(self) -> pulumi.Input[int]:
        """
        Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
        """
        return pulumi.get(self, "open_status")

    @open_status.setter
    def open_status(self, value: pulumi.Input[int]):
        pulumi.set(self, "open_status", value)

    @property
    @pulumi.getter
    def verify(self) -> pulumi.Input[str]:
        """
        Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: pulumi.Input[str]):
        pulumi.set(self, "verify", value)


@pulumi.input_type
class DdosPolicyV2WaterPrintConfigListenerArgs:
    def __init__(__self__, *,
                 forward_protocol: pulumi.Input[str],
                 frontend_port: pulumi.Input[int],
                 frontend_port_end: pulumi.Input[int]):
        """
        :param pulumi.Input[str] forward_protocol: Forwarding protocol, value [TCP, UDP].
        :param pulumi.Input[int] frontend_port: Lower limit of forwarding listening port. Values: [1-65535].
        :param pulumi.Input[int] frontend_port_end: Upper limit of forwarding listening port. Values: [1-65535].
        """
        pulumi.set(__self__, "forward_protocol", forward_protocol)
        pulumi.set(__self__, "frontend_port", frontend_port)
        pulumi.set(__self__, "frontend_port_end", frontend_port_end)

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> pulumi.Input[str]:
        """
        Forwarding protocol, value [TCP, UDP].
        """
        return pulumi.get(self, "forward_protocol")

    @forward_protocol.setter
    def forward_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "forward_protocol", value)

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> pulumi.Input[int]:
        """
        Lower limit of forwarding listening port. Values: [1-65535].
        """
        return pulumi.get(self, "frontend_port")

    @frontend_port.setter
    def frontend_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "frontend_port", value)

    @property
    @pulumi.getter(name="frontendPortEnd")
    def frontend_port_end(self) -> pulumi.Input[int]:
        """
        Upper limit of forwarding listening port. Values: [1-65535].
        """
        return pulumi.get(self, "frontend_port_end")

    @frontend_port_end.setter
    def frontend_port_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "frontend_port_end", value)


@pulumi.input_type
class DdosPolicyWatermarkFilterArgs:
    def __init__(__self__, *,
                 auto_remove: Optional[pulumi.Input[bool]] = None,
                 offset: Optional[pulumi.Input[int]] = None,
                 open_switch: Optional[pulumi.Input[bool]] = None,
                 tcp_port_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 udp_port_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] auto_remove: Indicate whether to auto-remove the watermark or not.
        :param pulumi.Input[int] offset: The offset of watermark. Valid value ranges: (0~1500).
        :param pulumi.Input[bool] open_switch: Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tcp_port_lists: Port range of TCP, the format is like `2000-3000`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] udp_port_lists: Port range of TCP, the format is like `2000-3000`.
        """
        if auto_remove is not None:
            pulumi.set(__self__, "auto_remove", auto_remove)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if open_switch is not None:
            pulumi.set(__self__, "open_switch", open_switch)
        if tcp_port_lists is not None:
            pulumi.set(__self__, "tcp_port_lists", tcp_port_lists)
        if udp_port_lists is not None:
            pulumi.set(__self__, "udp_port_lists", udp_port_lists)

    @property
    @pulumi.getter(name="autoRemove")
    def auto_remove(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate whether to auto-remove the watermark or not.
        """
        return pulumi.get(self, "auto_remove")

    @auto_remove.setter
    def auto_remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_remove", value)

    @property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[int]]:
        """
        The offset of watermark. Valid value ranges: (0~1500).
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="openSwitch")
    def open_switch(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        """
        return pulumi.get(self, "open_switch")

    @open_switch.setter
    def open_switch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "open_switch", value)

    @property
    @pulumi.getter(name="tcpPortLists")
    def tcp_port_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Port range of TCP, the format is like `2000-3000`.
        """
        return pulumi.get(self, "tcp_port_lists")

    @tcp_port_lists.setter
    def tcp_port_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tcp_port_lists", value)

    @property
    @pulumi.getter(name="udpPortLists")
    def udp_port_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Port range of TCP, the format is like `2000-3000`.
        """
        return pulumi.get(self, "udp_port_lists")

    @udp_port_lists.setter
    def udp_port_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "udp_port_lists", value)


@pulumi.input_type
class DdosPolicyWatermarkKeyArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 create_time: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 open_switch: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] content: Content of the watermark.
        :param pulumi.Input[str] create_time: Create time of the DDoS policy.
        :param pulumi.Input[str] id: Id of the watermark.
        :param pulumi.Input[bool] open_switch: Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if open_switch is not None:
            pulumi.set(__self__, "open_switch", open_switch)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Content of the watermark.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        Create time of the DDoS policy.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the watermark.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="openSwitch")
    def open_switch(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate whether to open watermark or not. It muse be set `true` when any field of watermark was set.
        """
        return pulumi.get(self, "open_switch")

    @open_switch.setter
    def open_switch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "open_switch", value)


@pulumi.input_type
class L4RuleSourceListArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] source: Source IP or domain, valid format of ip is like `1.1.1.1` and valid format of host source is like `abc.com`.
        :param pulumi.Input[int] weight: Weight of the source, the valid value ranges from 0 to 100.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Source IP or domain, valid format of ip is like `1.1.1.1` and valid format of host source is like `abc.com`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Weight of the source, the valid value ranges from 0 to 100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class L4RuleV2RulesArgs:
    def __init__(__self__, *,
                 keep_enable: pulumi.Input[bool],
                 keeptime: pulumi.Input[int],
                 lb_type: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 region: pulumi.Input[int],
                 remove_switch: pulumi.Input[bool],
                 rule_name: pulumi.Input[str],
                 source_lists: pulumi.Input[Sequence[pulumi.Input['L4RuleV2RulesSourceListArgs']]],
                 source_port: pulumi.Input[int],
                 source_type: pulumi.Input[int],
                 virtual_port: pulumi.Input[int]):
        """
        :param pulumi.Input[bool] keep_enable: session hold switch.
        :param pulumi.Input[int] keeptime: The keeptime of the layer 4 rule.
        :param pulumi.Input[int] lb_type: LB type of the rule, `1` for weight cycling and `2` for IP hash.
        :param pulumi.Input[str] protocol: Protocol of the rule.
        :param pulumi.Input[int] region: Corresponding regional information.
        :param pulumi.Input[bool] remove_switch: Remove the watermark state.
        :param pulumi.Input[str] rule_name: Name of the rule.
        :param pulumi.Input[Sequence[pulumi.Input['L4RuleV2RulesSourceListArgs']]] source_lists: Source list of the rule.
        :param pulumi.Input[int] source_port: The source port of the layer 4 rule.
        :param pulumi.Input[int] source_type: Source type, `1` for source of host, `2` for source of IP.
        :param pulumi.Input[int] virtual_port: The virtual port of the layer 4 rule.
        """
        pulumi.set(__self__, "keep_enable", keep_enable)
        pulumi.set(__self__, "keeptime", keeptime)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "remove_switch", remove_switch)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_port", source_port)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "virtual_port", virtual_port)

    @property
    @pulumi.getter(name="keepEnable")
    def keep_enable(self) -> pulumi.Input[bool]:
        """
        session hold switch.
        """
        return pulumi.get(self, "keep_enable")

    @keep_enable.setter
    def keep_enable(self, value: pulumi.Input[bool]):
        pulumi.set(self, "keep_enable", value)

    @property
    @pulumi.getter
    def keeptime(self) -> pulumi.Input[int]:
        """
        The keeptime of the layer 4 rule.
        """
        return pulumi.get(self, "keeptime")

    @keeptime.setter
    def keeptime(self, value: pulumi.Input[int]):
        pulumi.set(self, "keeptime", value)

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> pulumi.Input[int]:
        """
        LB type of the rule, `1` for weight cycling and `2` for IP hash.
        """
        return pulumi.get(self, "lb_type")

    @lb_type.setter
    def lb_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "lb_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[int]:
        """
        Corresponding regional information.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[int]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="removeSwitch")
    def remove_switch(self) -> pulumi.Input[bool]:
        """
        Remove the watermark state.
        """
        return pulumi.get(self, "remove_switch")

    @remove_switch.setter
    def remove_switch(self, value: pulumi.Input[bool]):
        pulumi.set(self, "remove_switch", value)

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[str]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_name", value)

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> pulumi.Input[Sequence[pulumi.Input['L4RuleV2RulesSourceListArgs']]]:
        """
        Source list of the rule.
        """
        return pulumi.get(self, "source_lists")

    @source_lists.setter
    def source_lists(self, value: pulumi.Input[Sequence[pulumi.Input['L4RuleV2RulesSourceListArgs']]]):
        pulumi.set(self, "source_lists", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[int]:
        """
        The source port of the layer 4 rule.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "source_port", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[int]:
        """
        Source type, `1` for source of host, `2` for source of IP.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> pulumi.Input[int]:
        """
        The virtual port of the layer 4 rule.
        """
        return pulumi.get(self, "virtual_port")

    @virtual_port.setter
    def virtual_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "virtual_port", value)


@pulumi.input_type
class L4RuleV2RulesSourceListArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] source: Source IP or domain.
        :param pulumi.Input[int] weight: Weight of the source.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Source IP or domain.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Weight of the source.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class L7RuleV2RuleArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 keep_enable: pulumi.Input[int],
                 keeptime: pulumi.Input[int],
                 lb_type: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 source_lists: pulumi.Input[Sequence[pulumi.Input['L7RuleV2RuleSourceListArgs']]],
                 source_type: pulumi.Input[int],
                 cc_enable: Optional[pulumi.Input[int]] = None,
                 cert_type: Optional[pulumi.Input[int]] = None,
                 https_to_http_enable: Optional[pulumi.Input[int]] = None,
                 ssl_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Domain of the rule.
        :param pulumi.Input[int] keep_enable: session hold switch.
        :param pulumi.Input[int] keeptime: The keeptime of the layer 4 rule.
        :param pulumi.Input[int] lb_type: LB type of the rule, `1` for weight cycling and `2` for IP hash.
        :param pulumi.Input[str] protocol: Protocol of the rule.
        :param pulumi.Input[int] source_type: Source type, `1` for source of host, `2` for source of IP.
        :param pulumi.Input[int] cc_enable: HTTPS protocol CC protection status, value [0 (off), 1 (on)], defaule is 0.
        :param pulumi.Input[int] cert_type: The source of the certificate must be filled in when the forwarding protocol is https, the value [2 (Tencent Cloud Hosting Certificate)], and 0 when the forwarding protocol is http.
        :param pulumi.Input[int] https_to_http_enable: Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], do not fill in the default is off, defaule is 0.
        :param pulumi.Input[str] ssl_id: When the certificate source is a Tencent Cloud managed certificate, this field must be filled in with the managed certificate ID.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "keep_enable", keep_enable)
        pulumi.set(__self__, "keeptime", keeptime)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_lists", source_lists)
        pulumi.set(__self__, "source_type", source_type)
        if cc_enable is not None:
            pulumi.set(__self__, "cc_enable", cc_enable)
        if cert_type is not None:
            pulumi.set(__self__, "cert_type", cert_type)
        if https_to_http_enable is not None:
            pulumi.set(__self__, "https_to_http_enable", https_to_http_enable)
        if ssl_id is not None:
            pulumi.set(__self__, "ssl_id", ssl_id)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Domain of the rule.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="keepEnable")
    def keep_enable(self) -> pulumi.Input[int]:
        """
        session hold switch.
        """
        return pulumi.get(self, "keep_enable")

    @keep_enable.setter
    def keep_enable(self, value: pulumi.Input[int]):
        pulumi.set(self, "keep_enable", value)

    @property
    @pulumi.getter
    def keeptime(self) -> pulumi.Input[int]:
        """
        The keeptime of the layer 4 rule.
        """
        return pulumi.get(self, "keeptime")

    @keeptime.setter
    def keeptime(self, value: pulumi.Input[int]):
        pulumi.set(self, "keeptime", value)

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> pulumi.Input[int]:
        """
        LB type of the rule, `1` for weight cycling and `2` for IP hash.
        """
        return pulumi.get(self, "lb_type")

    @lb_type.setter
    def lb_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "lb_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Protocol of the rule.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sourceLists")
    def source_lists(self) -> pulumi.Input[Sequence[pulumi.Input['L7RuleV2RuleSourceListArgs']]]:
        return pulumi.get(self, "source_lists")

    @source_lists.setter
    def source_lists(self, value: pulumi.Input[Sequence[pulumi.Input['L7RuleV2RuleSourceListArgs']]]):
        pulumi.set(self, "source_lists", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[int]:
        """
        Source type, `1` for source of host, `2` for source of IP.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="ccEnable")
    def cc_enable(self) -> Optional[pulumi.Input[int]]:
        """
        HTTPS protocol CC protection status, value [0 (off), 1 (on)], defaule is 0.
        """
        return pulumi.get(self, "cc_enable")

    @cc_enable.setter
    def cc_enable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cc_enable", value)

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> Optional[pulumi.Input[int]]:
        """
        The source of the certificate must be filled in when the forwarding protocol is https, the value [2 (Tencent Cloud Hosting Certificate)], and 0 when the forwarding protocol is http.
        """
        return pulumi.get(self, "cert_type")

    @cert_type.setter
    def cert_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cert_type", value)

    @property
    @pulumi.getter(name="httpsToHttpEnable")
    def https_to_http_enable(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to enable the Https protocol to use Http back-to-source, take the value [0 (off), 1 (on)], do not fill in the default is off, defaule is 0.
        """
        return pulumi.get(self, "https_to_http_enable")

    @https_to_http_enable.setter
    def https_to_http_enable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_to_http_enable", value)

    @property
    @pulumi.getter(name="sslId")
    def ssl_id(self) -> Optional[pulumi.Input[str]]:
        """
        When the certificate source is a Tencent Cloud managed certificate, this field must be filled in with the managed certificate ID.
        """
        return pulumi.get(self, "ssl_id")

    @ssl_id.setter
    def ssl_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl_id", value)


@pulumi.input_type
class L7RuleV2RuleSourceListArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] source: Source IP or domain.
        :param pulumi.Input[int] weight: Weight of the source.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Source IP or domain.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Weight of the source.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


