# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['RouteArgs', 'Route']

@pulumi.input_type
class RouteArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[str],
                 vip_type: pulumi.Input[int],
                 access_type: Optional[pulumi.Input[int]] = None,
                 auth_flag: Optional[pulumi.Input[int]] = None,
                 caller_appid: Optional[pulumi.Input[int]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 public_network: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a Route resource.
        :param pulumi.Input[str] instance_id: Instance id.
        :param pulumi.Input[int] vip_type: Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        :param pulumi.Input[int] access_type: Access type. Valid values:
               - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
               - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
               - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
               - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        :param pulumi.Input[int] auth_flag: Auth flag.
        :param pulumi.Input[int] caller_appid: Caller appid.
        :param pulumi.Input[str] ip: Ip.
        :param pulumi.Input[int] public_network: Public network.
        :param pulumi.Input[str] subnet_id: Subnet id.
        :param pulumi.Input[str] vpc_id: Vpc id.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "vip_type", vip_type)
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if auth_flag is not None:
            pulumi.set(__self__, "auth_flag", auth_flag)
        if caller_appid is not None:
            pulumi.set(__self__, "caller_appid", caller_appid)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if public_network is not None:
            pulumi.set(__self__, "public_network", public_network)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[str]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="vipType")
    def vip_type(self) -> pulumi.Input[int]:
        """
        Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        """
        return pulumi.get(self, "vip_type")

    @vip_type.setter
    def vip_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "vip_type", value)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[int]]:
        """
        Access type. Valid values:
        - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
        - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
        - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
        - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "access_type", value)

    @property
    @pulumi.getter(name="authFlag")
    def auth_flag(self) -> Optional[pulumi.Input[int]]:
        """
        Auth flag.
        """
        return pulumi.get(self, "auth_flag")

    @auth_flag.setter
    def auth_flag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_flag", value)

    @property
    @pulumi.getter(name="callerAppid")
    def caller_appid(self) -> Optional[pulumi.Input[int]]:
        """
        Caller appid.
        """
        return pulumi.get(self, "caller_appid")

    @caller_appid.setter
    def caller_appid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "caller_appid", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Ip.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[pulumi.Input[int]]:
        """
        Public network.
        """
        return pulumi.get(self, "public_network")

    @public_network.setter
    def public_network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "public_network", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


@pulumi.input_type
class _RouteState:
    def __init__(__self__, *,
                 access_type: Optional[pulumi.Input[int]] = None,
                 auth_flag: Optional[pulumi.Input[int]] = None,
                 broker_vip_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RouteBrokerVipListArgs']]]] = None,
                 caller_appid: Optional[pulumi.Input[int]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 public_network: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vip_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RouteVipListArgs']]]] = None,
                 vip_type: Optional[pulumi.Input[int]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering Route resources.
        :param pulumi.Input[int] access_type: Access type. Valid values:
               - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
               - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
               - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
               - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        :param pulumi.Input[int] auth_flag: Auth flag.
        :param pulumi.Input[Sequence[pulumi.Input['RouteBrokerVipListArgs']]] broker_vip_lists: Virtual IP list (1 to 1 broker nodes).
        :param pulumi.Input[int] caller_appid: Caller appid.
        :param pulumi.Input[str] instance_id: Instance id.
        :param pulumi.Input[str] ip: Ip.
        :param pulumi.Input[int] public_network: Public network.
        :param pulumi.Input[str] subnet_id: Subnet id.
        :param pulumi.Input[Sequence[pulumi.Input['RouteVipListArgs']]] vip_lists: Virtual IP list.
        :param pulumi.Input[int] vip_type: Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        :param pulumi.Input[str] vpc_id: Vpc id.
        """
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if auth_flag is not None:
            pulumi.set(__self__, "auth_flag", auth_flag)
        if broker_vip_lists is not None:
            pulumi.set(__self__, "broker_vip_lists", broker_vip_lists)
        if caller_appid is not None:
            pulumi.set(__self__, "caller_appid", caller_appid)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if public_network is not None:
            pulumi.set(__self__, "public_network", public_network)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vip_lists is not None:
            pulumi.set(__self__, "vip_lists", vip_lists)
        if vip_type is not None:
            pulumi.set(__self__, "vip_type", vip_type)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[int]]:
        """
        Access type. Valid values:
        - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
        - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
        - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
        - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "access_type", value)

    @property
    @pulumi.getter(name="authFlag")
    def auth_flag(self) -> Optional[pulumi.Input[int]]:
        """
        Auth flag.
        """
        return pulumi.get(self, "auth_flag")

    @auth_flag.setter
    def auth_flag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_flag", value)

    @property
    @pulumi.getter(name="brokerVipLists")
    def broker_vip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteBrokerVipListArgs']]]]:
        """
        Virtual IP list (1 to 1 broker nodes).
        """
        return pulumi.get(self, "broker_vip_lists")

    @broker_vip_lists.setter
    def broker_vip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteBrokerVipListArgs']]]]):
        pulumi.set(self, "broker_vip_lists", value)

    @property
    @pulumi.getter(name="callerAppid")
    def caller_appid(self) -> Optional[pulumi.Input[int]]:
        """
        Caller appid.
        """
        return pulumi.get(self, "caller_appid")

    @caller_appid.setter
    def caller_appid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "caller_appid", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Ip.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[pulumi.Input[int]]:
        """
        Public network.
        """
        return pulumi.get(self, "public_network")

    @public_network.setter
    def public_network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "public_network", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vipLists")
    def vip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteVipListArgs']]]]:
        """
        Virtual IP list.
        """
        return pulumi.get(self, "vip_lists")

    @vip_lists.setter
    def vip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteVipListArgs']]]]):
        pulumi.set(self, "vip_lists", value)

    @property
    @pulumi.getter(name="vipType")
    def vip_type(self) -> Optional[pulumi.Input[int]]:
        """
        Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        """
        return pulumi.get(self, "vip_type")

    @vip_type.setter
    def vip_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vip_type", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


class Route(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 access_type: Optional[pulumi.Input[int]] = None,
                 auth_flag: Optional[pulumi.Input[int]] = None,
                 caller_appid: Optional[pulumi.Input[int]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 public_network: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vip_type: Optional[pulumi.Input[int]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Provides a resource to create a ckafka route

        ## Example Usage

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        import tencentcloud_iac_pulumi as tencentcloud

        example = tencentcloud.ckafka.Route("example",
            access_type=0,
            instance_id="ckafka-8j4rodrr",
            public_network=3,
            subnet_id="subnet-j5vja918",
            vip_type=3,
            vpc_id="vpc-axrsmmrv")
        ```
        <!--End PulumiCodeChooser -->

        ## Import

        ckafka route can be imported using the id, e.g.

        ```sh
        $ pulumi import tencentcloud:Ckafka/route:Route example ckafka-8j4rodrr#135912
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] access_type: Access type. Valid values:
               - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
               - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
               - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
               - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        :param pulumi.Input[int] auth_flag: Auth flag.
        :param pulumi.Input[int] caller_appid: Caller appid.
        :param pulumi.Input[str] instance_id: Instance id.
        :param pulumi.Input[str] ip: Ip.
        :param pulumi.Input[int] public_network: Public network.
        :param pulumi.Input[str] subnet_id: Subnet id.
        :param pulumi.Input[int] vip_type: Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        :param pulumi.Input[str] vpc_id: Vpc id.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: RouteArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Provides a resource to create a ckafka route

        ## Example Usage

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        import tencentcloud_iac_pulumi as tencentcloud

        example = tencentcloud.ckafka.Route("example",
            access_type=0,
            instance_id="ckafka-8j4rodrr",
            public_network=3,
            subnet_id="subnet-j5vja918",
            vip_type=3,
            vpc_id="vpc-axrsmmrv")
        ```
        <!--End PulumiCodeChooser -->

        ## Import

        ckafka route can be imported using the id, e.g.

        ```sh
        $ pulumi import tencentcloud:Ckafka/route:Route example ckafka-8j4rodrr#135912
        ```

        :param str resource_name: The name of the resource.
        :param RouteArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(RouteArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 access_type: Optional[pulumi.Input[int]] = None,
                 auth_flag: Optional[pulumi.Input[int]] = None,
                 caller_appid: Optional[pulumi.Input[int]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 public_network: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vip_type: Optional[pulumi.Input[int]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = RouteArgs.__new__(RouteArgs)

            __props__.__dict__["access_type"] = access_type
            __props__.__dict__["auth_flag"] = auth_flag
            __props__.__dict__["caller_appid"] = caller_appid
            if instance_id is None and not opts.urn:
                raise TypeError("Missing required property 'instance_id'")
            __props__.__dict__["instance_id"] = instance_id
            __props__.__dict__["ip"] = ip
            __props__.__dict__["public_network"] = public_network
            __props__.__dict__["subnet_id"] = subnet_id
            if vip_type is None and not opts.urn:
                raise TypeError("Missing required property 'vip_type'")
            __props__.__dict__["vip_type"] = vip_type
            __props__.__dict__["vpc_id"] = vpc_id
            __props__.__dict__["broker_vip_lists"] = None
            __props__.__dict__["vip_lists"] = None
        super(Route, __self__).__init__(
            'tencentcloud:Ckafka/route:Route',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            access_type: Optional[pulumi.Input[int]] = None,
            auth_flag: Optional[pulumi.Input[int]] = None,
            broker_vip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['RouteBrokerVipListArgs']]]]] = None,
            caller_appid: Optional[pulumi.Input[int]] = None,
            instance_id: Optional[pulumi.Input[str]] = None,
            ip: Optional[pulumi.Input[str]] = None,
            public_network: Optional[pulumi.Input[int]] = None,
            subnet_id: Optional[pulumi.Input[str]] = None,
            vip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['RouteVipListArgs']]]]] = None,
            vip_type: Optional[pulumi.Input[int]] = None,
            vpc_id: Optional[pulumi.Input[str]] = None) -> 'Route':
        """
        Get an existing Route resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] access_type: Access type. Valid values:
               - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
               - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
               - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
               - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        :param pulumi.Input[int] auth_flag: Auth flag.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['RouteBrokerVipListArgs']]]] broker_vip_lists: Virtual IP list (1 to 1 broker nodes).
        :param pulumi.Input[int] caller_appid: Caller appid.
        :param pulumi.Input[str] instance_id: Instance id.
        :param pulumi.Input[str] ip: Ip.
        :param pulumi.Input[int] public_network: Public network.
        :param pulumi.Input[str] subnet_id: Subnet id.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['RouteVipListArgs']]]] vip_lists: Virtual IP list.
        :param pulumi.Input[int] vip_type: Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        :param pulumi.Input[str] vpc_id: Vpc id.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _RouteState.__new__(_RouteState)

        __props__.__dict__["access_type"] = access_type
        __props__.__dict__["auth_flag"] = auth_flag
        __props__.__dict__["broker_vip_lists"] = broker_vip_lists
        __props__.__dict__["caller_appid"] = caller_appid
        __props__.__dict__["instance_id"] = instance_id
        __props__.__dict__["ip"] = ip
        __props__.__dict__["public_network"] = public_network
        __props__.__dict__["subnet_id"] = subnet_id
        __props__.__dict__["vip_lists"] = vip_lists
        __props__.__dict__["vip_type"] = vip_type
        __props__.__dict__["vpc_id"] = vpc_id
        return Route(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> pulumi.Output[int]:
        """
        Access type. Valid values:
        - 0: PLAINTEXT (in clear text, supported by both the old version and the community version without user information)
        - 1: SASL_PLAINTEXT (in clear text, but at the beginning of the data, authentication will be logged in through SASL, which is only supported by the community version)
        - 2: SSL (SSL encrypted communication without user information, supported by both older and community versions)
        - 3: SASL_SSL (SSL encrypted communication. When the data starts, authentication will be logged in through SASL. Only the community version supports it).
        """
        return pulumi.get(self, "access_type")

    @property
    @pulumi.getter(name="authFlag")
    def auth_flag(self) -> pulumi.Output[Optional[int]]:
        """
        Auth flag.
        """
        return pulumi.get(self, "auth_flag")

    @property
    @pulumi.getter(name="brokerVipLists")
    def broker_vip_lists(self) -> pulumi.Output[Sequence['outputs.RouteBrokerVipList']]:
        """
        Virtual IP list (1 to 1 broker nodes).
        """
        return pulumi.get(self, "broker_vip_lists")

    @property
    @pulumi.getter(name="callerAppid")
    def caller_appid(self) -> pulumi.Output[Optional[int]]:
        """
        Caller appid.
        """
        return pulumi.get(self, "caller_appid")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Output[str]:
        """
        Instance id.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Output[str]:
        """
        Ip.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> pulumi.Output[Optional[int]]:
        """
        Public network.
        """
        return pulumi.get(self, "public_network")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Output[str]:
        """
        Subnet id.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="vipLists")
    def vip_lists(self) -> pulumi.Output[Sequence['outputs.RouteVipList']]:
        """
        Virtual IP list.
        """
        return pulumi.get(self, "vip_lists")

    @property
    @pulumi.getter(name="vipType")
    def vip_type(self) -> pulumi.Output[int]:
        """
        Routing network type (3:vpc routing; 4: standard support routing; 7: professional support routing).
        """
        return pulumi.get(self, "vip_type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Output[str]:
        """
        Vpc id.
        """
        return pulumi.get(self, "vpc_id")

