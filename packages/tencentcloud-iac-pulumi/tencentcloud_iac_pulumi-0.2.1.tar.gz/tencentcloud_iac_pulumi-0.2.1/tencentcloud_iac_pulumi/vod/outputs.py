# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AdaptiveDynamicStreamingTemplateStreamInfo',
    'AdaptiveDynamicStreamingTemplateStreamInfoAudio',
    'AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig',
    'AdaptiveDynamicStreamingTemplateStreamInfoVideo',
    'ProcedureTemplateAiAnalysisTask',
    'ProcedureTemplateAiRecognitionTask',
    'ProcedureTemplateMediaProcessTask',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskImageSpriteTaskList',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermark',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermark',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList',
    'ProcedureTemplateReviewAudioVideoTask',
    'SuperPlayerConfigDrmStreamingInfo',
    'SuperPlayerConfigResolutionName',
    'TranscodeTemplateAudioTemplate',
    'TranscodeTemplateTehdConfig',
    'TranscodeTemplateVideoTemplate',
    'WatermarkTemplateImageTemplate',
    'WatermarkTemplateSvgTemplate',
    'WatermarkTemplateTextTemplate',
    'GetAdaptiveDynamicStreamingTemplatesTemplateListResult',
    'GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult',
    'GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult',
    'GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult',
    'GetImageSpriteTemplatesTemplateListResult',
    'GetProcedureTemplatesTemplateListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult',
    'GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult',
    'GetSnapshotByTimeOffsetTemplatesTemplateListResult',
    'GetSuperPlayerConfigsConfigListResult',
    'GetSuperPlayerConfigsConfigListDrmStreamingInfoResult',
    'GetSuperPlayerConfigsConfigListResolutionNameResult',
]

@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeAudio":
            suggest = "remove_audio"
        elif key == "removeVideo":
            suggest = "remove_video"
        elif key == "tehdConfig":
            suggest = "tehd_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio: 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoAudio',
                 video: 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoVideo',
                 remove_audio: Optional[bool] = None,
                 remove_video: Optional[bool] = None,
                 tehd_config: Optional['outputs.AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig'] = None):
        """
        :param 'AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs' audio: Audio parameter information.
        :param 'AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs' video: Video parameter information.
        :param bool remove_audio: Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
        :param bool remove_video: Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
        :param 'AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs' tehd_config: Extremely fast HD transcoding parameters.
        """
        pulumi.set(__self__, "audio", audio)
        pulumi.set(__self__, "video", video)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)
        if tehd_config is not None:
            pulumi.set(__self__, "tehd_config", tehd_config)

    @property
    @pulumi.getter
    def audio(self) -> 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoAudio':
        """
        Audio parameter information.
        """
        return pulumi.get(self, "audio")

    @property
    @pulumi.getter
    def video(self) -> 'outputs.AdaptiveDynamicStreamingTemplateStreamInfoVideo':
        """
        Video parameter information.
        """
        return pulumi.get(self, "video")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[bool]:
        """
        Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
        """
        return pulumi.get(self, "remove_audio")

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[bool]:
        """
        Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
        """
        return pulumi.get(self, "remove_video")

    @property
    @pulumi.getter(name="tehdConfig")
    def tehd_config(self) -> Optional['outputs.AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig']:
        """
        Extremely fast HD transcoding parameters.
        """
        return pulumi.get(self, "tehd_config")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "audioChannel":
            suggest = "audio_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 sample_rate: int,
                 audio_channel: Optional[str] = None):
        """
        :param int bitrate: Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
        :param str codec: Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
        :param int sample_rate: Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
        :param str audio_channel: Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        """
        Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[str]:
        """
        Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
        """
        return pulumi.get(self, "audio_channel")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVideoBitrate":
            suggest = "max_video_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoTehdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 max_video_bitrate: Optional[int] = None):
        """
        :param str type: Extreme high-speed HD type, available values:
               - TEHD-100: super high definition-100th;
               - OFF: turn off Ultra High definition.
        :param int max_video_bitrate: Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Extreme high-speed HD type, available values:
        - TEHD-100: super high definition-100th;
        - OFF: turn off Ultra High definition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[int]:
        """
        Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
        """
        return pulumi.get(self, "max_video_bitrate")


@pulumi.output_type
class AdaptiveDynamicStreamingTemplateStreamInfoVideo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codecTag":
            suggest = "codec_tag"
        elif key == "fillType":
            suggest = "fill_type"
        elif key == "preserveHdrSwitch":
            suggest = "preserve_hdr_switch"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdaptiveDynamicStreamingTemplateStreamInfoVideo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoVideo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdaptiveDynamicStreamingTemplateStreamInfoVideo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fps: int,
                 codec_tag: Optional[str] = None,
                 fill_type: Optional[str] = None,
                 gop: Optional[int] = None,
                 height: Optional[int] = None,
                 preserve_hdr_switch: Optional[str] = None,
                 resolution_adaptive: Optional[bool] = None,
                 vcrf: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int bitrate: Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        :param str codec: Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        :param int fps: Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        :param str codec_tag: Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
               - hvc1: stands for hvc1 tag;
               - hev1: stands for the hev1 tag;
               Default value: hvc1.
        :param str fill_type: Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
        :param int gop: Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
        :param int height: Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str preserve_hdr_switch: Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
               - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
               - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
               Default value: OFF.
        :param bool resolution_adaptive: Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
        :param int vcrf: Video constant bit rate control factor, value range is [1,51].
               Note:
               - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
               - This field is required when the video stream encoding format is H.266. The recommended value is 28;
               - If there are no special requirements, it is not recommended to specify this parameter.
        :param int width: Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if codec_tag is not None:
            pulumi.set(__self__, "codec_tag", codec_tag)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if preserve_hdr_switch is not None:
            pulumi.set(__self__, "preserve_hdr_switch", preserve_hdr_switch)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> int:
        """
        Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter(name="codecTag")
    def codec_tag(self) -> Optional[str]:
        """
        Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
        - hvc1: stands for hvc1 tag;
        - hev1: stands for the hev1 tag;
        Default value: hvc1.
        """
        return pulumi.get(self, "codec_tag")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        """
        Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def gop(self) -> Optional[int]:
        """
        Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="preserveHdrSwitch")
    def preserve_hdr_switch(self) -> Optional[str]:
        """
        Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
        - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
        - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
        Default value: OFF.
        """
        return pulumi.get(self, "preserve_hdr_switch")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[bool]:
        """
        Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[int]:
        """
        Video constant bit rate control factor, value range is [1,51].
        Note:
        - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
        - This field is required when the video stream encoding format is H.266. The recommended value is 28;
        - If there are no special requirements, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class ProcedureTemplateAiAnalysisTask(dict):
    def __init__(__self__, *,
                 definition: Optional[str] = None):
        """
        :param str definition: Video content analysis template ID.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[str]:
        """
        Video content analysis template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class ProcedureTemplateAiRecognitionTask(dict):
    def __init__(__self__, *,
                 definition: Optional[str] = None):
        """
        :param str definition: Intelligent video recognition template ID.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[str]:
        """
        Intelligent video recognition template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class ProcedureTemplateMediaProcessTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveDynamicStreamingTaskLists":
            suggest = "adaptive_dynamic_streaming_task_lists"
        elif key == "animatedGraphicTaskLists":
            suggest = "animated_graphic_task_lists"
        elif key == "coverBySnapshotTaskLists":
            suggest = "cover_by_snapshot_task_lists"
        elif key == "imageSpriteTaskLists":
            suggest = "image_sprite_task_lists"
        elif key == "sampleSnapshotTaskLists":
            suggest = "sample_snapshot_task_lists"
        elif key == "snapshotByTimeOffsetTaskLists":
            suggest = "snapshot_by_time_offset_task_lists"
        elif key == "transcodeTaskLists":
            suggest = "transcode_task_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList']] = None,
                 animated_graphic_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList']] = None,
                 cover_by_snapshot_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList']] = None,
                 image_sprite_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskImageSpriteTaskList']] = None,
                 sample_snapshot_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList']] = None,
                 snapshot_by_time_offset_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList']] = None,
                 transcode_task_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskList']] = None):
        """
        :param Sequence['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs'] adaptive_dynamic_streaming_task_lists: List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs'] animated_graphic_task_lists: List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs'] cover_by_snapshot_task_lists: List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs'] image_sprite_task_lists: List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs'] sample_snapshot_task_lists: List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs'] snapshot_by_time_offset_task_lists: List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs'] transcode_task_lists: List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        if adaptive_dynamic_streaming_task_lists is not None:
            pulumi.set(__self__, "adaptive_dynamic_streaming_task_lists", adaptive_dynamic_streaming_task_lists)
        if animated_graphic_task_lists is not None:
            pulumi.set(__self__, "animated_graphic_task_lists", animated_graphic_task_lists)
        if cover_by_snapshot_task_lists is not None:
            pulumi.set(__self__, "cover_by_snapshot_task_lists", cover_by_snapshot_task_lists)
        if image_sprite_task_lists is not None:
            pulumi.set(__self__, "image_sprite_task_lists", image_sprite_task_lists)
        if sample_snapshot_task_lists is not None:
            pulumi.set(__self__, "sample_snapshot_task_lists", sample_snapshot_task_lists)
        if snapshot_by_time_offset_task_lists is not None:
            pulumi.set(__self__, "snapshot_by_time_offset_task_lists", snapshot_by_time_offset_task_lists)
        if transcode_task_lists is not None:
            pulumi.set(__self__, "transcode_task_lists", transcode_task_lists)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskLists")
    def adaptive_dynamic_streaming_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList']]:
        """
        List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_task_lists")

    @property
    @pulumi.getter(name="animatedGraphicTaskLists")
    def animated_graphic_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList']]:
        """
        List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "animated_graphic_task_lists")

    @property
    @pulumi.getter(name="coverBySnapshotTaskLists")
    def cover_by_snapshot_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList']]:
        """
        List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "cover_by_snapshot_task_lists")

    @property
    @pulumi.getter(name="imageSpriteTaskLists")
    def image_sprite_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskImageSpriteTaskList']]:
        """
        List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "image_sprite_task_lists")

    @property
    @pulumi.getter(name="sampleSnapshotTaskLists")
    def sample_snapshot_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList']]:
        """
        List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "sample_snapshot_task_lists")

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskLists")
    def snapshot_by_time_offset_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList']]:
        """
        List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "snapshot_by_time_offset_task_lists")

    @property
    @pulumi.getter(name="transcodeTaskLists")
    def transcode_task_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskList']]:
        """
        List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "transcode_task_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subtitleLists":
            suggest = "subtitle_lists"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 subtitle_lists: Optional[Sequence[str]] = None,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList']] = None):
        """
        :param str definition: Adaptive bitrate streaming template ID.
        :param Sequence[str] subtitle_lists: Subtitle list, element is subtitle ID, support multiple subtitles, up to 16.
        :param Sequence['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if subtitle_lists is not None:
            pulumi.set(__self__, "subtitle_lists", subtitle_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Adaptive bitrate streaming template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="subtitleLists")
    def subtitle_lists(self) -> Optional[Sequence[str]]:
        """
        Subtitle list, element is subtitle ID, support multiple subtitles, up to 16.
        """
        return pulumi.get(self, "subtitle_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList']]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Watermarking template ID.
        :param float end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: float,
                 start_time_offset: float):
        """
        :param str definition: Animated image generating template ID.
        :param float end_time_offset: End time of animated image in video in seconds.
        :param float start_time_offset: Start time of animated image in video in seconds.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Animated image generating template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        """
        End time of animated image in video in seconds.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        """
        Start time of animated image in video in seconds.
        """
        return pulumi.get(self, "start_time_offset")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionType":
            suggest = "position_type"
        elif key == "positionValue":
            suggest = "position_value"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 position_type: str,
                 position_value: float,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList']] = None):
        """
        :param str definition: Time point screen capturing template ID.
        :param str position_type: Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        :param float position_value: Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        :param Sequence['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "position_type", position_type)
        pulumi.set(__self__, "position_value", position_value)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Time point screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="positionType")
    def position_type(self) -> str:
        """
        Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        """
        return pulumi.get(self, "position_type")

    @property
    @pulumi.getter(name="positionValue")
    def position_value(self) -> float:
        """
        Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        """
        return pulumi.get(self, "position_value")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList']]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Watermarking template ID.
        :param float end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskImageSpriteTaskList(dict):
    def __init__(__self__, *,
                 definition: str):
        """
        :param str definition: Image sprite generating template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Image sprite generating template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList']] = None):
        """
        :param str definition: Sampled screen capturing template ID.
        :param Sequence['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Sampled screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList']]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Watermarking template ID.
        :param float end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extTimeOffsetLists":
            suggest = "ext_time_offset_lists"
        elif key == "timeOffsetLists":
            suggest = "time_offset_lists"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 ext_time_offset_lists: Optional[Sequence[str]] = None,
                 time_offset_lists: Optional[Sequence[float]] = None,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList']] = None):
        """
        :param str definition: Time point screen capturing template ID.
        :param Sequence[str] ext_time_offset_lists: The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        :param Sequence[float] time_offset_lists: List of time points for screencapturing in milliseconds. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if ext_time_offset_lists is not None:
            pulumi.set(__self__, "ext_time_offset_lists", ext_time_offset_lists)
        if time_offset_lists is not None:
            pulumi.set(__self__, "time_offset_lists", time_offset_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Time point screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="extTimeOffsetLists")
    def ext_time_offset_lists(self) -> Optional[Sequence[str]]:
        """
        The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        """
        return pulumi.get(self, "ext_time_offset_lists")

    @property
    @pulumi.getter(name="timeOffsetLists")
    def time_offset_lists(self) -> Optional[Sequence[float]]:
        """
        List of time points for screencapturing in milliseconds. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_offset_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList']]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Watermarking template ID.
        :param float end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyRightWatermark":
            suggest = "copy_right_watermark"
        elif key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "headTailLists":
            suggest = "head_tail_lists"
        elif key == "mosaicLists":
            suggest = "mosaic_lists"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "traceWatermark":
            suggest = "trace_watermark"
        elif key == "watermarkLists":
            suggest = "watermark_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskTranscodeTaskList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 copy_right_watermark: Optional['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermark'] = None,
                 end_time_offset: Optional[float] = None,
                 head_tail_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailList']] = None,
                 mosaic_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList']] = None,
                 start_time_offset: Optional[float] = None,
                 trace_watermark: Optional['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermark'] = None,
                 watermark_lists: Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList']] = None):
        """
        :param str definition: Video transcoding template ID.
        :param 'ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs' copy_right_watermark: opyright watermark.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param Sequence['ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs'] head_tail_lists: List of video opening/closing credits configuration template IDs. You can enter up to 10 IDs.
        :param Sequence['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs'] mosaic_lists: List of blurs. Up to 10 ones can be supported.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param 'ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs' trace_watermark: Digital watermark.
        :param Sequence['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if copy_right_watermark is not None:
            pulumi.set(__self__, "copy_right_watermark", copy_right_watermark)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if head_tail_lists is not None:
            pulumi.set(__self__, "head_tail_lists", head_tail_lists)
        if mosaic_lists is not None:
            pulumi.set(__self__, "mosaic_lists", mosaic_lists)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if trace_watermark is not None:
            pulumi.set(__self__, "trace_watermark", trace_watermark)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="copyRightWatermark")
    def copy_right_watermark(self) -> Optional['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermark']:
        """
        opyright watermark.
        """
        return pulumi.get(self, "copy_right_watermark")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="headTailLists")
    def head_tail_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailList']]:
        """
        List of video opening/closing credits configuration template IDs. You can enter up to 10 IDs.
        """
        return pulumi.get(self, "head_tail_lists")

    @property
    @pulumi.getter(name="mosaicLists")
    def mosaic_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList']]:
        """
        List of blurs. Up to 10 ones can be supported.
        """
        return pulumi.get(self, "mosaic_lists")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="traceWatermark")
    def trace_watermark(self) -> Optional['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermark']:
        """
        Digital watermark.
        """
        return pulumi.get(self, "trace_watermark")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[Sequence['outputs.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList']]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermark(dict):
    def __init__(__self__, *,
                 text: Optional[str] = None):
        """
        :param str text: Copyright information, maximum length is 200 characters.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        Copyright information, maximum length is 200 characters.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailList(dict):
    def __init__(__self__, *,
                 definition: Optional[str] = None):
        """
        :param str definition: Video opening/closing credits configuration template ID.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[str]:
        """
        Video opening/closing credits configuration template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coordinateOrigin":
            suggest = "coordinate_origin"
        elif key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "xPos":
            suggest = "x_pos"
        elif key == "yPos":
            suggest = "y_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coordinate_origin: Optional[str] = None,
                 end_time_offset: Optional[float] = None,
                 height: Optional[str] = None,
                 start_time_offset: Optional[float] = None,
                 width: Optional[str] = None,
                 x_pos: Optional[str] = None,
                 y_pos: Optional[str] = None):
        """
        :param str coordinate_origin: Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param str height: Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str width: Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
        :param str x_pos: The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
        :param str y_pos: Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
        """
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[str]:
        """
        Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[str]:
        """
        The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[str]:
        """
        Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermark(dict):
    def __init__(__self__, *,
                 switch: Optional[str] = None):
        """
        :param str switch: Whether to use digital watermarks. This parameter is required. Valid values: ON, OFF.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> Optional[str]:
        """
        Whether to use digital watermarks. This parameter is required. Valid values: ON, OFF.
        """
        return pulumi.get(self, "switch")


@pulumi.output_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTimeOffset":
            suggest = "end_time_offset"
        elif key == "startTimeOffset":
            suggest = "start_time_offset"
        elif key == "svgContent":
            suggest = "svg_content"
        elif key == "textContent":
            suggest = "text_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Watermarking template ID.
        :param float end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class ProcedureTemplateReviewAudioVideoTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reviewContents":
            suggest = "review_contents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcedureTemplateReviewAudioVideoTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcedureTemplateReviewAudioVideoTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcedureTemplateReviewAudioVideoTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: Optional[str] = None,
                 review_contents: Optional[Sequence[str]] = None):
        """
        :param str definition: Review template.
        :param Sequence[str] review_contents: The type of moderated content. Valid values:
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)
        if review_contents is not None:
            pulumi.set(__self__, "review_contents", review_contents)

    @property
    @pulumi.getter
    def definition(self) -> Optional[str]:
        """
        Review template.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="reviewContents")
    def review_contents(self) -> Optional[Sequence[str]]:
        """
        The type of moderated content. Valid values:
        """
        return pulumi.get(self, "review_contents")


@pulumi.output_type
class SuperPlayerConfigDrmStreamingInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleAesDefinition":
            suggest = "simple_aes_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuperPlayerConfigDrmStreamingInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuperPlayerConfigDrmStreamingInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuperPlayerConfigDrmStreamingInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_aes_definition: Optional[str] = None):
        """
        :param str simple_aes_definition: ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        if simple_aes_definition is not None:
            pulumi.set(__self__, "simple_aes_definition", simple_aes_definition)

    @property
    @pulumi.getter(name="simpleAesDefinition")
    def simple_aes_definition(self) -> Optional[str]:
        """
        ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        return pulumi.get(self, "simple_aes_definition")


@pulumi.output_type
class SuperPlayerConfigResolutionName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minEdgeLength":
            suggest = "min_edge_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuperPlayerConfigResolutionName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuperPlayerConfigResolutionName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuperPlayerConfigResolutionName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_edge_length: int,
                 name: str):
        """
        :param int min_edge_length: Length of video short side in px.
        :param str name: Display name.
        """
        pulumi.set(__self__, "min_edge_length", min_edge_length)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="minEdgeLength")
    def min_edge_length(self) -> int:
        """
        Length of video short side in px.
        """
        return pulumi.get(self, "min_edge_length")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TranscodeTemplateAudioTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"
        elif key == "audioChannel":
            suggest = "audio_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateAudioTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateAudioTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateAudioTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 sample_rate: int,
                 audio_channel: Optional[int] = None):
        """
        :param int bitrate: Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
        :param str codec: The audio codec.If `Container` is `mp3`, the valid value is:`libmp3lame`If `Container` is `ogg` or `flac`, the valid value is:`flac`If `Container` is `m4a`, the valid values are:`libfdk_aac``libmp3lame``ac3`If `Container` is `mp4` or `flv`, the valid values are:`libfdk_aac` (Recommended for MP4)`libmp3lame` (Recommended for FLV)`mp2`If `Container` is `hls`, the valid value is:`libfdk_aac`If `Format` is `HLS` or `MPEG-DASH`, the valid value is:`libfdk_aac`If `Container` is `wav`, the valid value is:`pcm16`.
        :param int sample_rate: The audio sample rate. Valid values:`16000` (valid only if `Codec` is `pcm16`)`32000``44100``48000`Unit: Hz.
        :param int audio_channel: Audio channel system. Valid values:1: mono-channel2: dual-channel6: stereoYou cannot set the sound channel as stereo for media files in container formats for audios (FLAC, OGG, MP3, M4A).Default value: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        The audio codec.If `Container` is `mp3`, the valid value is:`libmp3lame`If `Container` is `ogg` or `flac`, the valid value is:`flac`If `Container` is `m4a`, the valid values are:`libfdk_aac``libmp3lame``ac3`If `Container` is `mp4` or `flv`, the valid values are:`libfdk_aac` (Recommended for MP4)`libmp3lame` (Recommended for FLV)`mp2`If `Container` is `hls`, the valid value is:`libfdk_aac`If `Format` is `HLS` or `MPEG-DASH`, the valid value is:`libfdk_aac`If `Container` is `wav`, the valid value is:`pcm16`.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        """
        The audio sample rate. Valid values:`16000` (valid only if `Codec` is `pcm16`)`32000``44100``48000`Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[int]:
        """
        Audio channel system. Valid values:1: mono-channel2: dual-channel6: stereoYou cannot set the sound channel as stereo for media files in container formats for audios (FLAC, OGG, MP3, M4A).Default value: 2.
        """
        return pulumi.get(self, "audio_channel")


@pulumi.output_type
class TranscodeTemplateTehdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVideoBitrate":
            suggest = "max_video_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateTehdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateTehdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateTehdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 max_video_bitrate: Optional[int] = None):
        """
        :param str type: TESHD transcoding type. Valid values: TEHD-100, OFF (default).
        :param int max_video_bitrate: Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left blank or 0 is entered, there will be no upper limit for bitrate.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        TESHD transcoding type. Valid values: TEHD-100, OFF (default).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[int]:
        """
        Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left blank or 0 is entered, there will be no upper limit for bitrate.
        """
        return pulumi.get(self, "max_video_bitrate")


@pulumi.output_type
class TranscodeTemplateVideoTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codecTag":
            suggest = "codec_tag"
        elif key == "fillType":
            suggest = "fill_type"
        elif key == "preserveHdrSwitch":
            suggest = "preserve_hdr_switch"
        elif key == "resolutionAdaptive":
            suggest = "resolution_adaptive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodeTemplateVideoTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodeTemplateVideoTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodeTemplateVideoTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fps: int,
                 codec_tag: Optional[str] = None,
                 fill_type: Optional[str] = None,
                 gop: Optional[int] = None,
                 height: Optional[int] = None,
                 preserve_hdr_switch: Optional[str] = None,
                 resolution_adaptive: Optional[str] = None,
                 vcrf: Optional[int] = None,
                 width: Optional[int] = None):
        """
        :param int bitrate: Bitrate of video stream in Kbps. Value range: 0 and [128, 35,000].If the value is 0, the bitrate of the video will be the same as that of the source video.
        :param str codec: The video codec. Valid values:libx264: H.264; libx265: H.265; av1: AOMedia Video 1; H.266: H.266. The AOMedia Video 1 and H.266 codecs can only be used for MP4 files. Only CRF is supported for H.266 currently.
        :param int fps: Video frame rate in Hz. Value range: [0,100].If the value is 0, the frame rate will be the same as that of the source video.
        :param str codec_tag: The codec tag. This parameter is valid only if the H.265 codec is used. Valid values:hvc1hev1Default value: hvc1.
        :param str fill_type: Fill type, the way of processing a screenshot when the configured aspect ratio is different from that of the source video. Valid values:stretch: stretches the video image frame by frame to fill the screen. The video image may become squashed or stretched after transcoding.black: fills the uncovered area with black color, without changing the image&#39;s aspect ratio.white: fills the uncovered area with white color, without changing the image&#39;s aspect ratio.gauss: applies Gaussian blur to the uncovered area, without changing the image&#39;s aspect ratio.Default value: black.
        :param int gop: I-frame interval in frames. Valid values: 0 and 1-100000.When this parameter is set to 0 or left empty, `Gop` will be automatically set.
        :param int height: The maximum video height (or short side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        :param str preserve_hdr_switch: Whether to output an HDR (high dynamic range) video if the source video is HDR. Valid values:ON: If the source video is HDR, output an HDR video; if not, output an SDR (standard dynamic range) video.OFF: Output an SDR video regardless of whether the source video is HDR.Default value: OFF.
        :param str resolution_adaptive: Resolution adaption. Valid values:open: enabled. In this case, `Width` represents the long side of a video, while `Height` the short side;close: disabled. In this case, `Width` represents the width of a video, while `Height` the height.Default value: open.Note: this field may return null, indicating that no valid values can be obtained.
        :param int vcrf: The video constant rate factor (CRF). Value range: 1-51.If this parameter is specified, CRF encoding will be used and the bitrate parameter will be ignored.If `Codec` is `H.266`, this parameter is required (`28` is recommended).We don't recommend using this parameter unless you have special requirements.
        :param int width: The maximum video width (or long side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if codec_tag is not None:
            pulumi.set(__self__, "codec_tag", codec_tag)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if preserve_hdr_switch is not None:
            pulumi.set(__self__, "preserve_hdr_switch", preserve_hdr_switch)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bitrate of video stream in Kbps. Value range: 0 and [128, 35,000].If the value is 0, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        The video codec. Valid values:libx264: H.264; libx265: H.265; av1: AOMedia Video 1; H.266: H.266. The AOMedia Video 1 and H.266 codecs can only be used for MP4 files. Only CRF is supported for H.266 currently.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> int:
        """
        Video frame rate in Hz. Value range: [0,100].If the value is 0, the frame rate will be the same as that of the source video.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter(name="codecTag")
    def codec_tag(self) -> Optional[str]:
        """
        The codec tag. This parameter is valid only if the H.265 codec is used. Valid values:hvc1hev1Default value: hvc1.
        """
        return pulumi.get(self, "codec_tag")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[str]:
        """
        Fill type, the way of processing a screenshot when the configured aspect ratio is different from that of the source video. Valid values:stretch: stretches the video image frame by frame to fill the screen. The video image may become squashed or stretched after transcoding.black: fills the uncovered area with black color, without changing the image&#39;s aspect ratio.white: fills the uncovered area with white color, without changing the image&#39;s aspect ratio.gauss: applies Gaussian blur to the uncovered area, without changing the image&#39;s aspect ratio.Default value: black.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def gop(self) -> Optional[int]:
        """
        I-frame interval in frames. Valid values: 0 and 1-100000.When this parameter is set to 0 or left empty, `Gop` will be automatically set.
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The maximum video height (or short side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="preserveHdrSwitch")
    def preserve_hdr_switch(self) -> Optional[str]:
        """
        Whether to output an HDR (high dynamic range) video if the source video is HDR. Valid values:ON: If the source video is HDR, output an HDR video; if not, output an SDR (standard dynamic range) video.OFF: Output an SDR video regardless of whether the source video is HDR.Default value: OFF.
        """
        return pulumi.get(self, "preserve_hdr_switch")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[str]:
        """
        Resolution adaption. Valid values:open: enabled. In this case, `Width` represents the long side of a video, while `Height` the short side;close: disabled. In this case, `Width` represents the width of a video, while `Height` the height.Default value: open.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[int]:
        """
        The video constant rate factor (CRF). Value range: 1-51.If this parameter is specified, CRF encoding will be used and the bitrate parameter will be ignored.If `Codec` is `H.266`, this parameter is required (`28` is recommended).We don't recommend using this parameter unless you have special requirements.
        """
        return pulumi.get(self, "vcrf")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The maximum video width (or long side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WatermarkTemplateImageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageContent":
            suggest = "image_content"
        elif key == "repeatType":
            suggest = "repeat_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WatermarkTemplateImageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WatermarkTemplateImageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WatermarkTemplateImageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_content: str,
                 height: Optional[str] = None,
                 repeat_type: Optional[str] = None,
                 transparency: Optional[int] = None,
                 width: Optional[str] = None):
        """
        :param str image_content: The [Base64](https://tools.ietf.org/html/rfc4648) encoded string of a watermark image. Only JPEG, PNG, and GIF images are supported.
        :param str height: Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;  If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px. Valid values: 0 or [8,4096]. Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
        :param str repeat_type: Repeat type of an animated watermark. Valid values: once: no longer appears after watermark playback ends.  repeat_last_frame: stays on the last frame after watermark playback ends.  repeat (default): repeats the playback until the video ends.
        :param int transparency: Image watermark transparency: 0: completely opaque  100: completely transparent Default value: 0.
        :param str width: Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width. For example, `10%` means that `Width` is 10% of the video width;  If the string ends in px, the `Width` of the watermark will be in pixels. For example, `100px` means that `Width` is 100 pixels. Value range: [8, 4096]. Default value: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if transparency is not None:
            pulumi.set(__self__, "transparency", transparency)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> str:
        """
        The [Base64](https://tools.ietf.org/html/rfc4648) encoded string of a watermark image. Only JPEG, PNG, and GIF images are supported.
        """
        return pulumi.get(self, "image_content")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;  If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px. Valid values: 0 or [8,4096]. Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[str]:
        """
        Repeat type of an animated watermark. Valid values: once: no longer appears after watermark playback ends.  repeat_last_frame: stays on the last frame after watermark playback ends.  repeat (default): repeats the playback until the video ends.
        """
        return pulumi.get(self, "repeat_type")

    @property
    @pulumi.getter
    def transparency(self) -> Optional[int]:
        """
        Image watermark transparency: 0: completely opaque  100: completely transparent Default value: 0.
        """
        return pulumi.get(self, "transparency")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width. For example, `10%` means that `Width` is 10% of the video width;  If the string ends in px, the `Width` of the watermark will be in pixels. For example, `100px` means that `Width` is 100 pixels. Value range: [8, 4096]. Default value: 10%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WatermarkTemplateSvgTemplate(dict):
    def __init__(__self__, *,
                 height: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str height: Watermark height, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px; if `0px` is entered and `Width` is not `0px`, the watermark height will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark height will be the height of the source SVG image;  If the string ends in `W%`, the `Height` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Height` is 10% of the video width;  If the string ends in `H%`, the `Height` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Height` is 10% of the video height;  If the string ends in `S%`, the `Height` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Height` is 10% of the short side of the video;  If the string ends in `L%`, the `Height` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Height` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `H%`. Default value: 0 px.
        :param str width: Watermark width, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px; if `0px` is entered and `Height` is not `0px`, the watermark width will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark width will be the width of the source SVG image;  If the string ends in `W%`, the `Width` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Width` is 10% of the video width;  If the string ends in `H%`, the `Width` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Width` is 10% of the video height;  If the string ends in `S%`, the `Width` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Width` is 10% of the short side of the video;  If the string ends in `L%`, the `Width` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Width` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `W%`. Default value: 10W%.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        Watermark height, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px; if `0px` is entered and `Width` is not `0px`, the watermark height will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark height will be the height of the source SVG image;  If the string ends in `W%`, the `Height` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Height` is 10% of the video width;  If the string ends in `H%`, the `Height` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Height` is 10% of the video height;  If the string ends in `S%`, the `Height` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Height` is 10% of the short side of the video;  If the string ends in `L%`, the `Height` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Height` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `H%`. Default value: 0 px.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        Watermark width, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px; if `0px` is entered and `Height` is not `0px`, the watermark width will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark width will be the width of the source SVG image;  If the string ends in `W%`, the `Width` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Width` is 10% of the video width;  If the string ends in `H%`, the `Width` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Width` is 10% of the video height;  If the string ends in `S%`, the `Width` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Width` is 10% of the short side of the video;  If the string ends in `L%`, the `Width` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Width` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `W%`. Default value: 10W%.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class WatermarkTemplateTextTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontAlpha":
            suggest = "font_alpha"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontType":
            suggest = "font_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WatermarkTemplateTextTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WatermarkTemplateTextTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WatermarkTemplateTextTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_alpha: float,
                 font_color: str,
                 font_size: str,
                 font_type: str):
        """
        :param float font_alpha: Text transparency. Value range: (0, 1] 0: completely transparent  1: completely opaque Default value: 1.
        :param str font_color: Font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).
        :param str font_size: Font size in Npx format where N is a numeric value.
        :param str font_type: Font type. Currently, two types are supported: simkai.ttf: both Chinese and English are supported;  arial.ttf: only English is supported.
        """
        pulumi.set(__self__, "font_alpha", font_alpha)
        pulumi.set(__self__, "font_color", font_color)
        pulumi.set(__self__, "font_size", font_size)
        pulumi.set(__self__, "font_type", font_type)

    @property
    @pulumi.getter(name="fontAlpha")
    def font_alpha(self) -> float:
        """
        Text transparency. Value range: (0, 1] 0: completely transparent  1: completely opaque Default value: 1.
        """
        return pulumi.get(self, "font_alpha")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> str:
        """
        Font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).
        """
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> str:
        """
        Font size in Npx format where N is a numeric value.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> str:
        """
        Font type. Currently, two types are supported: simkai.ttf: both Chinese and English are supported;  arial.ttf: only English is supported.
        """
        return pulumi.get(self, "font_type")


@pulumi.output_type
class GetAdaptiveDynamicStreamingTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 create_time: str,
                 definition: str,
                 disable_higher_video_bitrate: bool,
                 disable_higher_video_resolution: bool,
                 drm_type: str,
                 format: str,
                 name: str,
                 stream_infos: Sequence['outputs.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult'],
                 type: str,
                 update_time: str):
        """
        :param str comment: Template description.
        :param str create_time: Creation time of template in ISO date format.
        :param str definition: Unique ID filter of adaptive dynamic streaming template.
        :param bool disable_higher_video_bitrate: Whether to prohibit transcoding video from low bitrate to high bitrate. `false`: no, `true`: yes.
        :param bool disable_higher_video_resolution: Whether to prohibit transcoding from low resolution to high resolution. `false`: no, `true`: yes.
        :param str drm_type: DRM scheme type.
        :param str format: Adaptive bitstream format.
        :param str name: Template name.
        :param Sequence['GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoArgs'] stream_infos: List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming.
        :param str type: Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        :param str update_time: Last modified time of template in ISO date format.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "disable_higher_video_bitrate", disable_higher_video_bitrate)
        pulumi.set(__self__, "disable_higher_video_resolution", disable_higher_video_resolution)
        pulumi.set(__self__, "drm_type", drm_type)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stream_infos", stream_infos)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Template description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Creation time of template in ISO date format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Unique ID filter of adaptive dynamic streaming template.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="disableHigherVideoBitrate")
    def disable_higher_video_bitrate(self) -> bool:
        """
        Whether to prohibit transcoding video from low bitrate to high bitrate. `false`: no, `true`: yes.
        """
        return pulumi.get(self, "disable_higher_video_bitrate")

    @property
    @pulumi.getter(name="disableHigherVideoResolution")
    def disable_higher_video_resolution(self) -> bool:
        """
        Whether to prohibit transcoding from low resolution to high resolution. `false`: no, `true`: yes.
        """
        return pulumi.get(self, "disable_higher_video_resolution")

    @property
    @pulumi.getter(name="drmType")
    def drm_type(self) -> str:
        """
        DRM scheme type.
        """
        return pulumi.get(self, "drm_type")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Adaptive bitstream format.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Template name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="streamInfos")
    def stream_infos(self) -> Sequence['outputs.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult']:
        """
        List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming.
        """
        return pulumi.get(self, "stream_infos")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last modified time of template in ISO date format.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoResult(dict):
    def __init__(__self__, *,
                 audios: Sequence['outputs.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult'],
                 remove_audio: bool,
                 videos: Sequence['outputs.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult']):
        """
        :param Sequence['GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioArgs'] audios: Audio parameter information.
        :param bool remove_audio: Whether to remove audio stream. `false`: no, `true`: yes.
        :param Sequence['GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoArgs'] videos: Video parameter information.
        """
        pulumi.set(__self__, "audios", audios)
        pulumi.set(__self__, "remove_audio", remove_audio)
        pulumi.set(__self__, "videos", videos)

    @property
    @pulumi.getter
    def audios(self) -> Sequence['outputs.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult']:
        """
        Audio parameter information.
        """
        return pulumi.get(self, "audios")

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> bool:
        """
        Whether to remove audio stream. `false`: no, `true`: yes.
        """
        return pulumi.get(self, "remove_audio")

    @property
    @pulumi.getter
    def videos(self) -> Sequence['outputs.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult']:
        """
        Video parameter information.
        """
        return pulumi.get(self, "videos")


@pulumi.output_type
class GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudioResult(dict):
    def __init__(__self__, *,
                 audio_channel: str,
                 bitrate: int,
                 codec: str,
                 sample_rate: int):
        """
        :param str audio_channel: Audio channel system. Valid values: mono, dual, stereo.
        :param int bitrate: Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        :param str codec: Video stream encoder. Valid values: `libx264`, `libx265`, `av1`.`libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        :param int sample_rate: Audio stream sample rate. Valid values: `32000`, `44100`, `48000`. Unit is HZ.
        """
        pulumi.set(__self__, "audio_channel", audio_channel)
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> str:
        """
        Audio channel system. Valid values: mono, dual, stereo.
        """
        return pulumi.get(self, "audio_channel")

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Video stream encoder. Valid values: `libx264`, `libx265`, `av1`.`libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> int:
        """
        Audio stream sample rate. Valid values: `32000`, `44100`, `48000`. Unit is HZ.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideoResult(dict):
    def __init__(__self__, *,
                 bitrate: int,
                 codec: str,
                 fill_type: str,
                 fps: int,
                 height: int,
                 resolution_adaptive: bool,
                 width: int):
        """
        :param int bitrate: Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        :param str codec: Video stream encoder. Valid values: `libx264`, `libx265`, `av1`.`libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        :param str fill_type: Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Note: this field may return null, indicating that no valid values can be obtained.
        :param int fps: Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        :param int height: Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Note: this field may return null, indicating that no valid values can be obtained.
        :param bool resolution_adaptive: Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Note: this field may return null, indicating that no valid values can be obtained.
        :param int width: Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fill_type", fill_type)
        pulumi.set(__self__, "fps", fps)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> int:
        """
        Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Video stream encoder. Valid values: `libx264`, `libx265`, `av1`.`libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> str:
        """
        Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def fps(self) -> int:
        """
        Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> bool:
        """
        Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetImageSpriteTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 column_count: int,
                 comment: str,
                 create_time: str,
                 definition: str,
                 fill_type: str,
                 height: int,
                 name: str,
                 resolution_adaptive: bool,
                 row_count: int,
                 sample_interval: int,
                 sample_type: str,
                 type: str,
                 update_time: str,
                 width: int):
        """
        :param int column_count: Subimage column count of an image sprite.
        :param str comment: Template description.
        :param str create_time: Creation time of template in ISO date format.
        :param str definition: Unique ID filter of image sprite template.
        :param str fill_type: Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks.
        :param int height: Maximum value of the `height` (or short side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        :param str name: Name of a time point screen capturing template.
        :param bool resolution_adaptive: Resolution adaption. Valid values: `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height.
        :param int row_count: Subimage row count of an image sprite.
        :param int sample_interval: Sampling interval. If `sample_type` is `Percent`, sampling will be performed at an interval of the specified percentage. If `sample_type` is `Time`, sampling will be performed at the specified time interval in seconds.
        :param str sample_type: Sampling type. Valid values: `Percent`, `Time`. `Percent`: by percent. `Time`: by time interval.
        :param str type: Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        :param str update_time: Last modified time of template in ISO date format.
        :param int width: Maximum value of the `width` (or long side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, width will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        """
        pulumi.set(__self__, "column_count", column_count)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "fill_type", fill_type)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        pulumi.set(__self__, "row_count", row_count)
        pulumi.set(__self__, "sample_interval", sample_interval)
        pulumi.set(__self__, "sample_type", sample_type)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="columnCount")
    def column_count(self) -> int:
        """
        Subimage column count of an image sprite.
        """
        return pulumi.get(self, "column_count")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Template description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Creation time of template in ISO date format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Unique ID filter of image sprite template.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> str:
        """
        Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        Maximum value of the `height` (or short side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a time point screen capturing template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> bool:
        """
        Resolution adaption. Valid values: `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter(name="rowCount")
    def row_count(self) -> int:
        """
        Subimage row count of an image sprite.
        """
        return pulumi.get(self, "row_count")

    @property
    @pulumi.getter(name="sampleInterval")
    def sample_interval(self) -> int:
        """
        Sampling interval. If `sample_type` is `Percent`, sampling will be performed at an interval of the specified percentage. If `sample_type` is `Time`, sampling will be performed at the specified time interval in seconds.
        """
        return pulumi.get(self, "sample_interval")

    @property
    @pulumi.getter(name="sampleType")
    def sample_type(self) -> str:
        """
        Sampling type. Valid values: `Percent`, `Time`. `Percent`: by percent. `Time`: by time interval.
        """
        return pulumi.get(self, "sample_type")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last modified time of template in ISO date format.
        """
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        Maximum value of the `width` (or long side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, width will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetProcedureTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 create_time: str,
                 media_process_tasks: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskResult'],
                 name: str,
                 type: str,
                 update_time: str):
        """
        :param str comment: Template description.
        :param str create_time: Creation time of template in ISO date format.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskArgs'] media_process_tasks: Parameter of video processing task.
        :param str name: Name of procedure template.
        :param str type: Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        :param str update_time: Last modified time of template in ISO date format.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "media_process_tasks", media_process_tasks)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Template description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Creation time of template in ISO date format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="mediaProcessTasks")
    def media_process_tasks(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskResult']:
        """
        Parameter of video processing task.
        """
        return pulumi.get(self, "media_process_tasks")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of procedure template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last modified time of template in ISO date format.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskResult(dict):
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult'],
                 animated_graphic_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult'],
                 cover_by_snapshot_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult'],
                 image_sprite_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult'],
                 sample_snapshot_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult'],
                 snapshot_by_time_offset_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult'],
                 transcode_task_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult']):
        """
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs'] adaptive_dynamic_streaming_task_lists: List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListArgs'] animated_graphic_task_lists: List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListArgs'] cover_by_snapshot_task_lists: List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListArgs'] image_sprite_task_lists: List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListArgs'] sample_snapshot_task_lists: List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListArgs'] snapshot_by_time_offset_task_lists: List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListArgs'] transcode_task_lists: List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "adaptive_dynamic_streaming_task_lists", adaptive_dynamic_streaming_task_lists)
        pulumi.set(__self__, "animated_graphic_task_lists", animated_graphic_task_lists)
        pulumi.set(__self__, "cover_by_snapshot_task_lists", cover_by_snapshot_task_lists)
        pulumi.set(__self__, "image_sprite_task_lists", image_sprite_task_lists)
        pulumi.set(__self__, "sample_snapshot_task_lists", sample_snapshot_task_lists)
        pulumi.set(__self__, "snapshot_by_time_offset_task_lists", snapshot_by_time_offset_task_lists)
        pulumi.set(__self__, "transcode_task_lists", transcode_task_lists)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskLists")
    def adaptive_dynamic_streaming_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult']:
        """
        List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_task_lists")

    @property
    @pulumi.getter(name="animatedGraphicTaskLists")
    def animated_graphic_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult']:
        """
        List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "animated_graphic_task_lists")

    @property
    @pulumi.getter(name="coverBySnapshotTaskLists")
    def cover_by_snapshot_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult']:
        """
        List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "cover_by_snapshot_task_lists")

    @property
    @pulumi.getter(name="imageSpriteTaskLists")
    def image_sprite_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult']:
        """
        List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "image_sprite_task_lists")

    @property
    @pulumi.getter(name="sampleSnapshotTaskLists")
    def sample_snapshot_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult']:
        """
        List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "sample_snapshot_task_lists")

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskLists")
    def snapshot_by_time_offset_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult']:
        """
        List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "snapshot_by_time_offset_task_lists")

    @property
    @pulumi.getter(name="transcodeTaskLists")
    def transcode_task_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult']:
        """
        List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "transcode_task_lists")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult']):
        """
        :param str definition: Video transcoding template ID.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult']:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Video transcoding template ID.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: float,
                 start_time_offset: float):
        """
        :param str definition: Video transcoding template ID.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 position_type: str,
                 position_value: float,
                 watermark_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult']):
        """
        :param str definition: Video transcoding template ID.
        :param str position_type: Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        :param float position_value: Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "position_type", position_type)
        pulumi.set(__self__, "position_value", position_value)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="positionType")
    def position_type(self) -> str:
        """
        Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        """
        return pulumi.get(self, "position_type")

    @property
    @pulumi.getter(name="positionValue")
    def position_value(self) -> float:
        """
        Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        """
        return pulumi.get(self, "position_value")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult']:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Video transcoding template ID.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str):
        """
        :param str definition: Video transcoding template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 watermark_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult']):
        """
        :param str definition: Video transcoding template ID.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult']:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Video transcoding template ID.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 ext_time_offset_lists: Sequence[str],
                 watermark_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult']):
        """
        :param str definition: Video transcoding template ID.
        :param Sequence[str] ext_time_offset_lists: The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "ext_time_offset_lists", ext_time_offset_lists)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="extTimeOffsetLists")
    def ext_time_offset_lists(self) -> Sequence[str]:
        """
        The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        """
        return pulumi.get(self, "ext_time_offset_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult']:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Video transcoding template ID.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 mosaic_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult'],
                 watermark_lists: Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult']):
        """
        :param str definition: Video transcoding template ID.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListArgs'] mosaic_lists: List of blurs. Up to 10 ones can be supported.
        :param Sequence['GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListArgs'] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "mosaic_lists", mosaic_lists)
        pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="mosaicLists")
    def mosaic_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult']:
        """
        List of blurs. Up to 10 ones can be supported.
        """
        return pulumi.get(self, "mosaic_lists")

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Sequence['outputs.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult']:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicListResult(dict):
    def __init__(__self__, *,
                 coordinate_origin: str,
                 end_time_offset: float,
                 height: str,
                 start_time_offset: float,
                 width: str,
                 x_pos: str,
                 y_pos: str):
        """
        :param str coordinate_origin: Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param str height: Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str width: Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px.
        :param str x_pos: The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px.
        :param str y_pos: Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px.
        """
        pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x_pos", x_pos)
        pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> str:
        """
        Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text.
        """
        return pulumi.get(self, "coordinate_origin")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> float:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter
    def height(self) -> str:
        """
        Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> float:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> str:
        """
        The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px.
        """
        return pulumi.get(self, "x_pos")

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> str:
        """
        Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px.
        """
        return pulumi.get(self, "y_pos")


@pulumi.output_type
class GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkListResult(dict):
    def __init__(__self__, *,
                 definition: str,
                 end_time_offset: Optional[float] = None,
                 start_time_offset: Optional[float] = None,
                 svg_content: Optional[str] = None,
                 text_content: Optional[str] = None):
        """
        :param str definition: Video transcoding template ID.
        :param float end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param float start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param str svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param str text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[float]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[float]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[str]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")


@pulumi.output_type
class GetSnapshotByTimeOffsetTemplatesTemplateListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 create_time: str,
                 definition: str,
                 fill_type: str,
                 format: str,
                 height: int,
                 name: str,
                 resolution_adaptive: bool,
                 type: str,
                 update_time: str,
                 width: int):
        """
        :param str comment: Template description.
        :param str create_time: Creation time of template in ISO date format.
        :param str definition: Unique ID filter of snapshot by time offset template.
        :param str fill_type: Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot `shorter` or `longer`; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. `white`: fill with white. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with white color blocks. `gauss`: fill with Gaussian blur. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with Gaussian blur.
        :param str format: Image format. Valid values: `jpg`, `png`.
        :param int height: Maximum value of the `height` (or short side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        :param str name: Name of a time point screen capturing template.
        :param bool resolution_adaptive: Resolution adaption. Valid values: `true`, `false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height.
        :param str type: Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        :param str update_time: Last modified time of template in ISO date format.
        :param int width: Maximum value of the `width` (or long side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, width will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "fill_type", fill_type)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Template description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Creation time of template in ISO date format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Unique ID filter of snapshot by time offset template.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> str:
        """
        Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot `shorter` or `longer`; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. `white`: fill with white. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with white color blocks. `gauss`: fill with Gaussian blur. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with Gaussian blur.
        """
        return pulumi.get(self, "fill_type")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Image format. Valid values: `jpg`, `png`.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        Maximum value of the `height` (or short side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a time point screen capturing template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> bool:
        """
        Resolution adaption. Valid values: `true`, `false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height.
        """
        return pulumi.get(self, "resolution_adaptive")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Template type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last modified time of template in ISO date format.
        """
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        Maximum value of the `width` (or long side) of a screenshot in px. Value range: 0 and [128, 4,096]. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, width will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetSuperPlayerConfigsConfigListResult(dict):
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_definition: str,
                 comment: str,
                 create_time: str,
                 domain: str,
                 drm_streaming_infos: Sequence['outputs.GetSuperPlayerConfigsConfigListDrmStreamingInfoResult'],
                 drm_switch: bool,
                 image_sprite_definition: str,
                 name: str,
                 resolution_names: Sequence['outputs.GetSuperPlayerConfigsConfigListResolutionNameResult'],
                 scheme: str,
                 type: str,
                 update_time: str):
        """
        :param str adaptive_dynamic_streaming_definition: ID of the unencrypted adaptive bitrate streaming template that allows output, which is required if `drm_switch` is `false`.
        :param str comment: Template description.
        :param str create_time: Creation time of template in ISO date format.
        :param str domain: Domain name used for playback. If it is left empty or set to `Default`, the domain name configured in [Default Distribution Configuration](https://cloud.tencent.com/document/product/266/33373) will be used.
        :param Sequence['GetSuperPlayerConfigsConfigListDrmStreamingInfoArgs'] drm_streaming_infos: Content of the DRM-protected adaptive bitrate streaming template that allows output, which is required if `drm_switch` is `true`.
        :param bool drm_switch: Switch of DRM-protected adaptive bitstream playback: `true`: enabled, indicating to play back only output adaptive bitstreams protected by DRM; `false`: disabled, indicating to play back unencrypted output adaptive bitstreams.
        :param str image_sprite_definition: ID of the image sprite template that allows output.
        :param str name: Name of super player config.
        :param Sequence['GetSuperPlayerConfigsConfigListResolutionNameArgs'] resolution_names: Display name of player for substreams with different resolutions. If this parameter is left empty or an empty array, the default configuration will be used: `min_edge_length: 240, name: LD`; `min_edge_length: 480, name: SD`; `min_edge_length: 720, name: HD`; `min_edge_length: 1080, name: FHD`; `min_edge_length: 1440, name: 2K`; `min_edge_length: 2160, name: 4K`; `min_edge_length: 4320, name: 8K`.
        :param str scheme: Scheme used for playback. If it is left empty or set to `Default`, the scheme configured in [Default Distribution Configuration](https://cloud.tencent.com/document/product/266/33373) will be used. Other valid values: `HTTP`; `HTTPS`.
        :param str type: Config type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        :param str update_time: Last modified time of template in ISO date format.
        """
        pulumi.set(__self__, "adaptive_dynamic_streaming_definition", adaptive_dynamic_streaming_definition)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "drm_streaming_infos", drm_streaming_infos)
        pulumi.set(__self__, "drm_switch", drm_switch)
        pulumi.set(__self__, "image_sprite_definition", image_sprite_definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolution_names", resolution_names)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingDefinition")
    def adaptive_dynamic_streaming_definition(self) -> str:
        """
        ID of the unencrypted adaptive bitrate streaming template that allows output, which is required if `drm_switch` is `false`.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_definition")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Template description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Creation time of template in ISO date format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain name used for playback. If it is left empty or set to `Default`, the domain name configured in [Default Distribution Configuration](https://cloud.tencent.com/document/product/266/33373) will be used.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="drmStreamingInfos")
    def drm_streaming_infos(self) -> Sequence['outputs.GetSuperPlayerConfigsConfigListDrmStreamingInfoResult']:
        """
        Content of the DRM-protected adaptive bitrate streaming template that allows output, which is required if `drm_switch` is `true`.
        """
        return pulumi.get(self, "drm_streaming_infos")

    @property
    @pulumi.getter(name="drmSwitch")
    def drm_switch(self) -> bool:
        """
        Switch of DRM-protected adaptive bitstream playback: `true`: enabled, indicating to play back only output adaptive bitstreams protected by DRM; `false`: disabled, indicating to play back unencrypted output adaptive bitstreams.
        """
        return pulumi.get(self, "drm_switch")

    @property
    @pulumi.getter(name="imageSpriteDefinition")
    def image_sprite_definition(self) -> str:
        """
        ID of the image sprite template that allows output.
        """
        return pulumi.get(self, "image_sprite_definition")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of super player config.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolutionNames")
    def resolution_names(self) -> Sequence['outputs.GetSuperPlayerConfigsConfigListResolutionNameResult']:
        """
        Display name of player for substreams with different resolutions. If this parameter is left empty or an empty array, the default configuration will be used: `min_edge_length: 240, name: LD`; `min_edge_length: 480, name: SD`; `min_edge_length: 720, name: HD`; `min_edge_length: 1080, name: FHD`; `min_edge_length: 1440, name: 2K`; `min_edge_length: 2160, name: 4K`; `min_edge_length: 4320, name: 8K`.
        """
        return pulumi.get(self, "resolution_names")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        Scheme used for playback. If it is left empty or set to `Default`, the scheme configured in [Default Distribution Configuration](https://cloud.tencent.com/document/product/266/33373) will be used. Other valid values: `HTTP`; `HTTPS`.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Config type filter. Valid values: `Preset`, `Custom`. `Preset`: preset template; `Custom`: custom template.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last modified time of template in ISO date format.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetSuperPlayerConfigsConfigListDrmStreamingInfoResult(dict):
    def __init__(__self__, *,
                 simple_aes_definition: str):
        """
        :param str simple_aes_definition: ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        pulumi.set(__self__, "simple_aes_definition", simple_aes_definition)

    @property
    @pulumi.getter(name="simpleAesDefinition")
    def simple_aes_definition(self) -> str:
        """
        ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        return pulumi.get(self, "simple_aes_definition")


@pulumi.output_type
class GetSuperPlayerConfigsConfigListResolutionNameResult(dict):
    def __init__(__self__, *,
                 min_edge_length: int,
                 name: str):
        """
        :param int min_edge_length: Length of video short side in px.
        :param str name: Name of super player config.
        """
        pulumi.set(__self__, "min_edge_length", min_edge_length)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="minEdgeLength")
    def min_edge_length(self) -> int:
        """
        Length of video short side in px.
        """
        return pulumi.get(self, "min_edge_length")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of super player config.
        """
        return pulumi.get(self, "name")


