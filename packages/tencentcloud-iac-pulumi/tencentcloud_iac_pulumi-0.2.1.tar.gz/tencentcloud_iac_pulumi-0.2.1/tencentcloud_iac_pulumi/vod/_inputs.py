# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AdaptiveDynamicStreamingTemplateStreamInfoArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs',
    'AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs',
    'ProcedureTemplateAiAnalysisTaskArgs',
    'ProcedureTemplateAiRecognitionTaskArgs',
    'ProcedureTemplateMediaProcessTaskArgs',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs',
    'ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs',
    'ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs',
    'ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs',
    'ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs',
    'ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs',
    'ProcedureTemplateReviewAudioVideoTaskArgs',
    'SuperPlayerConfigDrmStreamingInfoArgs',
    'SuperPlayerConfigResolutionNameArgs',
    'TranscodeTemplateAudioTemplateArgs',
    'TranscodeTemplateTehdConfigArgs',
    'TranscodeTemplateVideoTemplateArgs',
    'WatermarkTemplateImageTemplateArgs',
    'WatermarkTemplateSvgTemplateArgs',
    'WatermarkTemplateTextTemplateArgs',
]

@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoArgs:
    def __init__(__self__, *,
                 audio: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs'],
                 video: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs'],
                 remove_audio: Optional[pulumi.Input[bool]] = None,
                 remove_video: Optional[pulumi.Input[bool]] = None,
                 tehd_config: Optional[pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs']] = None):
        """
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs'] audio: Audio parameter information.
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs'] video: Video parameter information.
        :param pulumi.Input[bool] remove_audio: Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
        :param pulumi.Input[bool] remove_video: Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
        :param pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs'] tehd_config: Extremely fast HD transcoding parameters.
        """
        pulumi.set(__self__, "audio", audio)
        pulumi.set(__self__, "video", video)
        if remove_audio is not None:
            pulumi.set(__self__, "remove_audio", remove_audio)
        if remove_video is not None:
            pulumi.set(__self__, "remove_video", remove_video)
        if tehd_config is not None:
            pulumi.set(__self__, "tehd_config", tehd_config)

    @property
    @pulumi.getter
    def audio(self) -> pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs']:
        """
        Audio parameter information.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs']):
        pulumi.set(self, "audio", value)

    @property
    @pulumi.getter
    def video(self) -> pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs']:
        """
        Video parameter information.
        """
        return pulumi.get(self, "video")

    @video.setter
    def video(self, value: pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs']):
        pulumi.set(self, "video", value)

    @property
    @pulumi.getter(name="removeAudio")
    def remove_audio(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
        """
        return pulumi.get(self, "remove_audio")

    @remove_audio.setter
    def remove_audio(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove_audio", value)

    @property
    @pulumi.getter(name="removeVideo")
    def remove_video(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
        """
        return pulumi.get(self, "remove_video")

    @remove_video.setter
    def remove_video(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove_video", value)

    @property
    @pulumi.getter(name="tehdConfig")
    def tehd_config(self) -> Optional[pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs']]:
        """
        Extremely fast HD transcoding parameters.
        """
        return pulumi.get(self, "tehd_config")

    @tehd_config.setter
    def tehd_config(self, value: Optional[pulumi.Input['AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs']]):
        pulumi.set(self, "tehd_config", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoAudioArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 sample_rate: pulumi.Input[int],
                 audio_channel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bitrate: Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
        :param pulumi.Input[str] codec: Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
        :param pulumi.Input[int] sample_rate: Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
        :param pulumi.Input[str] audio_channel: Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> pulumi.Input[int]:
        """
        Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[str]]:
        """
        Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audio_channel", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoTehdConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 max_video_bitrate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Extreme high-speed HD type, available values:
               - TEHD-100: super high definition-100th;
               - OFF: turn off Ultra High definition.
        :param pulumi.Input[int] max_video_bitrate: Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Extreme high-speed HD type, available values:
        - TEHD-100: super high definition-100th;
        - OFF: turn off Ultra High definition.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
        """
        return pulumi.get(self, "max_video_bitrate")

    @max_video_bitrate.setter
    def max_video_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_video_bitrate", value)


@pulumi.input_type
class AdaptiveDynamicStreamingTemplateStreamInfoVideoArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 fps: pulumi.Input[int],
                 codec_tag: Optional[pulumi.Input[str]] = None,
                 fill_type: Optional[pulumi.Input[str]] = None,
                 gop: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 preserve_hdr_switch: Optional[pulumi.Input[str]] = None,
                 resolution_adaptive: Optional[pulumi.Input[bool]] = None,
                 vcrf: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        :param pulumi.Input[str] codec: Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        :param pulumi.Input[int] fps: Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        :param pulumi.Input[str] codec_tag: Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
               - hvc1: stands for hvc1 tag;
               - hev1: stands for the hev1 tag;
               Default value: hvc1.
        :param pulumi.Input[str] fill_type: Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[int] gop: Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
        :param pulumi.Input[int] height: Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] preserve_hdr_switch: Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
               - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
               - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
               Default value: OFF.
        :param pulumi.Input[bool] resolution_adaptive: Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[int] vcrf: Video constant bit rate control factor, value range is [1,51].
               Note:
               - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
               - This field is required when the video stream encoding format is H.266. The recommended value is 28;
               - If there are no special requirements, it is not recommended to specify this parameter.
        :param pulumi.Input[int] width: Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if codec_tag is not None:
            pulumi.set(__self__, "codec_tag", codec_tag)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if preserve_hdr_switch is not None:
            pulumi.set(__self__, "preserve_hdr_switch", preserve_hdr_switch)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> pulumi.Input[int]:
        """
        Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: pulumi.Input[int]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter(name="codecTag")
    def codec_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
        - hvc1: stands for hvc1 tag;
        - hev1: stands for the hev1 tag;
        Default value: hvc1.
        """
        return pulumi.get(self, "codec_tag")

    @codec_tag.setter
    def codec_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec_tag", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="preserveHdrSwitch")
    def preserve_hdr_switch(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
        - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
        - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
        Default value: OFF.
        """
        return pulumi.get(self, "preserve_hdr_switch")

    @preserve_hdr_switch.setter
    def preserve_hdr_switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_hdr_switch", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[bool]]:
        """
        Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[pulumi.Input[int]]:
        """
        Video constant bit rate control factor, value range is [1,51].
        Note:
        - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
        - This field is required when the video stream encoding format is H.266. The recommended value is 28;
        - If there are no special requirements, it is not recommended to specify this parameter.
        """
        return pulumi.get(self, "vcrf")

    @vcrf.setter
    def vcrf(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcrf", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class ProcedureTemplateAiAnalysisTaskArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Video content analysis template ID.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[str]]:
        """
        Video content analysis template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class ProcedureTemplateAiRecognitionTaskArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Intelligent video recognition template ID.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[str]]:
        """
        Intelligent video recognition template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskArgs:
    def __init__(__self__, *,
                 adaptive_dynamic_streaming_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]]] = None,
                 animated_graphic_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]]] = None,
                 cover_by_snapshot_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]]] = None,
                 image_sprite_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]]] = None,
                 sample_snapshot_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]]] = None,
                 snapshot_by_time_offset_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]]] = None,
                 transcode_task_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]] adaptive_dynamic_streaming_task_lists: List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]] animated_graphic_task_lists: List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]] cover_by_snapshot_task_lists: List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]] image_sprite_task_lists: List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]] sample_snapshot_task_lists: List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]] snapshot_by_time_offset_task_lists: List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]] transcode_task_lists: List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        if adaptive_dynamic_streaming_task_lists is not None:
            pulumi.set(__self__, "adaptive_dynamic_streaming_task_lists", adaptive_dynamic_streaming_task_lists)
        if animated_graphic_task_lists is not None:
            pulumi.set(__self__, "animated_graphic_task_lists", animated_graphic_task_lists)
        if cover_by_snapshot_task_lists is not None:
            pulumi.set(__self__, "cover_by_snapshot_task_lists", cover_by_snapshot_task_lists)
        if image_sprite_task_lists is not None:
            pulumi.set(__self__, "image_sprite_task_lists", image_sprite_task_lists)
        if sample_snapshot_task_lists is not None:
            pulumi.set(__self__, "sample_snapshot_task_lists", sample_snapshot_task_lists)
        if snapshot_by_time_offset_task_lists is not None:
            pulumi.set(__self__, "snapshot_by_time_offset_task_lists", snapshot_by_time_offset_task_lists)
        if transcode_task_lists is not None:
            pulumi.set(__self__, "transcode_task_lists", transcode_task_lists)

    @property
    @pulumi.getter(name="adaptiveDynamicStreamingTaskLists")
    def adaptive_dynamic_streaming_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]]]:
        """
        List of adaptive bitrate streaming tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "adaptive_dynamic_streaming_task_lists")

    @adaptive_dynamic_streaming_task_lists.setter
    def adaptive_dynamic_streaming_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs']]]]):
        pulumi.set(self, "adaptive_dynamic_streaming_task_lists", value)

    @property
    @pulumi.getter(name="animatedGraphicTaskLists")
    def animated_graphic_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]]]:
        """
        List of animated image generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "animated_graphic_task_lists")

    @animated_graphic_task_lists.setter
    def animated_graphic_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs']]]]):
        pulumi.set(self, "animated_graphic_task_lists", value)

    @property
    @pulumi.getter(name="coverBySnapshotTaskLists")
    def cover_by_snapshot_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]]]:
        """
        List of cover generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "cover_by_snapshot_task_lists")

    @cover_by_snapshot_task_lists.setter
    def cover_by_snapshot_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs']]]]):
        pulumi.set(self, "cover_by_snapshot_task_lists", value)

    @property
    @pulumi.getter(name="imageSpriteTaskLists")
    def image_sprite_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]]]:
        """
        List of image sprite generating tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "image_sprite_task_lists")

    @image_sprite_task_lists.setter
    def image_sprite_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs']]]]):
        pulumi.set(self, "image_sprite_task_lists", value)

    @property
    @pulumi.getter(name="sampleSnapshotTaskLists")
    def sample_snapshot_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]]]:
        """
        List of sampled screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "sample_snapshot_task_lists")

    @sample_snapshot_task_lists.setter
    def sample_snapshot_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs']]]]):
        pulumi.set(self, "sample_snapshot_task_lists", value)

    @property
    @pulumi.getter(name="snapshotByTimeOffsetTaskLists")
    def snapshot_by_time_offset_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]]]:
        """
        List of time point screen capturing tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "snapshot_by_time_offset_task_lists")

    @snapshot_by_time_offset_task_lists.setter
    def snapshot_by_time_offset_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs']]]]):
        pulumi.set(self, "snapshot_by_time_offset_task_lists", value)

    @property
    @pulumi.getter(name="transcodeTaskLists")
    def transcode_task_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]]]:
        """
        List of transcoding tasks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "transcode_task_lists")

    @transcode_task_lists.setter
    def transcode_task_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs']]]]):
        pulumi.set(self, "transcode_task_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 subtitle_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Adaptive bitrate streaming template ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subtitle_lists: Subtitle list, element is subtitle ID, support multiple subtitles, up to 16.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if subtitle_lists is not None:
            pulumi.set(__self__, "subtitle_lists", subtitle_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Adaptive bitrate streaming template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="subtitleLists")
    def subtitle_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Subtitle list, element is subtitle ID, support multiple subtitles, up to 16.
        """
        return pulumi.get(self, "subtitle_lists")

    @subtitle_lists.setter
    def subtitle_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subtitle_lists", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: pulumi.Input[float],
                 start_time_offset: pulumi.Input[float]):
        """
        :param pulumi.Input[str] definition: Animated image generating template ID.
        :param pulumi.Input[float] end_time_offset: End time of animated image in video in seconds.
        :param pulumi.Input[float] start_time_offset: Start time of animated image in video in seconds.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Animated image generating template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> pulumi.Input[float]:
        """
        End time of animated image in video in seconds.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> pulumi.Input[float]:
        """
        Start time of animated image in video in seconds.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: pulumi.Input[float]):
        pulumi.set(self, "start_time_offset", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 position_type: pulumi.Input[str],
                 position_value: pulumi.Input[float],
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Time point screen capturing template ID.
        :param pulumi.Input[str] position_type: Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        :param pulumi.Input[float] position_value: Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "position_type", position_type)
        pulumi.set(__self__, "position_value", position_value)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Time point screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="positionType")
    def position_type(self) -> pulumi.Input[str]:
        """
        Screen capturing mode. Valid values: `Time`, `Percent`. `Time`: screen captures by time point, `Percent`: screen captures by percentage.
        """
        return pulumi.get(self, "position_type")

    @position_type.setter
    def position_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "position_type", value)

    @property
    @pulumi.getter(name="positionValue")
    def position_value(self) -> pulumi.Input[float]:
        """
        Screenshot position: For time point screen capturing, this means to take a screenshot at a specified time point (in seconds) and use it as the cover. For percentage screen capturing, this value means to take a screenshot at a specified percentage of the video duration and use it as the cover.
        """
        return pulumi.get(self, "position_value")

    @position_value.setter
    def position_value(self, value: pulumi.Input[float]):
        pulumi.set(self, "position_value", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskImageSpriteTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] definition: Image sprite generating template ID.
        """
        pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Image sprite generating template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Sampled screen capturing template ID.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Sampled screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 ext_time_offset_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_offset_lists: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None,
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Time point screen capturing template ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ext_time_offset_lists: The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] time_offset_lists: List of time points for screencapturing in milliseconds. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if ext_time_offset_lists is not None:
            pulumi.set(__self__, "ext_time_offset_lists", ext_time_offset_lists)
        if time_offset_lists is not None:
            pulumi.set(__self__, "time_offset_lists", time_offset_lists)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Time point screen capturing template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="extTimeOffsetLists")
    def ext_time_offset_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of screenshot time points. `s` and `%` formats are supported: When a time point string ends with `s`, its unit is second. For example, `3.5s` means the 3.5th second of the video; When a time point string ends with `%`, it is marked with corresponding percentage of the video duration. For example, `10%` means that the time point is at the 10% of the video entire duration.
        """
        return pulumi.get(self, "ext_time_offset_lists")

    @ext_time_offset_lists.setter
    def ext_time_offset_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ext_time_offset_lists", value)

    @property
    @pulumi.getter(name="timeOffsetLists")
    def time_offset_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]:
        """
        List of time points for screencapturing in milliseconds. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "time_offset_lists")

    @time_offset_lists.setter
    def time_offset_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]):
        pulumi.set(self, "time_offset_lists", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 copy_right_watermark: Optional[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs']] = None,
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 head_tail_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs']]]] = None,
                 mosaic_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 trace_watermark: Optional[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs']] = None,
                 watermark_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]]] = None):
        """
        :param pulumi.Input[str] definition: Video transcoding template ID.
        :param pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs'] copy_right_watermark: opyright watermark.
        :param pulumi.Input[float] end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs']]] head_tail_lists: List of video opening/closing credits configuration template IDs. You can enter up to 10 IDs.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]] mosaic_lists: List of blurs. Up to 10 ones can be supported.
        :param pulumi.Input[float] start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs'] trace_watermark: Digital watermark.
        :param pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]] watermark_lists: List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if copy_right_watermark is not None:
            pulumi.set(__self__, "copy_right_watermark", copy_right_watermark)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if head_tail_lists is not None:
            pulumi.set(__self__, "head_tail_lists", head_tail_lists)
        if mosaic_lists is not None:
            pulumi.set(__self__, "mosaic_lists", mosaic_lists)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if trace_watermark is not None:
            pulumi.set(__self__, "trace_watermark", trace_watermark)
        if watermark_lists is not None:
            pulumi.set(__self__, "watermark_lists", watermark_lists)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Video transcoding template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="copyRightWatermark")
    def copy_right_watermark(self) -> Optional[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs']]:
        """
        opyright watermark.
        """
        return pulumi.get(self, "copy_right_watermark")

    @copy_right_watermark.setter
    def copy_right_watermark(self, value: Optional[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs']]):
        pulumi.set(self, "copy_right_watermark", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="headTailLists")
    def head_tail_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs']]]]:
        """
        List of video opening/closing credits configuration template IDs. You can enter up to 10 IDs.
        """
        return pulumi.get(self, "head_tail_lists")

    @head_tail_lists.setter
    def head_tail_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs']]]]):
        pulumi.set(self, "head_tail_lists", value)

    @property
    @pulumi.getter(name="mosaicLists")
    def mosaic_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]]]:
        """
        List of blurs. Up to 10 ones can be supported.
        """
        return pulumi.get(self, "mosaic_lists")

    @mosaic_lists.setter
    def mosaic_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs']]]]):
        pulumi.set(self, "mosaic_lists", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="traceWatermark")
    def trace_watermark(self) -> Optional[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs']]:
        """
        Digital watermark.
        """
        return pulumi.get(self, "trace_watermark")

    @trace_watermark.setter
    def trace_watermark(self, value: Optional[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs']]):
        pulumi.set(self, "trace_watermark", value)

    @property
    @pulumi.getter(name="watermarkLists")
    def watermark_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]]]:
        """
        List of up to `10` image or text watermarks. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "watermark_lists")

    @watermark_lists.setter
    def watermark_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs']]]]):
        pulumi.set(self, "watermark_lists", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListCopyRightWatermarkArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: Copyright information, maximum length is 200 characters.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Copyright information, maximum length is 200 characters.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListHeadTailListArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Video opening/closing credits configuration template ID.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[str]]:
        """
        Video opening/closing credits configuration template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicListArgs:
    def __init__(__self__, *,
                 coordinate_origin: Optional[pulumi.Input[str]] = None,
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 height: Optional[pulumi.Input[str]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 width: Optional[pulumi.Input[str]] = None,
                 x_pos: Optional[pulumi.Input[str]] = None,
                 y_pos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] coordinate_origin: Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
        :param pulumi.Input[float] end_time_offset: End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        :param pulumi.Input[str] height: Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
        :param pulumi.Input[float] start_time_offset: Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        :param pulumi.Input[str] width: Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
        :param pulumi.Input[str] x_pos: The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
        :param pulumi.Input[str] y_pos: Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
        """
        if coordinate_origin is not None:
            pulumi.set(__self__, "coordinate_origin", coordinate_origin)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter(name="coordinateOrigin")
    def coordinate_origin(self) -> Optional[pulumi.Input[str]]:
        """
        Origin position, which currently can only be: `TopLeft`: the origin of coordinates is in the top-left corner of the video, and the origin of the blur is in the top-left corner of the image or text. Default value: TopLeft.
        """
        return pulumi.get(self, "coordinate_origin")

    @coordinate_origin.setter
    def coordinate_origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coordinate_origin", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will exist till the last video frame; If this value is greater than `0` (e.g., n), the blur will exist till second n; If this value is smaller than `0` (e.g., -n), the blur will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        Blur height. `%` and `px` formats are supported: If the string ends in `%`, the `height` of the blur will be the specified percentage of the video height; for example, 10% means that Height is 10% of the video height; If the string ends in `px`, the `height` of the blur will be in px; for example, 100px means that Height is 100 px. Default value: `10%`.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of blur in seconds. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame. If this parameter is left empty or `0` is entered, the blur will appear upon the first video frame; If this value is greater than `0` (e.g., n), the blur will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the blur will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        Blur width. `%` and `px` formats are supported: If the string ends in `%`, the `width` of the blur will be the specified percentage of the video width; for example, 10% means that `width` is 10% of the video width; If the string ends in `px`, the `width` of the blur will be in px; for example, 100px means that Width is 100 px. Default value: `10%`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal position of the origin of the blur relative to the origin of coordinates of the video. `%` and `px` formats are supported: If the string ends in `%`, the XPos of the blur will be the specified percentage of the video width; for example, 10% means that XPos is 10% of the video width; If the string ends in `px`, the XPos of the blur will be the specified px; for example, 100px means that XPos is 100 px. Default value: `0px`.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[str]]:
        """
        Vertical position of the origin of blur relative to the origin of coordinates of video. `%` and `px` formats are supported: If the string ends in `%`, the YPos of the blur will be the specified percentage of the video height; for example, 10% means that YPos is 10% of the video height; If the string ends in `px`, the YPos of the blur will be the specified px; for example, 100px means that YPos is 100 px. Default value: `0px`.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListTraceWatermarkArgs:
    def __init__(__self__, *,
                 switch: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] switch: Whether to use digital watermarks. This parameter is required. Valid values: ON, OFF.
        """
        if switch is not None:
            pulumi.set(__self__, "switch", switch)

    @property
    @pulumi.getter
    def switch(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use digital watermarks. This parameter is required. Valid values: ON, OFF.
        """
        return pulumi.get(self, "switch")

    @switch.setter
    def switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "switch", value)


@pulumi.input_type
class ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkListArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[float]] = None,
                 start_time_offset: Optional[pulumi.Input[float]] = None,
                 svg_content: Optional[pulumi.Input[str]] = None,
                 text_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] definition: Watermarking template ID.
        :param pulumi.Input[float] end_time_offset: End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        :param pulumi.Input[float] start_time_offset: Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        :param pulumi.Input[str] svg_content: SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[str] text_content: Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        pulumi.set(__self__, "definition", definition)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)
        if svg_content is not None:
            pulumi.set(__self__, "svg_content", svg_content)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Watermarking template ID.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        End time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will exist till the last video frame; If this value is greater than `0` (e.g., n), the watermark will exist till second n; If this value is smaller than `0` (e.g., -n), the watermark will exist till second n before the last video frame.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[float]]:
        """
        Start time offset of a watermark in seconds. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame. If this parameter is left blank or `0` is entered, the watermark will appear upon the first video frame; If this value is greater than `0` (e.g., n), the watermark will appear at second n after the first video frame; If this value is smaller than `0` (e.g., -n), the watermark will appear at second n before the last video frame.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="svgContent")
    def svg_content(self) -> Optional[pulumi.Input[str]]:
        """
        SVG content of up to `2000000` characters. This needs to be entered only when the watermark type is `SVG`. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "svg_content")

    @svg_content.setter
    def svg_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svg_content", value)

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[pulumi.Input[str]]:
        """
        Text content of up to `100` characters. This needs to be entered only when the watermark type is text. Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "text_content")

    @text_content.setter
    def text_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_content", value)


@pulumi.input_type
class ProcedureTemplateReviewAudioVideoTaskArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[str]] = None,
                 review_contents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] definition: Review template.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] review_contents: The type of moderated content. Valid values:
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)
        if review_contents is not None:
            pulumi.set(__self__, "review_contents", review_contents)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[str]]:
        """
        Review template.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="reviewContents")
    def review_contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The type of moderated content. Valid values:
        """
        return pulumi.get(self, "review_contents")

    @review_contents.setter
    def review_contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "review_contents", value)


@pulumi.input_type
class SuperPlayerConfigDrmStreamingInfoArgs:
    def __init__(__self__, *,
                 simple_aes_definition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] simple_aes_definition: ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        if simple_aes_definition is not None:
            pulumi.set(__self__, "simple_aes_definition", simple_aes_definition)

    @property
    @pulumi.getter(name="simpleAesDefinition")
    def simple_aes_definition(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the adaptive dynamic streaming template whose protection type is `SimpleAES`.
        """
        return pulumi.get(self, "simple_aes_definition")

    @simple_aes_definition.setter
    def simple_aes_definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "simple_aes_definition", value)


@pulumi.input_type
class SuperPlayerConfigResolutionNameArgs:
    def __init__(__self__, *,
                 min_edge_length: pulumi.Input[int],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[int] min_edge_length: Length of video short side in px.
        :param pulumi.Input[str] name: Display name.
        """
        pulumi.set(__self__, "min_edge_length", min_edge_length)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="minEdgeLength")
    def min_edge_length(self) -> pulumi.Input[int]:
        """
        Length of video short side in px.
        """
        return pulumi.get(self, "min_edge_length")

    @min_edge_length.setter
    def min_edge_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_edge_length", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Display name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class TranscodeTemplateAudioTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 sample_rate: pulumi.Input[int],
                 audio_channel: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
        :param pulumi.Input[str] codec: The audio codec.If `Container` is `mp3`, the valid value is:`libmp3lame`If `Container` is `ogg` or `flac`, the valid value is:`flac`If `Container` is `m4a`, the valid values are:`libfdk_aac``libmp3lame``ac3`If `Container` is `mp4` or `flv`, the valid values are:`libfdk_aac` (Recommended for MP4)`libmp3lame` (Recommended for FLV)`mp2`If `Container` is `hls`, the valid value is:`libfdk_aac`If `Format` is `HLS` or `MPEG-DASH`, the valid value is:`libfdk_aac`If `Container` is `wav`, the valid value is:`pcm16`.
        :param pulumi.Input[int] sample_rate: The audio sample rate. Valid values:`16000` (valid only if `Codec` is `pcm16`)`32000``44100``48000`Unit: Hz.
        :param pulumi.Input[int] audio_channel: Audio channel system. Valid values:1: mono-channel2: dual-channel6: stereoYou cannot set the sound channel as stereo for media files in container formats for audios (FLAC, OGG, MP3, M4A).Default value: 2.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "sample_rate", sample_rate)
        if audio_channel is not None:
            pulumi.set(__self__, "audio_channel", audio_channel)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Audio stream bitrate in Kbps. Value range: 0 and [26, 256].If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        The audio codec.If `Container` is `mp3`, the valid value is:`libmp3lame`If `Container` is `ogg` or `flac`, the valid value is:`flac`If `Container` is `m4a`, the valid values are:`libfdk_aac``libmp3lame``ac3`If `Container` is `mp4` or `flv`, the valid values are:`libfdk_aac` (Recommended for MP4)`libmp3lame` (Recommended for FLV)`mp2`If `Container` is `hls`, the valid value is:`libfdk_aac`If `Format` is `HLS` or `MPEG-DASH`, the valid value is:`libfdk_aac`If `Container` is `wav`, the valid value is:`pcm16`.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> pulumi.Input[int]:
        """
        The audio sample rate. Valid values:`16000` (valid only if `Codec` is `pcm16`)`32000``44100``48000`Unit: Hz.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: pulumi.Input[int]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="audioChannel")
    def audio_channel(self) -> Optional[pulumi.Input[int]]:
        """
        Audio channel system. Valid values:1: mono-channel2: dual-channel6: stereoYou cannot set the sound channel as stereo for media files in container formats for audios (FLAC, OGG, MP3, M4A).Default value: 2.
        """
        return pulumi.get(self, "audio_channel")

    @audio_channel.setter
    def audio_channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "audio_channel", value)


@pulumi.input_type
class TranscodeTemplateTehdConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 max_video_bitrate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: TESHD transcoding type. Valid values: TEHD-100, OFF (default).
        :param pulumi.Input[int] max_video_bitrate: Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left blank or 0 is entered, there will be no upper limit for bitrate.
        """
        pulumi.set(__self__, "type", type)
        if max_video_bitrate is not None:
            pulumi.set(__self__, "max_video_bitrate", max_video_bitrate)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        TESHD transcoding type. Valid values: TEHD-100, OFF (default).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="maxVideoBitrate")
    def max_video_bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum bitrate, which is valid when `Type` is `TESHD`.If this parameter is left blank or 0 is entered, there will be no upper limit for bitrate.
        """
        return pulumi.get(self, "max_video_bitrate")

    @max_video_bitrate.setter
    def max_video_bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_video_bitrate", value)


@pulumi.input_type
class TranscodeTemplateVideoTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[int],
                 codec: pulumi.Input[str],
                 fps: pulumi.Input[int],
                 codec_tag: Optional[pulumi.Input[str]] = None,
                 fill_type: Optional[pulumi.Input[str]] = None,
                 gop: Optional[pulumi.Input[int]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 preserve_hdr_switch: Optional[pulumi.Input[str]] = None,
                 resolution_adaptive: Optional[pulumi.Input[str]] = None,
                 vcrf: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bitrate: Bitrate of video stream in Kbps. Value range: 0 and [128, 35,000].If the value is 0, the bitrate of the video will be the same as that of the source video.
        :param pulumi.Input[str] codec: The video codec. Valid values:libx264: H.264; libx265: H.265; av1: AOMedia Video 1; H.266: H.266. The AOMedia Video 1 and H.266 codecs can only be used for MP4 files. Only CRF is supported for H.266 currently.
        :param pulumi.Input[int] fps: Video frame rate in Hz. Value range: [0,100].If the value is 0, the frame rate will be the same as that of the source video.
        :param pulumi.Input[str] codec_tag: The codec tag. This parameter is valid only if the H.265 codec is used. Valid values:hvc1hev1Default value: hvc1.
        :param pulumi.Input[str] fill_type: Fill type, the way of processing a screenshot when the configured aspect ratio is different from that of the source video. Valid values:stretch: stretches the video image frame by frame to fill the screen. The video image may become squashed or stretched after transcoding.black: fills the uncovered area with black color, without changing the image&#39;s aspect ratio.white: fills the uncovered area with white color, without changing the image&#39;s aspect ratio.gauss: applies Gaussian blur to the uncovered area, without changing the image&#39;s aspect ratio.Default value: black.
        :param pulumi.Input[int] gop: I-frame interval in frames. Valid values: 0 and 1-100000.When this parameter is set to 0 or left empty, `Gop` will be automatically set.
        :param pulumi.Input[int] height: The maximum video height (or short side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        :param pulumi.Input[str] preserve_hdr_switch: Whether to output an HDR (high dynamic range) video if the source video is HDR. Valid values:ON: If the source video is HDR, output an HDR video; if not, output an SDR (standard dynamic range) video.OFF: Output an SDR video regardless of whether the source video is HDR.Default value: OFF.
        :param pulumi.Input[str] resolution_adaptive: Resolution adaption. Valid values:open: enabled. In this case, `Width` represents the long side of a video, while `Height` the short side;close: disabled. In this case, `Width` represents the width of a video, while `Height` the height.Default value: open.Note: this field may return null, indicating that no valid values can be obtained.
        :param pulumi.Input[int] vcrf: The video constant rate factor (CRF). Value range: 1-51.If this parameter is specified, CRF encoding will be used and the bitrate parameter will be ignored.If `Codec` is `H.266`, this parameter is required (`28` is recommended).We don't recommend using this parameter unless you have special requirements.
        :param pulumi.Input[int] width: The maximum video width (or long side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "codec", codec)
        pulumi.set(__self__, "fps", fps)
        if codec_tag is not None:
            pulumi.set(__self__, "codec_tag", codec_tag)
        if fill_type is not None:
            pulumi.set(__self__, "fill_type", fill_type)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if preserve_hdr_switch is not None:
            pulumi.set(__self__, "preserve_hdr_switch", preserve_hdr_switch)
        if resolution_adaptive is not None:
            pulumi.set(__self__, "resolution_adaptive", resolution_adaptive)
        if vcrf is not None:
            pulumi.set(__self__, "vcrf", vcrf)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[int]:
        """
        Bitrate of video stream in Kbps. Value range: 0 and [128, 35,000].If the value is 0, the bitrate of the video will be the same as that of the source video.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[int]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def codec(self) -> pulumi.Input[str]:
        """
        The video codec. Valid values:libx264: H.264; libx265: H.265; av1: AOMedia Video 1; H.266: H.266. The AOMedia Video 1 and H.266 codecs can only be used for MP4 files. Only CRF is supported for H.266 currently.
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: pulumi.Input[str]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter
    def fps(self) -> pulumi.Input[int]:
        """
        Video frame rate in Hz. Value range: [0,100].If the value is 0, the frame rate will be the same as that of the source video.
        """
        return pulumi.get(self, "fps")

    @fps.setter
    def fps(self, value: pulumi.Input[int]):
        pulumi.set(self, "fps", value)

    @property
    @pulumi.getter(name="codecTag")
    def codec_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The codec tag. This parameter is valid only if the H.265 codec is used. Valid values:hvc1hev1Default value: hvc1.
        """
        return pulumi.get(self, "codec_tag")

    @codec_tag.setter
    def codec_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec_tag", value)

    @property
    @pulumi.getter(name="fillType")
    def fill_type(self) -> Optional[pulumi.Input[str]]:
        """
        Fill type, the way of processing a screenshot when the configured aspect ratio is different from that of the source video. Valid values:stretch: stretches the video image frame by frame to fill the screen. The video image may become squashed or stretched after transcoding.black: fills the uncovered area with black color, without changing the image&#39;s aspect ratio.white: fills the uncovered area with white color, without changing the image&#39;s aspect ratio.gauss: applies Gaussian blur to the uncovered area, without changing the image&#39;s aspect ratio.Default value: black.
        """
        return pulumi.get(self, "fill_type")

    @fill_type.setter
    def fill_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_type", value)

    @property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[int]]:
        """
        I-frame interval in frames. Valid values: 0 and 1-100000.When this parameter is set to 0 or left empty, `Gop` will be automatically set.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gop", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum video height (or short side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="preserveHdrSwitch")
    def preserve_hdr_switch(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to output an HDR (high dynamic range) video if the source video is HDR. Valid values:ON: If the source video is HDR, output an HDR video; if not, output an SDR (standard dynamic range) video.OFF: Output an SDR video regardless of whether the source video is HDR.Default value: OFF.
        """
        return pulumi.get(self, "preserve_hdr_switch")

    @preserve_hdr_switch.setter
    def preserve_hdr_switch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preserve_hdr_switch", value)

    @property
    @pulumi.getter(name="resolutionAdaptive")
    def resolution_adaptive(self) -> Optional[pulumi.Input[str]]:
        """
        Resolution adaption. Valid values:open: enabled. In this case, `Width` represents the long side of a video, while `Height` the short side;close: disabled. In this case, `Width` represents the width of a video, while `Height` the height.Default value: open.Note: this field may return null, indicating that no valid values can be obtained.
        """
        return pulumi.get(self, "resolution_adaptive")

    @resolution_adaptive.setter
    def resolution_adaptive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_adaptive", value)

    @property
    @pulumi.getter
    def vcrf(self) -> Optional[pulumi.Input[int]]:
        """
        The video constant rate factor (CRF). Value range: 1-51.If this parameter is specified, CRF encoding will be used and the bitrate parameter will be ignored.If `Codec` is `H.266`, this parameter is required (`28` is recommended).We don't recommend using this parameter unless you have special requirements.
        """
        return pulumi.get(self, "vcrf")

    @vcrf.setter
    def vcrf(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcrf", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum video width (or long side) in pixels. Value range: 0 and [128, 8192].If both `Width` and `Height` are 0, the output resolution will be the same as that of the source video.If `Width` is 0 and `Height` is not, the video width will be proportionally scaled.If `Width` is not 0 and `Height` is, the video height will be proportionally scaled.If neither `Width` nor `Height` is 0, the specified width and height will be used.Default value: 0.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WatermarkTemplateImageTemplateArgs:
    def __init__(__self__, *,
                 image_content: pulumi.Input[str],
                 height: Optional[pulumi.Input[str]] = None,
                 repeat_type: Optional[pulumi.Input[str]] = None,
                 transparency: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_content: The [Base64](https://tools.ietf.org/html/rfc4648) encoded string of a watermark image. Only JPEG, PNG, and GIF images are supported.
        :param pulumi.Input[str] height: Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;  If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px. Valid values: 0 or [8,4096]. Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
        :param pulumi.Input[str] repeat_type: Repeat type of an animated watermark. Valid values: once: no longer appears after watermark playback ends.  repeat_last_frame: stays on the last frame after watermark playback ends.  repeat (default): repeats the playback until the video ends.
        :param pulumi.Input[int] transparency: Image watermark transparency: 0: completely opaque  100: completely transparent Default value: 0.
        :param pulumi.Input[str] width: Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width. For example, `10%` means that `Width` is 10% of the video width;  If the string ends in px, the `Width` of the watermark will be in pixels. For example, `100px` means that `Width` is 100 pixels. Value range: [8, 4096]. Default value: 10%.
        """
        pulumi.set(__self__, "image_content", image_content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if repeat_type is not None:
            pulumi.set(__self__, "repeat_type", repeat_type)
        if transparency is not None:
            pulumi.set(__self__, "transparency", transparency)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter(name="imageContent")
    def image_content(self) -> pulumi.Input[str]:
        """
        The [Base64](https://tools.ietf.org/html/rfc4648) encoded string of a watermark image. Only JPEG, PNG, and GIF images are supported.
        """
        return pulumi.get(self, "image_content")

    @image_content.setter
    def image_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark height. % and px formats are supported: If the string ends in %, the `Height` of the watermark will be the specified percentage of the video height; for example, `10%` means that `Height` is 10% of the video height;  If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px. Valid values: 0 or [8,4096]. Default value: 0 px, which means that `Height` will be proportionally scaled according to the aspect ratio of the original watermark image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="repeatType")
    def repeat_type(self) -> Optional[pulumi.Input[str]]:
        """
        Repeat type of an animated watermark. Valid values: once: no longer appears after watermark playback ends.  repeat_last_frame: stays on the last frame after watermark playback ends.  repeat (default): repeats the playback until the video ends.
        """
        return pulumi.get(self, "repeat_type")

    @repeat_type.setter
    def repeat_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_type", value)

    @property
    @pulumi.getter
    def transparency(self) -> Optional[pulumi.Input[int]]:
        """
        Image watermark transparency: 0: completely opaque  100: completely transparent Default value: 0.
        """
        return pulumi.get(self, "transparency")

    @transparency.setter
    def transparency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transparency", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark width. % and px formats are supported: If the string ends in %, the `Width` of the watermark will be the specified percentage of the video width. For example, `10%` means that `Width` is 10% of the video width;  If the string ends in px, the `Width` of the watermark will be in pixels. For example, `100px` means that `Width` is 100 pixels. Value range: [8, 4096]. Default value: 10%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WatermarkTemplateSvgTemplateArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] height: Watermark height, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px; if `0px` is entered and `Width` is not `0px`, the watermark height will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark height will be the height of the source SVG image;  If the string ends in `W%`, the `Height` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Height` is 10% of the video width;  If the string ends in `H%`, the `Height` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Height` is 10% of the video height;  If the string ends in `S%`, the `Height` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Height` is 10% of the short side of the video;  If the string ends in `L%`, the `Height` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Height` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `H%`. Default value: 0 px.
        :param pulumi.Input[str] width: Watermark width, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px; if `0px` is entered and `Height` is not `0px`, the watermark width will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark width will be the width of the source SVG image;  If the string ends in `W%`, the `Width` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Width` is 10% of the video width;  If the string ends in `H%`, the `Width` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Width` is 10% of the video height;  If the string ends in `S%`, the `Width` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Width` is 10% of the short side of the video;  If the string ends in `L%`, the `Width` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Width` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `W%`. Default value: 10W%.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark height, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Height` of the watermark will be in px; for example, `100px` means that `Height` is 100 px; if `0px` is entered and `Width` is not `0px`, the watermark height will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark height will be the height of the source SVG image;  If the string ends in `W%`, the `Height` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Height` is 10% of the video width;  If the string ends in `H%`, the `Height` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Height` is 10% of the video height;  If the string ends in `S%`, the `Height` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Height` is 10% of the short side of the video;  If the string ends in `L%`, the `Height` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Height` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `H%`. Default value: 0 px.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[str]]:
        """
        Watermark width, which supports six formats of px, %, W%, H%, S%, and L%: If the string ends in px, the `Width` of the watermark will be in px; for example, `100px` means that `Width` is 100 px; if `0px` is entered and `Height` is not `0px`, the watermark width will be proportionally scaled based on the source SVG image; if `0px` is entered for both `Width` and `Height`, the watermark width will be the width of the source SVG image;  If the string ends in `W%`, the `Width` of the watermark will be the specified percentage of the video width; for example, `10W%` means that `Width` is 10% of the video width;  If the string ends in `H%`, the `Width` of the watermark will be the specified percentage of the video height; for example, `10H%` means that `Width` is 10% of the video height;  If the string ends in `S%`, the `Width` of the watermark will be the specified percentage of the short side of the video; for example, `10S%` means that `Width` is 10% of the short side of the video;  If the string ends in `L%`, the `Width` of the watermark will be the specified percentage of the long side of the video; for example, `10L%` means that `Width` is 10% of the long side of the video;  If the string ends in %, the meaning is the same as `W%`. Default value: 10W%.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class WatermarkTemplateTextTemplateArgs:
    def __init__(__self__, *,
                 font_alpha: pulumi.Input[float],
                 font_color: pulumi.Input[str],
                 font_size: pulumi.Input[str],
                 font_type: pulumi.Input[str]):
        """
        :param pulumi.Input[float] font_alpha: Text transparency. Value range: (0, 1] 0: completely transparent  1: completely opaque Default value: 1.
        :param pulumi.Input[str] font_color: Font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).
        :param pulumi.Input[str] font_size: Font size in Npx format where N is a numeric value.
        :param pulumi.Input[str] font_type: Font type. Currently, two types are supported: simkai.ttf: both Chinese and English are supported;  arial.ttf: only English is supported.
        """
        pulumi.set(__self__, "font_alpha", font_alpha)
        pulumi.set(__self__, "font_color", font_color)
        pulumi.set(__self__, "font_size", font_size)
        pulumi.set(__self__, "font_type", font_type)

    @property
    @pulumi.getter(name="fontAlpha")
    def font_alpha(self) -> pulumi.Input[float]:
        """
        Text transparency. Value range: (0, 1] 0: completely transparent  1: completely opaque Default value: 1.
        """
        return pulumi.get(self, "font_alpha")

    @font_alpha.setter
    def font_alpha(self, value: pulumi.Input[float]):
        pulumi.set(self, "font_alpha", value)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> pulumi.Input[str]:
        """
        Font color in 0xRRGGBB format. Default value: 0xFFFFFF (white).
        """
        return pulumi.get(self, "font_color")

    @font_color.setter
    def font_color(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> pulumi.Input[str]:
        """
        Font size in Npx format where N is a numeric value.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> pulumi.Input[str]:
        """
        Font type. Currently, two types are supported: simkai.ttf: both Chinese and English are supported;  arial.ttf: only English is supported.
        """
        return pulumi.get(self, "font_type")

    @font_type.setter
    def font_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "font_type", value)


