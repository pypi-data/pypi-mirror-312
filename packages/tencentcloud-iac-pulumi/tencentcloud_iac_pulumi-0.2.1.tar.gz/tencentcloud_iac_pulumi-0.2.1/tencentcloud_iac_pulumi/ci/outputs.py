# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'MediaAnimationTemplateContainer',
    'MediaAnimationTemplateTimeInterval',
    'MediaAnimationTemplateVideo',
    'MediaConcatTemplateConcatTemplate',
    'MediaConcatTemplateConcatTemplateAudio',
    'MediaConcatTemplateConcatTemplateAudioMix',
    'MediaConcatTemplateConcatTemplateAudioMixEffectConfig',
    'MediaConcatTemplateConcatTemplateConcatFragment',
    'MediaConcatTemplateConcatTemplateContainer',
    'MediaConcatTemplateConcatTemplateVideo',
    'MediaPicProcessTemplatePicProcess',
    'MediaSmartCoverTemplateSmartCover',
    'MediaSnapshotTemplateSnapshot',
    'MediaSnapshotTemplateSnapshotSpriteSnapshotConfig',
    'MediaSpeechRecognitionTemplateSpeechRecognition',
    'MediaTranscodeProTemplateAudio',
    'MediaTranscodeProTemplateContainer',
    'MediaTranscodeProTemplateContainerClipConfig',
    'MediaTranscodeProTemplateTimeInterval',
    'MediaTranscodeProTemplateTransConfig',
    'MediaTranscodeProTemplateVideo',
    'MediaTranscodeTemplateAudio',
    'MediaTranscodeTemplateAudioMix',
    'MediaTranscodeTemplateAudioMixEffectConfig',
    'MediaTranscodeTemplateContainer',
    'MediaTranscodeTemplateContainerClipConfig',
    'MediaTranscodeTemplateTimeInterval',
    'MediaTranscodeTemplateTransConfig',
    'MediaTranscodeTemplateTransConfigHlsEncrypt',
    'MediaTranscodeTemplateVideo',
    'MediaVideoMontageTemplateAudio',
    'MediaVideoMontageTemplateAudioMix',
    'MediaVideoMontageTemplateAudioMixEffectConfig',
    'MediaVideoMontageTemplateContainer',
    'MediaVideoMontageTemplateVideo',
    'MediaVideoProcessTemplateColorEnhance',
    'MediaVideoProcessTemplateMsSharpen',
    'MediaVoiceSeparateTemplateAudioConfig',
    'MediaWatermarkTemplateWatermark',
    'MediaWatermarkTemplateWatermarkImage',
    'MediaWatermarkTemplateWatermarkText',
]

@pulumi.output_type
class MediaAnimationTemplateContainer(dict):
    def __init__(__self__, *,
                 format: str):
        """
        :param str format: Package format.
        """
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Package format.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class MediaAnimationTemplateTimeInterval(dict):
    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 start: Optional[str] = None):
        """
        :param str duration: duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param str start: Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class MediaAnimationTemplateVideo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "animateFramesPerSecond":
            suggest = "animate_frames_per_second"
        elif key == "animateOnlyKeepKeyFrame":
            suggest = "animate_only_keep_key_frame"
        elif key == "animateTimeIntervalOfFrame":
            suggest = "animate_time_interval_of_frame"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaAnimationTemplateVideo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaAnimationTemplateVideo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaAnimationTemplateVideo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: str,
                 animate_frames_per_second: Optional[str] = None,
                 animate_only_keep_key_frame: Optional[str] = None,
                 animate_time_interval_of_frame: Optional[str] = None,
                 fps: Optional[str] = None,
                 height: Optional[str] = None,
                 quality: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str codec: Codec format `gif`, `webp`.
        :param str animate_frames_per_second: Animation per second frame number, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        :param str animate_only_keep_key_frame: GIFs are kept only Keyframe, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        :param str animate_time_interval_of_frame: Animation frame extraction every time, (0, video duration], Animation frame extraction time interval, If TimeInterval.Duration is set, it is less than this value.
        :param str fps: Frame rate, value range: (0, 60], Unit: fps.
        :param str height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param str quality: Set relative quality, [1, 100), webp image quality setting takes effect, gif has no quality parameter.
        :param str width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        pulumi.set(__self__, "codec", codec)
        if animate_frames_per_second is not None:
            pulumi.set(__self__, "animate_frames_per_second", animate_frames_per_second)
        if animate_only_keep_key_frame is not None:
            pulumi.set(__self__, "animate_only_keep_key_frame", animate_only_keep_key_frame)
        if animate_time_interval_of_frame is not None:
            pulumi.set(__self__, "animate_time_interval_of_frame", animate_time_interval_of_frame)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format `gif`, `webp`.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="animateFramesPerSecond")
    def animate_frames_per_second(self) -> Optional[str]:
        """
        Animation per second frame number, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        """
        return pulumi.get(self, "animate_frames_per_second")

    @property
    @pulumi.getter(name="animateOnlyKeepKeyFrame")
    def animate_only_keep_key_frame(self) -> Optional[str]:
        """
        GIFs are kept only Keyframe, Priority: AnimateFramesPerSecond &gt; AnimateOnlyKeepKeyFrame &gt; AnimateTimeIntervalOfFrame.
        """
        return pulumi.get(self, "animate_only_keep_key_frame")

    @property
    @pulumi.getter(name="animateTimeIntervalOfFrame")
    def animate_time_interval_of_frame(self) -> Optional[str]:
        """
        Animation frame extraction every time, (0, video duration], Animation frame extraction time interval, If TimeInterval.Duration is set, it is less than this value.
        """
        return pulumi.get(self, "animate_time_interval_of_frame")

    @property
    @pulumi.getter
    def fps(self) -> Optional[str]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def quality(self) -> Optional[str]:
        """
        Set relative quality, [1, 100), webp image quality setting takes effect, gif has no quality parameter.
        """
        return pulumi.get(self, "quality")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaConcatTemplateConcatTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "concatFragments":
            suggest = "concat_fragments"
        elif key == "audioMixes":
            suggest = "audio_mixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaConcatTemplateConcatTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaConcatTemplateConcatTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaConcatTemplateConcatTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 concat_fragments: Sequence['outputs.MediaConcatTemplateConcatTemplateConcatFragment'],
                 container: 'outputs.MediaConcatTemplateConcatTemplateContainer',
                 audio: Optional['outputs.MediaConcatTemplateConcatTemplateAudio'] = None,
                 audio_mixes: Optional[Sequence['outputs.MediaConcatTemplateConcatTemplateAudioMix']] = None,
                 video: Optional['outputs.MediaConcatTemplateConcatTemplateVideo'] = None):
        """
        :param Sequence['MediaConcatTemplateConcatTemplateConcatFragmentArgs'] concat_fragments: Package format.
        :param 'MediaConcatTemplateConcatTemplateContainerArgs' container: Only splicing without transcoding.
        :param 'MediaConcatTemplateConcatTemplateAudioArgs' audio: audio parameters, the target file does not require Audio information, need to set Audio.Remove to true.
        :param Sequence['MediaConcatTemplateConcatTemplateAudioMixArgs'] audio_mixes: mixing parameters.
        :param 'MediaConcatTemplateConcatTemplateVideoArgs' video: video information, do not upload Video, which is equivalent to deleting video information.
        """
        pulumi.set(__self__, "concat_fragments", concat_fragments)
        pulumi.set(__self__, "container", container)
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if audio_mixes is not None:
            pulumi.set(__self__, "audio_mixes", audio_mixes)
        if video is not None:
            pulumi.set(__self__, "video", video)

    @property
    @pulumi.getter(name="concatFragments")
    def concat_fragments(self) -> Sequence['outputs.MediaConcatTemplateConcatTemplateConcatFragment']:
        """
        Package format.
        """
        return pulumi.get(self, "concat_fragments")

    @property
    @pulumi.getter
    def container(self) -> 'outputs.MediaConcatTemplateConcatTemplateContainer':
        """
        Only splicing without transcoding.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def audio(self) -> Optional['outputs.MediaConcatTemplateConcatTemplateAudio']:
        """
        audio parameters, the target file does not require Audio information, need to set Audio.Remove to true.
        """
        return pulumi.get(self, "audio")

    @property
    @pulumi.getter(name="audioMixes")
    def audio_mixes(self) -> Optional[Sequence['outputs.MediaConcatTemplateConcatTemplateAudioMix']]:
        """
        mixing parameters.
        """
        return pulumi.get(self, "audio_mixes")

    @property
    @pulumi.getter
    def video(self) -> Optional['outputs.MediaConcatTemplateConcatTemplateVideo']:
        """
        video information, do not upload Video, which is equivalent to deleting video information.
        """
        return pulumi.get(self, "video")


@pulumi.output_type
class MediaConcatTemplateConcatTemplateAudio(dict):
    def __init__(__self__, *,
                 codec: str,
                 bitrate: Optional[str] = None,
                 channels: Optional[str] = None,
                 samplerate: Optional[str] = None):
        """
        :param str codec: Codec format, value aac, mp3.
        :param str bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param str channels: number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        :param str samplerate: Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format, value aac, mp3.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def channels(self) -> Optional[str]:
        """
        number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[str]:
        """
        Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        return pulumi.get(self, "samplerate")


@pulumi.output_type
class MediaConcatTemplateConcatTemplateAudioMix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSource":
            suggest = "audio_source"
        elif key == "effectConfig":
            suggest = "effect_config"
        elif key == "mixMode":
            suggest = "mix_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaConcatTemplateConcatTemplateAudioMix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaConcatTemplateConcatTemplateAudioMix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaConcatTemplateConcatTemplateAudioMix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_source: str,
                 effect_config: Optional['outputs.MediaConcatTemplateConcatTemplateAudioMixEffectConfig'] = None,
                 mix_mode: Optional[str] = None,
                 replace: Optional[str] = None):
        """
        :param str audio_source: The media address of the audio track that needs to be mixed.
        :param 'MediaConcatTemplateConcatTemplateAudioMixEffectConfigArgs' effect_config: Mix Fade Configuration.
        :param str mix_mode: Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        :param str replace: Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        pulumi.set(__self__, "audio_source", audio_source)
        if effect_config is not None:
            pulumi.set(__self__, "effect_config", effect_config)
        if mix_mode is not None:
            pulumi.set(__self__, "mix_mode", mix_mode)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="audioSource")
    def audio_source(self) -> str:
        """
        The media address of the audio track that needs to be mixed.
        """
        return pulumi.get(self, "audio_source")

    @property
    @pulumi.getter(name="effectConfig")
    def effect_config(self) -> Optional['outputs.MediaConcatTemplateConcatTemplateAudioMixEffectConfig']:
        """
        Mix Fade Configuration.
        """
        return pulumi.get(self, "effect_config")

    @property
    @pulumi.getter(name="mixMode")
    def mix_mode(self) -> Optional[str]:
        """
        Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        """
        return pulumi.get(self, "mix_mode")

    @property
    @pulumi.getter
    def replace(self) -> Optional[str]:
        """
        Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class MediaConcatTemplateConcatTemplateAudioMixEffectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgmFadeTime":
            suggest = "bgm_fade_time"
        elif key == "enableBgmFade":
            suggest = "enable_bgm_fade"
        elif key == "enableEndFadeout":
            suggest = "enable_end_fadeout"
        elif key == "enableStartFadein":
            suggest = "enable_start_fadein"
        elif key == "endFadeoutTime":
            suggest = "end_fadeout_time"
        elif key == "startFadeinTime":
            suggest = "start_fadein_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaConcatTemplateConcatTemplateAudioMixEffectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaConcatTemplateConcatTemplateAudioMixEffectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaConcatTemplateConcatTemplateAudioMixEffectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgm_fade_time: Optional[str] = None,
                 enable_bgm_fade: Optional[str] = None,
                 enable_end_fadeout: Optional[str] = None,
                 enable_start_fadein: Optional[str] = None,
                 end_fadeout_time: Optional[str] = None,
                 start_fadein_time: Optional[str] = None):
        """
        :param str bgm_fade_time: bgm transition fade-in duration, support floating point numbers.
        :param str enable_bgm_fade: Enable bgm conversion fade in.
        :param str enable_end_fadeout: enable fade out.
        :param str enable_start_fadein: enable fade in.
        :param str end_fadeout_time: fade out time, greater than 0, support floating point numbers.
        :param str start_fadein_time: Fade in duration, greater than 0, support floating point numbers.
        """
        if bgm_fade_time is not None:
            pulumi.set(__self__, "bgm_fade_time", bgm_fade_time)
        if enable_bgm_fade is not None:
            pulumi.set(__self__, "enable_bgm_fade", enable_bgm_fade)
        if enable_end_fadeout is not None:
            pulumi.set(__self__, "enable_end_fadeout", enable_end_fadeout)
        if enable_start_fadein is not None:
            pulumi.set(__self__, "enable_start_fadein", enable_start_fadein)
        if end_fadeout_time is not None:
            pulumi.set(__self__, "end_fadeout_time", end_fadeout_time)
        if start_fadein_time is not None:
            pulumi.set(__self__, "start_fadein_time", start_fadein_time)

    @property
    @pulumi.getter(name="bgmFadeTime")
    def bgm_fade_time(self) -> Optional[str]:
        """
        bgm transition fade-in duration, support floating point numbers.
        """
        return pulumi.get(self, "bgm_fade_time")

    @property
    @pulumi.getter(name="enableBgmFade")
    def enable_bgm_fade(self) -> Optional[str]:
        """
        Enable bgm conversion fade in.
        """
        return pulumi.get(self, "enable_bgm_fade")

    @property
    @pulumi.getter(name="enableEndFadeout")
    def enable_end_fadeout(self) -> Optional[str]:
        """
        enable fade out.
        """
        return pulumi.get(self, "enable_end_fadeout")

    @property
    @pulumi.getter(name="enableStartFadein")
    def enable_start_fadein(self) -> Optional[str]:
        """
        enable fade in.
        """
        return pulumi.get(self, "enable_start_fadein")

    @property
    @pulumi.getter(name="endFadeoutTime")
    def end_fadeout_time(self) -> Optional[str]:
        """
        fade out time, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "end_fadeout_time")

    @property
    @pulumi.getter(name="startFadeinTime")
    def start_fadein_time(self) -> Optional[str]:
        """
        Fade in duration, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "start_fadein_time")


@pulumi.output_type
class MediaConcatTemplateConcatTemplateConcatFragment(dict):
    def __init__(__self__, *,
                 mode: str,
                 url: str):
        """
        :param str mode: node type, `start`, `end`.
        :param str url: Splicing object address.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        node type, `start`, `end`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Splicing object address.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class MediaConcatTemplateConcatTemplateContainer(dict):
    def __init__(__self__, *,
                 format: str):
        """
        :param str format: Container format: mp4, flv, hls, ts, mp3, aac.
        """
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Container format: mp4, flv, hls, ts, mp3, aac.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class MediaConcatTemplateConcatTemplateVideo(dict):
    def __init__(__self__, *,
                 codec: str,
                 bitrate: Optional[str] = None,
                 crf: Optional[str] = None,
                 fps: Optional[str] = None,
                 height: Optional[str] = None,
                 remove: Optional[str] = None,
                 rotate: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str codec: Codec format `H.264`.
        :param str bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param str crf: Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        :param str fps: Frame rate, value range: (0, 60], Unit: fps.
        :param str height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param str remove: Whether to delete the source audio stream, the value is true, false.
        :param str rotate: Rotation angle, Value range: [0, 360), Unit: degree.
        :param str width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if crf is not None:
            pulumi.set(__self__, "crf", crf)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rotate is not None:
            pulumi.set(__self__, "rotate", rotate)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format `H.264`.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def crf(self) -> Optional[str]:
        """
        Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        """
        return pulumi.get(self, "crf")

    @property
    @pulumi.getter
    def fps(self) -> Optional[str]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def remove(self) -> Optional[str]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rotate(self) -> Optional[str]:
        """
        Rotation angle, Value range: [0, 360), Unit: degree.
        """
        return pulumi.get(self, "rotate")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaPicProcessTemplatePicProcess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processRule":
            suggest = "process_rule"
        elif key == "isPicInfo":
            suggest = "is_pic_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaPicProcessTemplatePicProcess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaPicProcessTemplatePicProcess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaPicProcessTemplatePicProcess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 process_rule: str,
                 is_pic_info: Optional[str] = None):
        """
        :param str process_rule: Image processing rules, 1: basic image processing, please refer to the basic image processing document, 2: image compression, please refer to the image compression document, 3: blind watermark, please refer to the blind watermark document.
        :param str is_pic_info: Whether to return the original image information.
        """
        pulumi.set(__self__, "process_rule", process_rule)
        if is_pic_info is not None:
            pulumi.set(__self__, "is_pic_info", is_pic_info)

    @property
    @pulumi.getter(name="processRule")
    def process_rule(self) -> str:
        """
        Image processing rules, 1: basic image processing, please refer to the basic image processing document, 2: image compression, please refer to the image compression document, 3: blind watermark, please refer to the blind watermark document.
        """
        return pulumi.get(self, "process_rule")

    @property
    @pulumi.getter(name="isPicInfo")
    def is_pic_info(self) -> Optional[str]:
        """
        Whether to return the original image information.
        """
        return pulumi.get(self, "is_pic_info")


@pulumi.output_type
class MediaSmartCoverTemplateSmartCover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteDuplicates":
            suggest = "delete_duplicates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaSmartCoverTemplateSmartCover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaSmartCoverTemplateSmartCover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaSmartCoverTemplateSmartCover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: str,
                 count: Optional[str] = None,
                 delete_duplicates: Optional[str] = None,
                 height: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str format: Image Format, value jpg, png, webp.
        :param str count: Number of screenshots, [1,10].
        :param str delete_duplicates: cover deduplication, true/false.
        :param str height: Height, value range: [128, 4096], unit: px, if only Height is set, Width is calculated according to the original video ratio.
        :param str width: Width, value range: [128, 4096], unit: px, if only Width is set, Height is calculated according to the original ratio of the video.
        """
        pulumi.set(__self__, "format", format)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if delete_duplicates is not None:
            pulumi.set(__self__, "delete_duplicates", delete_duplicates)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Image Format, value jpg, png, webp.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def count(self) -> Optional[str]:
        """
        Number of screenshots, [1,10].
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="deleteDuplicates")
    def delete_duplicates(self) -> Optional[str]:
        """
        cover deduplication, true/false.
        """
        return pulumi.get(self, "delete_duplicates")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        Height, value range: [128, 4096], unit: px, if only Height is set, Width is calculated according to the original video ratio.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        Width, value range: [128, 4096], unit: px, if only Width is set, Height is calculated according to the original ratio of the video.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaSnapshotTemplateSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackLevel":
            suggest = "black_level"
        elif key == "ciParam":
            suggest = "ci_param"
        elif key == "isCheckBlack":
            suggest = "is_check_black"
        elif key == "isCheckCount":
            suggest = "is_check_count"
        elif key == "pixelBlackThreshold":
            suggest = "pixel_black_threshold"
        elif key == "snapshotOutMode":
            suggest = "snapshot_out_mode"
        elif key == "spriteSnapshotConfig":
            suggest = "sprite_snapshot_config"
        elif key == "timeInterval":
            suggest = "time_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaSnapshotTemplateSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaSnapshotTemplateSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaSnapshotTemplateSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: str,
                 black_level: Optional[str] = None,
                 ci_param: Optional[str] = None,
                 height: Optional[str] = None,
                 is_check_black: Optional[str] = None,
                 is_check_count: Optional[str] = None,
                 mode: Optional[str] = None,
                 pixel_black_threshold: Optional[str] = None,
                 snapshot_out_mode: Optional[str] = None,
                 sprite_snapshot_config: Optional['outputs.MediaSnapshotTemplateSnapshotSpriteSnapshotConfig'] = None,
                 start: Optional[str] = None,
                 time_interval: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str count: Number of screenshots, range (0 10000].
        :param str black_level: Screenshot black screen detection parameters, Valid when IsCheckBlack=true, Value reference range [30, 100], indicating the proportion of black pixels, the smaller the value, the smaller the proportion of black pixels, Start&gt;0, the parameter setting is invalid, no filter black screen, Start =0 parameter is valid, the start time of the frame capture is the first frame non-black screen start.
        :param str ci_param: Screenshot image processing parameters, for example: imageMogr2/format/png.
        :param str height: high, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video.
        :param str is_check_black: Whether to enable black screen detection true/false.
        :param str is_check_count: Whether to check the number of screenshots forcibly, when using custom interval mode to take screenshots, the video time is not long enough to capture Count screenshots, you can switch to average screenshot mode to capture Count screenshots.
        :param str mode: Screenshot mode, value range: {Interval, Average, KeyFrame}- Interval means interval mode Average means average mode- KeyFrame represents the key frame mode- Interval mode: Start, TimeInterval, The Count parameter takes effect. When Count is set and TimeInterval is not set, Indicates to capture all frames, a total of Count pictures- Average mode: Start, the Count parameter takes effect. express.
        :param str pixel_black_threshold: Screenshot black screen detection parameters, Valid when IsCheckBlack=true, The threshold for judging whether a pixel is a black point, value range: [0, 255].
        :param str snapshot_out_mode: Screenshot output mode parameters, Value range: {OnlySnapshot, OnlySprite, SnapshotAndSprite}, OnlySnapshot means output only screenshot mode OnlySprite means only output sprite mode SnapshotAndSprite means output screenshot and sprite mode.
        :param 'MediaSnapshotTemplateSnapshotSpriteSnapshotConfigArgs' sprite_snapshot_config: Screenshot output configuration.
        :param str start: Starting time, [0 video duration] in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param str time_interval: Screenshot time interval, (0 3600], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param str width: wide, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video.
        """
        pulumi.set(__self__, "count", count)
        if black_level is not None:
            pulumi.set(__self__, "black_level", black_level)
        if ci_param is not None:
            pulumi.set(__self__, "ci_param", ci_param)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if is_check_black is not None:
            pulumi.set(__self__, "is_check_black", is_check_black)
        if is_check_count is not None:
            pulumi.set(__self__, "is_check_count", is_check_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pixel_black_threshold is not None:
            pulumi.set(__self__, "pixel_black_threshold", pixel_black_threshold)
        if snapshot_out_mode is not None:
            pulumi.set(__self__, "snapshot_out_mode", snapshot_out_mode)
        if sprite_snapshot_config is not None:
            pulumi.set(__self__, "sprite_snapshot_config", sprite_snapshot_config)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Number of screenshots, range (0 10000].
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="blackLevel")
    def black_level(self) -> Optional[str]:
        """
        Screenshot black screen detection parameters, Valid when IsCheckBlack=true, Value reference range [30, 100], indicating the proportion of black pixels, the smaller the value, the smaller the proportion of black pixels, Start&gt;0, the parameter setting is invalid, no filter black screen, Start =0 parameter is valid, the start time of the frame capture is the first frame non-black screen start.
        """
        return pulumi.get(self, "black_level")

    @property
    @pulumi.getter(name="ciParam")
    def ci_param(self) -> Optional[str]:
        """
        Screenshot image processing parameters, for example: imageMogr2/format/png.
        """
        return pulumi.get(self, "ci_param")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        high, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="isCheckBlack")
    def is_check_black(self) -> Optional[str]:
        """
        Whether to enable black screen detection true/false.
        """
        return pulumi.get(self, "is_check_black")

    @property
    @pulumi.getter(name="isCheckCount")
    def is_check_count(self) -> Optional[str]:
        """
        Whether to check the number of screenshots forcibly, when using custom interval mode to take screenshots, the video time is not long enough to capture Count screenshots, you can switch to average screenshot mode to capture Count screenshots.
        """
        return pulumi.get(self, "is_check_count")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Screenshot mode, value range: {Interval, Average, KeyFrame}- Interval means interval mode Average means average mode- KeyFrame represents the key frame mode- Interval mode: Start, TimeInterval, The Count parameter takes effect. When Count is set and TimeInterval is not set, Indicates to capture all frames, a total of Count pictures- Average mode: Start, the Count parameter takes effect. express.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="pixelBlackThreshold")
    def pixel_black_threshold(self) -> Optional[str]:
        """
        Screenshot black screen detection parameters, Valid when IsCheckBlack=true, The threshold for judging whether a pixel is a black point, value range: [0, 255].
        """
        return pulumi.get(self, "pixel_black_threshold")

    @property
    @pulumi.getter(name="snapshotOutMode")
    def snapshot_out_mode(self) -> Optional[str]:
        """
        Screenshot output mode parameters, Value range: {OnlySnapshot, OnlySprite, SnapshotAndSprite}, OnlySnapshot means output only screenshot mode OnlySprite means only output sprite mode SnapshotAndSprite means output screenshot and sprite mode.
        """
        return pulumi.get(self, "snapshot_out_mode")

    @property
    @pulumi.getter(name="spriteSnapshotConfig")
    def sprite_snapshot_config(self) -> Optional['outputs.MediaSnapshotTemplateSnapshotSpriteSnapshotConfig']:
        """
        Screenshot output configuration.
        """
        return pulumi.get(self, "sprite_snapshot_config")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        Starting time, [0 video duration] in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[str]:
        """
        Screenshot time interval, (0 3600], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "time_interval")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        wide, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaSnapshotTemplateSnapshotSpriteSnapshotConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellHeight":
            suggest = "cell_height"
        elif key == "cellWidth":
            suggest = "cell_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaSnapshotTemplateSnapshotSpriteSnapshotConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaSnapshotTemplateSnapshotSpriteSnapshotConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaSnapshotTemplateSnapshotSpriteSnapshotConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: str,
                 columns: str,
                 lines: str,
                 cell_height: Optional[str] = None,
                 cell_width: Optional[str] = None,
                 margin: Optional[str] = None,
                 padding: Optional[str] = None):
        """
        :param str color: See `https://www.ffmpeg.org/ffmpeg-utils.html#color-syntax` for details on supported colors.
        :param str columns: Number of screenshot columns, value range: [1, 10000].
        :param str lines: Number of screenshot lines, value range: [1, 10000].
        :param str cell_height: Single image height Value range: [8, 4096], Unit: px.
        :param str cell_width: Single image width Value range: [8, 4096], Unit: px.
        :param str margin: screenshot margin size, Value range: [8, 4096], Unit: px.
        :param str padding: screenshot padding size, Value range: [8, 4096], Unit: px.
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "lines", lines)
        if cell_height is not None:
            pulumi.set(__self__, "cell_height", cell_height)
        if cell_width is not None:
            pulumi.set(__self__, "cell_width", cell_width)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)

    @property
    @pulumi.getter
    def color(self) -> str:
        """
        See `https://www.ffmpeg.org/ffmpeg-utils.html#color-syntax` for details on supported colors.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def columns(self) -> str:
        """
        Number of screenshot columns, value range: [1, 10000].
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def lines(self) -> str:
        """
        Number of screenshot lines, value range: [1, 10000].
        """
        return pulumi.get(self, "lines")

    @property
    @pulumi.getter(name="cellHeight")
    def cell_height(self) -> Optional[str]:
        """
        Single image height Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "cell_height")

    @property
    @pulumi.getter(name="cellWidth")
    def cell_width(self) -> Optional[str]:
        """
        Single image width Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "cell_width")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        screenshot margin size, Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def padding(self) -> Optional[str]:
        """
        screenshot padding size, Value range: [8, 4096], Unit: px.
        """
        return pulumi.get(self, "padding")


@pulumi.output_type
class MediaSpeechRecognitionTemplateSpeechRecognition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelNum":
            suggest = "channel_num"
        elif key == "engineModelType":
            suggest = "engine_model_type"
        elif key == "convertNumMode":
            suggest = "convert_num_mode"
        elif key == "filterDirty":
            suggest = "filter_dirty"
        elif key == "filterModal":
            suggest = "filter_modal"
        elif key == "filterPunc":
            suggest = "filter_punc"
        elif key == "outputFileType":
            suggest = "output_file_type"
        elif key == "resTextFormat":
            suggest = "res_text_format"
        elif key == "speakerDiarization":
            suggest = "speaker_diarization"
        elif key == "speakerNumber":
            suggest = "speaker_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaSpeechRecognitionTemplateSpeechRecognition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaSpeechRecognitionTemplateSpeechRecognition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaSpeechRecognitionTemplateSpeechRecognition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_num: str,
                 engine_model_type: str,
                 convert_num_mode: Optional[str] = None,
                 filter_dirty: Optional[str] = None,
                 filter_modal: Optional[str] = None,
                 filter_punc: Optional[str] = None,
                 output_file_type: Optional[str] = None,
                 res_text_format: Optional[str] = None,
                 speaker_diarization: Optional[str] = None,
                 speaker_number: Optional[str] = None):
        """
        :param str channel_num: Number of voice channels: 1 means mono. EngineModelType supports only mono for non-telephone scenarios, and 2 means dual channels (only 8k_zh engine model supports dual channels, which should correspond to both sides of the call).
        :param str engine_model_type: Engine model type, divided into phone scene and non-phone scene, phone scene: 8k_zh: phone 8k Chinese Mandarin general (can be used for dual-channel audio), 8k_zh_s: phone 8k Chinese Mandarin speaker separation (only for monophonic audio), 8k_en: Telephone 8k English; non-telephone scene: 16k_zh: 16k Mandarin Chinese, 16k_zh_video: 16k audio and video field, 16k_en: 16k English, 16k_ca: 16k Cantonese, 16k_ja: 16k Japanese, 16k_zh_edu: Chinese education, 16k_en_edu: English education, 16k_zh_medical: medical, 16k_th: Thai, 16k_zh_dialect: multi-dialect, supports 23 dialects.
        :param str convert_num_mode: Whether to perform intelligent conversion of Arabic numerals (currently supports Mandarin Chinese engine): 0 means no conversion, directly output Chinese numbers, 1 means intelligently convert to Arabic numerals according to the scene, 3 means enable math-related digital conversion, the default value is 0.
        :param str filter_dirty: Whether to filter dirty words (currently supports Mandarin Chinese engine): 0 means not to filter dirty words, 1 means to filter dirty words, 2 means to replace dirty words with *, the default value is 0.
        :param str filter_modal: Whether to pass modal particles (currently supports Mandarin Chinese engine): 0 means not to filter modal particles, 1 means partial filtering, 2 means strict filtering, and the default value is 0.
        :param str filter_punc: Whether to filter punctuation (currently supports Mandarin Chinese engine): 0 means no filtering, 1 means filtering end-of-sentence punctuation, 2 means filtering all punctuation, the default value is 0.
        :param str output_file_type: Output file type, optional txt, srt. The default is txt.
        :param str res_text_format: Recognition result return form: 0 means the recognition result text (including segmented time stamps), 1 is the detailed recognition result at the word level granularity, without punctuation, and includes the speech rate value (a list of word time stamps, generally used to generate subtitle scenes), 2 Detailed recognition results at word-level granularity (including punctuation and speech rate values)..
        :param str speaker_diarization: Whether to enable speaker separation: 0 means not enabled, 1 means enabled (only supports 8k_zh, 16k_zh, 16k_zh_video, monophonic audio), the default value is 0, Note: 8K telephony scenarios suggest using dual-channel to distinguish between the two parties, set ChannelNum=2 is enough, no need to enable speaker separation.
        :param str speaker_number: The number of speakers to be separated (need to be used in conjunction with enabling speaker separation), value range: 0-10, 0 means automatic separation (currently only supports <= 6 people), 1-10 represents the number of specified speakers to be separated. The default value is 0.
        """
        pulumi.set(__self__, "channel_num", channel_num)
        pulumi.set(__self__, "engine_model_type", engine_model_type)
        if convert_num_mode is not None:
            pulumi.set(__self__, "convert_num_mode", convert_num_mode)
        if filter_dirty is not None:
            pulumi.set(__self__, "filter_dirty", filter_dirty)
        if filter_modal is not None:
            pulumi.set(__self__, "filter_modal", filter_modal)
        if filter_punc is not None:
            pulumi.set(__self__, "filter_punc", filter_punc)
        if output_file_type is not None:
            pulumi.set(__self__, "output_file_type", output_file_type)
        if res_text_format is not None:
            pulumi.set(__self__, "res_text_format", res_text_format)
        if speaker_diarization is not None:
            pulumi.set(__self__, "speaker_diarization", speaker_diarization)
        if speaker_number is not None:
            pulumi.set(__self__, "speaker_number", speaker_number)

    @property
    @pulumi.getter(name="channelNum")
    def channel_num(self) -> str:
        """
        Number of voice channels: 1 means mono. EngineModelType supports only mono for non-telephone scenarios, and 2 means dual channels (only 8k_zh engine model supports dual channels, which should correspond to both sides of the call).
        """
        return pulumi.get(self, "channel_num")

    @property
    @pulumi.getter(name="engineModelType")
    def engine_model_type(self) -> str:
        """
        Engine model type, divided into phone scene and non-phone scene, phone scene: 8k_zh: phone 8k Chinese Mandarin general (can be used for dual-channel audio), 8k_zh_s: phone 8k Chinese Mandarin speaker separation (only for monophonic audio), 8k_en: Telephone 8k English; non-telephone scene: 16k_zh: 16k Mandarin Chinese, 16k_zh_video: 16k audio and video field, 16k_en: 16k English, 16k_ca: 16k Cantonese, 16k_ja: 16k Japanese, 16k_zh_edu: Chinese education, 16k_en_edu: English education, 16k_zh_medical: medical, 16k_th: Thai, 16k_zh_dialect: multi-dialect, supports 23 dialects.
        """
        return pulumi.get(self, "engine_model_type")

    @property
    @pulumi.getter(name="convertNumMode")
    def convert_num_mode(self) -> Optional[str]:
        """
        Whether to perform intelligent conversion of Arabic numerals (currently supports Mandarin Chinese engine): 0 means no conversion, directly output Chinese numbers, 1 means intelligently convert to Arabic numerals according to the scene, 3 means enable math-related digital conversion, the default value is 0.
        """
        return pulumi.get(self, "convert_num_mode")

    @property
    @pulumi.getter(name="filterDirty")
    def filter_dirty(self) -> Optional[str]:
        """
        Whether to filter dirty words (currently supports Mandarin Chinese engine): 0 means not to filter dirty words, 1 means to filter dirty words, 2 means to replace dirty words with *, the default value is 0.
        """
        return pulumi.get(self, "filter_dirty")

    @property
    @pulumi.getter(name="filterModal")
    def filter_modal(self) -> Optional[str]:
        """
        Whether to pass modal particles (currently supports Mandarin Chinese engine): 0 means not to filter modal particles, 1 means partial filtering, 2 means strict filtering, and the default value is 0.
        """
        return pulumi.get(self, "filter_modal")

    @property
    @pulumi.getter(name="filterPunc")
    def filter_punc(self) -> Optional[str]:
        """
        Whether to filter punctuation (currently supports Mandarin Chinese engine): 0 means no filtering, 1 means filtering end-of-sentence punctuation, 2 means filtering all punctuation, the default value is 0.
        """
        return pulumi.get(self, "filter_punc")

    @property
    @pulumi.getter(name="outputFileType")
    def output_file_type(self) -> Optional[str]:
        """
        Output file type, optional txt, srt. The default is txt.
        """
        return pulumi.get(self, "output_file_type")

    @property
    @pulumi.getter(name="resTextFormat")
    def res_text_format(self) -> Optional[str]:
        """
        Recognition result return form: 0 means the recognition result text (including segmented time stamps), 1 is the detailed recognition result at the word level granularity, without punctuation, and includes the speech rate value (a list of word time stamps, generally used to generate subtitle scenes), 2 Detailed recognition results at word-level granularity (including punctuation and speech rate values)..
        """
        return pulumi.get(self, "res_text_format")

    @property
    @pulumi.getter(name="speakerDiarization")
    def speaker_diarization(self) -> Optional[str]:
        """
        Whether to enable speaker separation: 0 means not enabled, 1 means enabled (only supports 8k_zh, 16k_zh, 16k_zh_video, monophonic audio), the default value is 0, Note: 8K telephony scenarios suggest using dual-channel to distinguish between the two parties, set ChannelNum=2 is enough, no need to enable speaker separation.
        """
        return pulumi.get(self, "speaker_diarization")

    @property
    @pulumi.getter(name="speakerNumber")
    def speaker_number(self) -> Optional[str]:
        """
        The number of speakers to be separated (need to be used in conjunction with enabling speaker separation), value range: 0-10, 0 means automatic separation (currently only supports <= 6 people), 1-10 represents the number of specified speakers to be separated. The default value is 0.
        """
        return pulumi.get(self, "speaker_number")


@pulumi.output_type
class MediaTranscodeProTemplateAudio(dict):
    def __init__(__self__, *,
                 codec: str,
                 remove: Optional[str] = None):
        """
        :param str codec: Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        :param str remove: Whether to delete the source audio stream, the value is true, false.
        """
        pulumi.set(__self__, "codec", codec)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def remove(self) -> Optional[str]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")


@pulumi.output_type
class MediaTranscodeProTemplateContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipConfig":
            suggest = "clip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeProTemplateContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeProTemplateContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeProTemplateContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: str,
                 clip_config: Optional['outputs.MediaTranscodeProTemplateContainerClipConfig'] = None):
        """
        :param str format: Package format.
        :param 'MediaTranscodeProTemplateContainerClipConfigArgs' clip_config: Fragment configuration, valid when format is hls and dash.
        """
        pulumi.set(__self__, "format", format)
        if clip_config is not None:
            pulumi.set(__self__, "clip_config", clip_config)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Package format.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="clipConfig")
    def clip_config(self) -> Optional['outputs.MediaTranscodeProTemplateContainerClipConfig']:
        """
        Fragment configuration, valid when format is hls and dash.
        """
        return pulumi.get(self, "clip_config")


@pulumi.output_type
class MediaTranscodeProTemplateContainerClipConfig(dict):
    def __init__(__self__, *,
                 duration: Optional[str] = None):
        """
        :param str duration: Fragmentation duration, default 5s.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Fragmentation duration, default 5s.
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class MediaTranscodeProTemplateTimeInterval(dict):
    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 start: Optional[str] = None):
        """
        :param str duration: duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param str start: Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class MediaTranscodeProTemplateTransConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adjDarMethod":
            suggest = "adj_dar_method"
        elif key == "audioBitrateAdjMethod":
            suggest = "audio_bitrate_adj_method"
        elif key == "deleteMetadata":
            suggest = "delete_metadata"
        elif key == "isCheckAudioBitrate":
            suggest = "is_check_audio_bitrate"
        elif key == "isCheckReso":
            suggest = "is_check_reso"
        elif key == "isCheckVideoBitrate":
            suggest = "is_check_video_bitrate"
        elif key == "isHdr2Sdr":
            suggest = "is_hdr2_sdr"
        elif key == "resoAdjMethod":
            suggest = "reso_adj_method"
        elif key == "videoBitrateAdjMethod":
            suggest = "video_bitrate_adj_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeProTemplateTransConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeProTemplateTransConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeProTemplateTransConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adj_dar_method: Optional[str] = None,
                 audio_bitrate_adj_method: Optional[str] = None,
                 delete_metadata: Optional[str] = None,
                 is_check_audio_bitrate: Optional[str] = None,
                 is_check_reso: Optional[str] = None,
                 is_check_video_bitrate: Optional[str] = None,
                 is_hdr2_sdr: Optional[str] = None,
                 reso_adj_method: Optional[str] = None,
                 video_bitrate_adj_method: Optional[str] = None):
        """
        :param str adj_dar_method: Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        :param str audio_bitrate_adj_method: Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        :param str delete_metadata: Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        :param str is_check_audio_bitrate: Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        :param str is_check_reso: Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        :param str is_check_video_bitrate: Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        :param str is_hdr2_sdr: Whether to enable HDR to SDR true, false.
        :param str reso_adj_method: Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        :param str video_bitrate_adj_method: Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        if adj_dar_method is not None:
            pulumi.set(__self__, "adj_dar_method", adj_dar_method)
        if audio_bitrate_adj_method is not None:
            pulumi.set(__self__, "audio_bitrate_adj_method", audio_bitrate_adj_method)
        if delete_metadata is not None:
            pulumi.set(__self__, "delete_metadata", delete_metadata)
        if is_check_audio_bitrate is not None:
            pulumi.set(__self__, "is_check_audio_bitrate", is_check_audio_bitrate)
        if is_check_reso is not None:
            pulumi.set(__self__, "is_check_reso", is_check_reso)
        if is_check_video_bitrate is not None:
            pulumi.set(__self__, "is_check_video_bitrate", is_check_video_bitrate)
        if is_hdr2_sdr is not None:
            pulumi.set(__self__, "is_hdr2_sdr", is_hdr2_sdr)
        if reso_adj_method is not None:
            pulumi.set(__self__, "reso_adj_method", reso_adj_method)
        if video_bitrate_adj_method is not None:
            pulumi.set(__self__, "video_bitrate_adj_method", video_bitrate_adj_method)

    @property
    @pulumi.getter(name="adjDarMethod")
    def adj_dar_method(self) -> Optional[str]:
        """
        Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        """
        return pulumi.get(self, "adj_dar_method")

    @property
    @pulumi.getter(name="audioBitrateAdjMethod")
    def audio_bitrate_adj_method(self) -> Optional[str]:
        """
        Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        """
        return pulumi.get(self, "audio_bitrate_adj_method")

    @property
    @pulumi.getter(name="deleteMetadata")
    def delete_metadata(self) -> Optional[str]:
        """
        Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        """
        return pulumi.get(self, "delete_metadata")

    @property
    @pulumi.getter(name="isCheckAudioBitrate")
    def is_check_audio_bitrate(self) -> Optional[str]:
        """
        Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        """
        return pulumi.get(self, "is_check_audio_bitrate")

    @property
    @pulumi.getter(name="isCheckReso")
    def is_check_reso(self) -> Optional[str]:
        """
        Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_reso")

    @property
    @pulumi.getter(name="isCheckVideoBitrate")
    def is_check_video_bitrate(self) -> Optional[str]:
        """
        Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_video_bitrate")

    @property
    @pulumi.getter(name="isHdr2Sdr")
    def is_hdr2_sdr(self) -> Optional[str]:
        """
        Whether to enable HDR to SDR true, false.
        """
        return pulumi.get(self, "is_hdr2_sdr")

    @property
    @pulumi.getter(name="resoAdjMethod")
    def reso_adj_method(self) -> Optional[str]:
        """
        Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        """
        return pulumi.get(self, "reso_adj_method")

    @property
    @pulumi.getter(name="videoBitrateAdjMethod")
    def video_bitrate_adj_method(self) -> Optional[str]:
        """
        Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        return pulumi.get(self, "video_bitrate_adj_method")


@pulumi.output_type
class MediaTranscodeProTemplateVideo(dict):
    def __init__(__self__, *,
                 bitrate: Optional[str] = None,
                 codec: Optional[str] = None,
                 fps: Optional[str] = None,
                 height: Optional[str] = None,
                 interlaced: Optional[str] = None,
                 profile: Optional[str] = None,
                 rotate: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str bitrate: Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        :param str codec: Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        :param str fps: Frame rate, value range: (0, 60], Unit: fps.
        :param str height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param str interlaced: field pattern.
        :param str profile: encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        :param str rotate: Rotation angle, Value range: [0, 360), Unit: degree.
        :param str width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if interlaced is not None:
            pulumi.set(__self__, "interlaced", interlaced)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if rotate is not None:
            pulumi.set(__self__, "rotate", rotate)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def fps(self) -> Optional[str]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def interlaced(self) -> Optional[str]:
        """
        field pattern.
        """
        return pulumi.get(self, "interlaced")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter
    def rotate(self) -> Optional[str]:
        """
        Rotation angle, Value range: [0, 360), Unit: degree.
        """
        return pulumi.get(self, "rotate")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaTranscodeTemplateAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepTwoTracks":
            suggest = "keep_two_tracks"
        elif key == "sampleFormat":
            suggest = "sample_format"
        elif key == "switchTrack":
            suggest = "switch_track"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[str] = None,
                 channels: Optional[str] = None,
                 codec: Optional[str] = None,
                 keep_two_tracks: Optional[str] = None,
                 remove: Optional[str] = None,
                 sample_format: Optional[str] = None,
                 samplerate: Optional[str] = None,
                 switch_track: Optional[str] = None):
        """
        :param str bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param str channels: number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3/opus, support 1, 2- When Codec is set to Vorbis, only 2 is supported- When Codec is set to amr, only 1 is supported- When Codec is set to pcm_s16le, only 1 and 2 are supported- When the encapsulation format is dash, 8 is not supported.
        :param str codec: Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        :param str keep_two_tracks: Keep dual audio tracks, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        :param str remove: Whether to delete the source audio stream, the value is true, false.
        :param str sample_format: Sampling bit width- When Codec is set to aac, support fltp- When Codec is set to mp3, fltp, s16p, s32p are supported- When Codec is set to flac, s16, s32, s16p, s32p are supported- When Codec is set to amr, support s16, s16p- When Codec is set to opus, support s16- When Codec is set to pcm_s16le, support s16- When Codec is set to Vorbis, support fltp- This parameter is invalid when Video.Codec is H.265.
        :param str samplerate: Sampling Rate- Unit: Hz- Optional 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below- When Codec is set to amr, only 8000 is supported- When Codec is set to opus, it supports 8000, 16000, 24000, 48000.
        :param str switch_track: Convert track, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if keep_two_tracks is not None:
            pulumi.set(__self__, "keep_two_tracks", keep_two_tracks)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if sample_format is not None:
            pulumi.set(__self__, "sample_format", sample_format)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)
        if switch_track is not None:
            pulumi.set(__self__, "switch_track", switch_track)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def channels(self) -> Optional[str]:
        """
        number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3/opus, support 1, 2- When Codec is set to Vorbis, only 2 is supported- When Codec is set to amr, only 1 is supported- When Codec is set to pcm_s16le, only 1 and 2 are supported- When the encapsulation format is dash, 8 is not supported.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        Codec format, value aac, mp3, flac, amr, Vorbis, opus, pcm_s16le.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="keepTwoTracks")
    def keep_two_tracks(self) -> Optional[str]:
        """
        Keep dual audio tracks, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        """
        return pulumi.get(self, "keep_two_tracks")

    @property
    @pulumi.getter
    def remove(self) -> Optional[str]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter(name="sampleFormat")
    def sample_format(self) -> Optional[str]:
        """
        Sampling bit width- When Codec is set to aac, support fltp- When Codec is set to mp3, fltp, s16p, s32p are supported- When Codec is set to flac, s16, s32, s16p, s32p are supported- When Codec is set to amr, support s16, s16p- When Codec is set to opus, support s16- When Codec is set to pcm_s16le, support s16- When Codec is set to Vorbis, support fltp- This parameter is invalid when Video.Codec is H.265.
        """
        return pulumi.get(self, "sample_format")

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[str]:
        """
        Sampling Rate- Unit: Hz- Optional 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below- When Codec is set to amr, only 8000 is supported- When Codec is set to opus, it supports 8000, 16000, 24000, 48000.
        """
        return pulumi.get(self, "samplerate")

    @property
    @pulumi.getter(name="switchTrack")
    def switch_track(self) -> Optional[str]:
        """
        Convert track, the value is true, false. This parameter is invalid when Video.Codec is H.265.
        """
        return pulumi.get(self, "switch_track")


@pulumi.output_type
class MediaTranscodeTemplateAudioMix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSource":
            suggest = "audio_source"
        elif key == "effectConfig":
            suggest = "effect_config"
        elif key == "mixMode":
            suggest = "mix_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateAudioMix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateAudioMix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateAudioMix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_source: str,
                 effect_config: Optional['outputs.MediaTranscodeTemplateAudioMixEffectConfig'] = None,
                 mix_mode: Optional[str] = None,
                 replace: Optional[str] = None):
        """
        :param str audio_source: The media address of the audio track that needs to be mixed.
        :param 'MediaTranscodeTemplateAudioMixEffectConfigArgs' effect_config: Mix Fade Configuration.
        :param str mix_mode: Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        :param str replace: Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        pulumi.set(__self__, "audio_source", audio_source)
        if effect_config is not None:
            pulumi.set(__self__, "effect_config", effect_config)
        if mix_mode is not None:
            pulumi.set(__self__, "mix_mode", mix_mode)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="audioSource")
    def audio_source(self) -> str:
        """
        The media address of the audio track that needs to be mixed.
        """
        return pulumi.get(self, "audio_source")

    @property
    @pulumi.getter(name="effectConfig")
    def effect_config(self) -> Optional['outputs.MediaTranscodeTemplateAudioMixEffectConfig']:
        """
        Mix Fade Configuration.
        """
        return pulumi.get(self, "effect_config")

    @property
    @pulumi.getter(name="mixMode")
    def mix_mode(self) -> Optional[str]:
        """
        Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        """
        return pulumi.get(self, "mix_mode")

    @property
    @pulumi.getter
    def replace(self) -> Optional[str]:
        """
        Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class MediaTranscodeTemplateAudioMixEffectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgmFadeTime":
            suggest = "bgm_fade_time"
        elif key == "enableBgmFade":
            suggest = "enable_bgm_fade"
        elif key == "enableEndFadeout":
            suggest = "enable_end_fadeout"
        elif key == "enableStartFadein":
            suggest = "enable_start_fadein"
        elif key == "endFadeoutTime":
            suggest = "end_fadeout_time"
        elif key == "startFadeinTime":
            suggest = "start_fadein_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateAudioMixEffectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateAudioMixEffectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateAudioMixEffectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgm_fade_time: Optional[str] = None,
                 enable_bgm_fade: Optional[str] = None,
                 enable_end_fadeout: Optional[str] = None,
                 enable_start_fadein: Optional[str] = None,
                 end_fadeout_time: Optional[str] = None,
                 start_fadein_time: Optional[str] = None):
        """
        :param str bgm_fade_time: bgm transition fade-in duration, support floating point numbers.
        :param str enable_bgm_fade: Enable bgm conversion fade in.
        :param str enable_end_fadeout: enable fade out.
        :param str enable_start_fadein: enable fade in.
        :param str end_fadeout_time: fade out time, greater than 0, support floating point numbers.
        :param str start_fadein_time: Fade in duration, greater than 0, support floating point numbers.
        """
        if bgm_fade_time is not None:
            pulumi.set(__self__, "bgm_fade_time", bgm_fade_time)
        if enable_bgm_fade is not None:
            pulumi.set(__self__, "enable_bgm_fade", enable_bgm_fade)
        if enable_end_fadeout is not None:
            pulumi.set(__self__, "enable_end_fadeout", enable_end_fadeout)
        if enable_start_fadein is not None:
            pulumi.set(__self__, "enable_start_fadein", enable_start_fadein)
        if end_fadeout_time is not None:
            pulumi.set(__self__, "end_fadeout_time", end_fadeout_time)
        if start_fadein_time is not None:
            pulumi.set(__self__, "start_fadein_time", start_fadein_time)

    @property
    @pulumi.getter(name="bgmFadeTime")
    def bgm_fade_time(self) -> Optional[str]:
        """
        bgm transition fade-in duration, support floating point numbers.
        """
        return pulumi.get(self, "bgm_fade_time")

    @property
    @pulumi.getter(name="enableBgmFade")
    def enable_bgm_fade(self) -> Optional[str]:
        """
        Enable bgm conversion fade in.
        """
        return pulumi.get(self, "enable_bgm_fade")

    @property
    @pulumi.getter(name="enableEndFadeout")
    def enable_end_fadeout(self) -> Optional[str]:
        """
        enable fade out.
        """
        return pulumi.get(self, "enable_end_fadeout")

    @property
    @pulumi.getter(name="enableStartFadein")
    def enable_start_fadein(self) -> Optional[str]:
        """
        enable fade in.
        """
        return pulumi.get(self, "enable_start_fadein")

    @property
    @pulumi.getter(name="endFadeoutTime")
    def end_fadeout_time(self) -> Optional[str]:
        """
        fade out time, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "end_fadeout_time")

    @property
    @pulumi.getter(name="startFadeinTime")
    def start_fadein_time(self) -> Optional[str]:
        """
        Fade in duration, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "start_fadein_time")


@pulumi.output_type
class MediaTranscodeTemplateContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clipConfig":
            suggest = "clip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: str,
                 clip_config: Optional['outputs.MediaTranscodeTemplateContainerClipConfig'] = None):
        """
        :param str format: Package format.
        :param 'MediaTranscodeTemplateContainerClipConfigArgs' clip_config: Fragment configuration, valid when format is hls and dash.
        """
        pulumi.set(__self__, "format", format)
        if clip_config is not None:
            pulumi.set(__self__, "clip_config", clip_config)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Package format.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="clipConfig")
    def clip_config(self) -> Optional['outputs.MediaTranscodeTemplateContainerClipConfig']:
        """
        Fragment configuration, valid when format is hls and dash.
        """
        return pulumi.get(self, "clip_config")


@pulumi.output_type
class MediaTranscodeTemplateContainerClipConfig(dict):
    def __init__(__self__, *,
                 duration: Optional[str] = None):
        """
        :param str duration: Fragmentation duration, default 5s.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Fragmentation duration, default 5s.
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class MediaTranscodeTemplateTimeInterval(dict):
    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 start: Optional[str] = None):
        """
        :param str duration: duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        :param str start: Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        duration, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        Starting time, [0 video duration], in seconds, Support float format, the execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class MediaTranscodeTemplateTransConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adjDarMethod":
            suggest = "adj_dar_method"
        elif key == "audioBitrateAdjMethod":
            suggest = "audio_bitrate_adj_method"
        elif key == "deleteMetadata":
            suggest = "delete_metadata"
        elif key == "hlsEncrypt":
            suggest = "hls_encrypt"
        elif key == "isCheckAudioBitrate":
            suggest = "is_check_audio_bitrate"
        elif key == "isCheckReso":
            suggest = "is_check_reso"
        elif key == "isCheckVideoBitrate":
            suggest = "is_check_video_bitrate"
        elif key == "isHdr2Sdr":
            suggest = "is_hdr2_sdr"
        elif key == "resoAdjMethod":
            suggest = "reso_adj_method"
        elif key == "videoBitrateAdjMethod":
            suggest = "video_bitrate_adj_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateTransConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateTransConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateTransConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adj_dar_method: Optional[str] = None,
                 audio_bitrate_adj_method: Optional[str] = None,
                 delete_metadata: Optional[str] = None,
                 hls_encrypt: Optional['outputs.MediaTranscodeTemplateTransConfigHlsEncrypt'] = None,
                 is_check_audio_bitrate: Optional[str] = None,
                 is_check_reso: Optional[str] = None,
                 is_check_video_bitrate: Optional[str] = None,
                 is_hdr2_sdr: Optional[str] = None,
                 reso_adj_method: Optional[str] = None,
                 video_bitrate_adj_method: Optional[str] = None):
        """
        :param str adj_dar_method: Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        :param str audio_bitrate_adj_method: Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        :param str delete_metadata: Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        :param 'MediaTranscodeTemplateTransConfigHlsEncryptArgs' hls_encrypt: hls encryption configuration.
        :param str is_check_audio_bitrate: Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        :param str is_check_reso: Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        :param str is_check_video_bitrate: Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        :param str is_hdr2_sdr: Whether to enable HDR to SDR true, false.
        :param str reso_adj_method: Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        :param str video_bitrate_adj_method: Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        if adj_dar_method is not None:
            pulumi.set(__self__, "adj_dar_method", adj_dar_method)
        if audio_bitrate_adj_method is not None:
            pulumi.set(__self__, "audio_bitrate_adj_method", audio_bitrate_adj_method)
        if delete_metadata is not None:
            pulumi.set(__self__, "delete_metadata", delete_metadata)
        if hls_encrypt is not None:
            pulumi.set(__self__, "hls_encrypt", hls_encrypt)
        if is_check_audio_bitrate is not None:
            pulumi.set(__self__, "is_check_audio_bitrate", is_check_audio_bitrate)
        if is_check_reso is not None:
            pulumi.set(__self__, "is_check_reso", is_check_reso)
        if is_check_video_bitrate is not None:
            pulumi.set(__self__, "is_check_video_bitrate", is_check_video_bitrate)
        if is_hdr2_sdr is not None:
            pulumi.set(__self__, "is_hdr2_sdr", is_hdr2_sdr)
        if reso_adj_method is not None:
            pulumi.set(__self__, "reso_adj_method", reso_adj_method)
        if video_bitrate_adj_method is not None:
            pulumi.set(__self__, "video_bitrate_adj_method", video_bitrate_adj_method)

    @property
    @pulumi.getter(name="adjDarMethod")
    def adj_dar_method(self) -> Optional[str]:
        """
        Resolution adjustment method, value scale, crop, pad, none, When the aspect ratio of the output video is different from the original video, adjust the resolution accordingly according to this parameter.
        """
        return pulumi.get(self, "adj_dar_method")

    @property
    @pulumi.getter(name="audioBitrateAdjMethod")
    def audio_bitrate_adj_method(self) -> Optional[str]:
        """
        Audio bit rate adjustment mode, value 0, 1; when the output audio bit rate is greater than the original audio bit rate, 0 means use the original audio bit rate; 1 means return transcoding failed, Take effect when IsCheckAudioBitrate is true.
        """
        return pulumi.get(self, "audio_bitrate_adj_method")

    @property
    @pulumi.getter(name="deleteMetadata")
    def delete_metadata(self) -> Optional[str]:
        """
        Whether to delete the MetaData information in the file, true, false, When false, keep source file information.
        """
        return pulumi.get(self, "delete_metadata")

    @property
    @pulumi.getter(name="hlsEncrypt")
    def hls_encrypt(self) -> Optional['outputs.MediaTranscodeTemplateTransConfigHlsEncrypt']:
        """
        hls encryption configuration.
        """
        return pulumi.get(self, "hls_encrypt")

    @property
    @pulumi.getter(name="isCheckAudioBitrate")
    def is_check_audio_bitrate(self) -> Optional[str]:
        """
        Whether to check the audio code rate, true, false, When false, transcode according to configuration parameters.
        """
        return pulumi.get(self, "is_check_audio_bitrate")

    @property
    @pulumi.getter(name="isCheckReso")
    def is_check_reso(self) -> Optional[str]:
        """
        Whether to check the resolution, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_reso")

    @property
    @pulumi.getter(name="isCheckVideoBitrate")
    def is_check_video_bitrate(self) -> Optional[str]:
        """
        Whether to check the video code rate, when it is false, transcode according to the configuration parameters.
        """
        return pulumi.get(self, "is_check_video_bitrate")

    @property
    @pulumi.getter(name="isHdr2Sdr")
    def is_hdr2_sdr(self) -> Optional[str]:
        """
        Whether to enable HDR to SDR true, false.
        """
        return pulumi.get(self, "is_hdr2_sdr")

    @property
    @pulumi.getter(name="resoAdjMethod")
    def reso_adj_method(self) -> Optional[str]:
        """
        Resolution adjustment mode, value 0, 1; 0 means use the original video resolution; 1 means return transcoding failed, Take effect when IsCheckReso is true.
        """
        return pulumi.get(self, "reso_adj_method")

    @property
    @pulumi.getter(name="videoBitrateAdjMethod")
    def video_bitrate_adj_method(self) -> Optional[str]:
        """
        Video bit rate adjustment method, value 0, 1; when the output video bit rate is greater than the original video bit rate, 0 means use the original video bit rate; 1 means return transcoding failed, Take effect when IsCheckVideoBitrate is true.
        """
        return pulumi.get(self, "video_bitrate_adj_method")


@pulumi.output_type
class MediaTranscodeTemplateTransConfigHlsEncrypt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHlsEncrypt":
            suggest = "is_hls_encrypt"
        elif key == "uriKey":
            suggest = "uri_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateTransConfigHlsEncrypt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateTransConfigHlsEncrypt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateTransConfigHlsEncrypt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hls_encrypt: Optional[str] = None,
                 uri_key: Optional[str] = None):
        """
        :param str is_hls_encrypt: Whether to enable HLS encryption, support encryption when Container.Format is hls.
        :param str uri_key: HLS encrypted key, this parameter is only meaningful when IsHlsEncrypt is true.
        """
        if is_hls_encrypt is not None:
            pulumi.set(__self__, "is_hls_encrypt", is_hls_encrypt)
        if uri_key is not None:
            pulumi.set(__self__, "uri_key", uri_key)

    @property
    @pulumi.getter(name="isHlsEncrypt")
    def is_hls_encrypt(self) -> Optional[str]:
        """
        Whether to enable HLS encryption, support encryption when Container.Format is hls.
        """
        return pulumi.get(self, "is_hls_encrypt")

    @property
    @pulumi.getter(name="uriKey")
    def uri_key(self) -> Optional[str]:
        """
        HLS encrypted key, this parameter is only meaningful when IsHlsEncrypt is true.
        """
        return pulumi.get(self, "uri_key")


@pulumi.output_type
class MediaTranscodeTemplateVideo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "longShortMode":
            suggest = "long_short_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaTranscodeTemplateVideo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaTranscodeTemplateVideo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaTranscodeTemplateVideo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[str] = None,
                 bufsize: Optional[str] = None,
                 codec: Optional[str] = None,
                 crf: Optional[str] = None,
                 fps: Optional[str] = None,
                 gop: Optional[str] = None,
                 height: Optional[str] = None,
                 long_short_mode: Optional[str] = None,
                 maxrate: Optional[str] = None,
                 pixfmt: Optional[str] = None,
                 preset: Optional[str] = None,
                 profile: Optional[str] = None,
                 remove: Optional[str] = None,
                 rotate: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str bitrate: Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        :param str bufsize: buffer size, Value range: [1000, 128000], Unit: Kb, This parameter is not supported when Codec is VP8/VP9.
        :param str codec: Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        :param str crf: Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        :param str fps: Frame rate, value range: (0, 60], Unit: fps.
        :param str gop: The maximum number of frames between key frames, value range: [1, 100000].
        :param str height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param str long_short_mode: Adaptive length,true, false, This parameter is not supported when Codec is VP8/VP9/AV1.
        :param str maxrate: Peak video bit rate, Value range: [10, 50000], Unit: Kbps, This parameter is not supported when Codec is VP8/VP9.
        :param str pixfmt: video color format, H.264 support: yuv420p, yuv422p, yuv444p, yuvj420p, yuvj422p, yuvj444p, auto, H.265 support: yuv420p, yuv420p10le, auto, This parameter is not supported when Codec is VP8/VP9/AV1.
        :param str preset: Video Algorithm Presets- H.264 supports this parameter, the values are veryfast, fast, medium, slow, slower- VP8 supports this parameter, the value is good, realtime- AV1 supports this parameter, the value is 5 (recommended value), 4- H.265 and VP9 do not support this parameter.
        :param str profile: encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        :param str remove: Whether to delete the video stream, true, false.
        :param str rotate: Rotation angle, Value range: [0, 360), Unit: degree.
        :param str width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if bufsize is not None:
            pulumi.set(__self__, "bufsize", bufsize)
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if crf is not None:
            pulumi.set(__self__, "crf", crf)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if long_short_mode is not None:
            pulumi.set(__self__, "long_short_mode", long_short_mode)
        if maxrate is not None:
            pulumi.set(__self__, "maxrate", maxrate)
        if pixfmt is not None:
            pulumi.set(__self__, "pixfmt", pixfmt)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rotate is not None:
            pulumi.set(__self__, "rotate", rotate)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def bufsize(self) -> Optional[str]:
        """
        buffer size, Value range: [1000, 128000], Unit: Kb, This parameter is not supported when Codec is VP8/VP9.
        """
        return pulumi.get(self, "bufsize")

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        Codec format, default value: `H.264`, when format is WebM, it is VP8, value range: `H.264`, `H.265`, `VP8`, `VP9`, `AV1`.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def crf(self) -> Optional[str]:
        """
        Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        """
        return pulumi.get(self, "crf")

    @property
    @pulumi.getter
    def fps(self) -> Optional[str]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def gop(self) -> Optional[str]:
        """
        The maximum number of frames between key frames, value range: [1, 100000].
        """
        return pulumi.get(self, "gop")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="longShortMode")
    def long_short_mode(self) -> Optional[str]:
        """
        Adaptive length,true, false, This parameter is not supported when Codec is VP8/VP9/AV1.
        """
        return pulumi.get(self, "long_short_mode")

    @property
    @pulumi.getter
    def maxrate(self) -> Optional[str]:
        """
        Peak video bit rate, Value range: [10, 50000], Unit: Kbps, This parameter is not supported when Codec is VP8/VP9.
        """
        return pulumi.get(self, "maxrate")

    @property
    @pulumi.getter
    def pixfmt(self) -> Optional[str]:
        """
        video color format, H.264 support: yuv420p, yuv422p, yuv444p, yuvj420p, yuvj422p, yuvj444p, auto, H.265 support: yuv420p, yuv420p10le, auto, This parameter is not supported when Codec is VP8/VP9/AV1.
        """
        return pulumi.get(self, "pixfmt")

    @property
    @pulumi.getter
    def preset(self) -> Optional[str]:
        """
        Video Algorithm Presets- H.264 supports this parameter, the values are veryfast, fast, medium, slow, slower- VP8 supports this parameter, the value is good, realtime- AV1 supports this parameter, the value is 5 (recommended value), 4- H.265 and VP9 do not support this parameter.
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        encoding level, Support baseline, main, high, auto- When Pixfmt is auto, this parameter can only be set to auto, when it is set to other options, the parameter value will be set to auto- baseline: suitable for mobile devices- main: suitable for standard resolution devices- high: suitable for high-resolution devices- Only H.264 supports this parameter.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter
    def remove(self) -> Optional[str]:
        """
        Whether to delete the video stream, true, false.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rotate(self) -> Optional[str]:
        """
        Rotation angle, Value range: [0, 360), Unit: degree.
        """
        return pulumi.get(self, "rotate")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaVideoMontageTemplateAudio(dict):
    def __init__(__self__, *,
                 codec: str,
                 bitrate: Optional[str] = None,
                 channels: Optional[str] = None,
                 remove: Optional[str] = None,
                 samplerate: Optional[str] = None):
        """
        :param str codec: Codec format, value aac, mp3.
        :param str bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param str channels: number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        :param str remove: Whether to delete the source audio stream, the value is true, false.
        :param str samplerate: Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format, value aac, mp3.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def channels(self) -> Optional[str]:
        """
        number of channels- When Codec is set to aac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def remove(self) -> Optional[str]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[str]:
        """
        Sampling Rate- Unit: Hz- Optional 11025, 22050, 32000, 44100, 48000, 96000- Different packages, mp3 supports different sampling rates, as shown in the table below.
        """
        return pulumi.get(self, "samplerate")


@pulumi.output_type
class MediaVideoMontageTemplateAudioMix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSource":
            suggest = "audio_source"
        elif key == "effectConfig":
            suggest = "effect_config"
        elif key == "mixMode":
            suggest = "mix_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaVideoMontageTemplateAudioMix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaVideoMontageTemplateAudioMix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaVideoMontageTemplateAudioMix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_source: str,
                 effect_config: Optional['outputs.MediaVideoMontageTemplateAudioMixEffectConfig'] = None,
                 mix_mode: Optional[str] = None,
                 replace: Optional[str] = None):
        """
        :param str audio_source: The media address of the audio track that needs to be mixed.
        :param 'MediaVideoMontageTemplateAudioMixEffectConfigArgs' effect_config: Mix Fade Configuration.
        :param str mix_mode: Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        :param str replace: Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        pulumi.set(__self__, "audio_source", audio_source)
        if effect_config is not None:
            pulumi.set(__self__, "effect_config", effect_config)
        if mix_mode is not None:
            pulumi.set(__self__, "mix_mode", mix_mode)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter(name="audioSource")
    def audio_source(self) -> str:
        """
        The media address of the audio track that needs to be mixed.
        """
        return pulumi.get(self, "audio_source")

    @property
    @pulumi.getter(name="effectConfig")
    def effect_config(self) -> Optional['outputs.MediaVideoMontageTemplateAudioMixEffectConfig']:
        """
        Mix Fade Configuration.
        """
        return pulumi.get(self, "effect_config")

    @property
    @pulumi.getter(name="mixMode")
    def mix_mode(self) -> Optional[str]:
        """
        Mixing mode Repeat: background sound loop, Once: The background sound is played once.
        """
        return pulumi.get(self, "mix_mode")

    @property
    @pulumi.getter
    def replace(self) -> Optional[str]:
        """
        Whether to replace the original audio of the Input media file with the mixed audio track media.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class MediaVideoMontageTemplateAudioMixEffectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgmFadeTime":
            suggest = "bgm_fade_time"
        elif key == "enableBgmFade":
            suggest = "enable_bgm_fade"
        elif key == "enableEndFadeout":
            suggest = "enable_end_fadeout"
        elif key == "enableStartFadein":
            suggest = "enable_start_fadein"
        elif key == "endFadeoutTime":
            suggest = "end_fadeout_time"
        elif key == "startFadeinTime":
            suggest = "start_fadein_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaVideoMontageTemplateAudioMixEffectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaVideoMontageTemplateAudioMixEffectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaVideoMontageTemplateAudioMixEffectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgm_fade_time: Optional[str] = None,
                 enable_bgm_fade: Optional[str] = None,
                 enable_end_fadeout: Optional[str] = None,
                 enable_start_fadein: Optional[str] = None,
                 end_fadeout_time: Optional[str] = None,
                 start_fadein_time: Optional[str] = None):
        """
        :param str bgm_fade_time: bgm transition fade-in duration, support floating point numbers.
        :param str enable_bgm_fade: Enable bgm conversion fade in.
        :param str enable_end_fadeout: enable fade out.
        :param str enable_start_fadein: enable fade in.
        :param str end_fadeout_time: fade out time, greater than 0, support floating point numbers.
        :param str start_fadein_time: Fade in duration, greater than 0, support floating point numbers.
        """
        if bgm_fade_time is not None:
            pulumi.set(__self__, "bgm_fade_time", bgm_fade_time)
        if enable_bgm_fade is not None:
            pulumi.set(__self__, "enable_bgm_fade", enable_bgm_fade)
        if enable_end_fadeout is not None:
            pulumi.set(__self__, "enable_end_fadeout", enable_end_fadeout)
        if enable_start_fadein is not None:
            pulumi.set(__self__, "enable_start_fadein", enable_start_fadein)
        if end_fadeout_time is not None:
            pulumi.set(__self__, "end_fadeout_time", end_fadeout_time)
        if start_fadein_time is not None:
            pulumi.set(__self__, "start_fadein_time", start_fadein_time)

    @property
    @pulumi.getter(name="bgmFadeTime")
    def bgm_fade_time(self) -> Optional[str]:
        """
        bgm transition fade-in duration, support floating point numbers.
        """
        return pulumi.get(self, "bgm_fade_time")

    @property
    @pulumi.getter(name="enableBgmFade")
    def enable_bgm_fade(self) -> Optional[str]:
        """
        Enable bgm conversion fade in.
        """
        return pulumi.get(self, "enable_bgm_fade")

    @property
    @pulumi.getter(name="enableEndFadeout")
    def enable_end_fadeout(self) -> Optional[str]:
        """
        enable fade out.
        """
        return pulumi.get(self, "enable_end_fadeout")

    @property
    @pulumi.getter(name="enableStartFadein")
    def enable_start_fadein(self) -> Optional[str]:
        """
        enable fade in.
        """
        return pulumi.get(self, "enable_start_fadein")

    @property
    @pulumi.getter(name="endFadeoutTime")
    def end_fadeout_time(self) -> Optional[str]:
        """
        fade out time, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "end_fadeout_time")

    @property
    @pulumi.getter(name="startFadeinTime")
    def start_fadein_time(self) -> Optional[str]:
        """
        Fade in duration, greater than 0, support floating point numbers.
        """
        return pulumi.get(self, "start_fadein_time")


@pulumi.output_type
class MediaVideoMontageTemplateContainer(dict):
    def __init__(__self__, *,
                 format: str):
        """
        :param str format: Container format: mp4, flv, hls, ts, mkv.
        """
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Container format: mp4, flv, hls, ts, mkv.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class MediaVideoMontageTemplateVideo(dict):
    def __init__(__self__, *,
                 codec: str,
                 bitrate: Optional[str] = None,
                 crf: Optional[str] = None,
                 fps: Optional[str] = None,
                 height: Optional[str] = None,
                 remove: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str codec: Codec format `H.264`.
        :param str bitrate: Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        :param str crf: Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        :param str fps: Frame rate, value range: (0, 60], Unit: fps.
        :param str height: High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        :param str remove: Whether to delete the source audio stream, the value is true, false.
        :param str width: width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if crf is not None:
            pulumi.set(__self__, "crf", crf)
        if fps is not None:
            pulumi.set(__self__, "fps", fps)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format `H.264`.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Bit rate of video output file, value range: [10, 50000], unit: Kbps, auto means adaptive bit rate.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def crf(self) -> Optional[str]:
        """
        Bit rate-quality control factor, value range: (0, 51], If Crf is set, the setting of Bitrate will be invalid, When Bitrate is empty, the default is 25.
        """
        return pulumi.get(self, "crf")

    @property
    @pulumi.getter
    def fps(self) -> Optional[str]:
        """
        Frame rate, value range: (0, 60], Unit: fps.
        """
        return pulumi.get(self, "fps")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        High, value range: [128, 4096], Unit: px, If only Height is set, Width is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def remove(self) -> Optional[str]:
        """
        Whether to delete the source audio stream, the value is true, false.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        width, value range: [128, 4096], Unit: px, If only Width is set, Height is calculated according to the original ratio of the video, must be even.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaVideoProcessTemplateColorEnhance(dict):
    def __init__(__self__, *,
                 contrast: Optional[str] = None,
                 correction: Optional[str] = None,
                 enable: Optional[str] = None,
                 saturation: Optional[str] = None):
        """
        :param str contrast: Contrast, value range: [0, 100], empty string (indicates automatic analysis).
        :param str correction: colorcorrection, value range: [0, 100], empty string (indicating automatic analysis).
        :param str enable: Whether color enhancement is turned on.
        :param str saturation: Saturation, value range: [0, 100], empty string (indicating automatic analysis).
        """
        if contrast is not None:
            pulumi.set(__self__, "contrast", contrast)
        if correction is not None:
            pulumi.set(__self__, "correction", correction)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)

    @property
    @pulumi.getter
    def contrast(self) -> Optional[str]:
        """
        Contrast, value range: [0, 100], empty string (indicates automatic analysis).
        """
        return pulumi.get(self, "contrast")

    @property
    @pulumi.getter
    def correction(self) -> Optional[str]:
        """
        colorcorrection, value range: [0, 100], empty string (indicating automatic analysis).
        """
        return pulumi.get(self, "correction")

    @property
    @pulumi.getter
    def enable(self) -> Optional[str]:
        """
        Whether color enhancement is turned on.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def saturation(self) -> Optional[str]:
        """
        Saturation, value range: [0, 100], empty string (indicating automatic analysis).
        """
        return pulumi.get(self, "saturation")


@pulumi.output_type
class MediaVideoProcessTemplateMsSharpen(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sharpenLevel":
            suggest = "sharpen_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaVideoProcessTemplateMsSharpen. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaVideoProcessTemplateMsSharpen.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaVideoProcessTemplateMsSharpen.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[str] = None,
                 sharpen_level: Optional[str] = None):
        """
        :param str enable: Whether detail enhancement is enabled.
        :param str sharpen_level: Enhancement level, value range: [0, 10], empty string (indicates automatic analysis).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sharpen_level is not None:
            pulumi.set(__self__, "sharpen_level", sharpen_level)

    @property
    @pulumi.getter
    def enable(self) -> Optional[str]:
        """
        Whether detail enhancement is enabled.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="sharpenLevel")
    def sharpen_level(self) -> Optional[str]:
        """
        Enhancement level, value range: [0, 10], empty string (indicates automatic analysis).
        """
        return pulumi.get(self, "sharpen_level")


@pulumi.output_type
class MediaVoiceSeparateTemplateAudioConfig(dict):
    def __init__(__self__, *,
                 codec: str,
                 bitrate: Optional[str] = None,
                 channels: Optional[str] = None,
                 samplerate: Optional[str] = None):
        """
        :param str codec: Codec format, value aac, mp3, flac, amr.
        :param str bitrate: Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        :param str channels: number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2- When Codec is set to amr, only 1 is supported.
        :param str samplerate: Sampling Rate- 1: Unit: Hz- 2: Optional 8000, 11025, 22050, 32000, 44100, 48000, 96000- 3: When Codec is set to aac/flac, 8000 is not supported- 4: When Codec is set to mp3, 8000 and 96000 are not supported- 5: When Codec is set to amr, only 8000 is supported.
        """
        pulumi.set(__self__, "codec", codec)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if samplerate is not None:
            pulumi.set(__self__, "samplerate", samplerate)

    @property
    @pulumi.getter
    def codec(self) -> str:
        """
        Codec format, value aac, mp3, flac, amr.
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[str]:
        """
        Original audio bit rate, unit: Kbps, Value range: [8, 1000].
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def channels(self) -> Optional[str]:
        """
        number of channels- When Codec is set to aac/flac, support 1, 2, 4, 5, 6, 8- When Codec is set to mp3, support 1, 2- When Codec is set to amr, only 1 is supported.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def samplerate(self) -> Optional[str]:
        """
        Sampling Rate- 1: Unit: Hz- 2: Optional 8000, 11025, 22050, 32000, 44100, 48000, 96000- 3: When Codec is set to aac/flac, 8000 is not supported- 4: When Codec is set to mp3, 8000 and 96000 are not supported- 5: When Codec is set to amr, only 8000 is supported.
        """
        return pulumi.get(self, "samplerate")


@pulumi.output_type
class MediaWatermarkTemplateWatermark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locMode":
            suggest = "loc_mode"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaWatermarkTemplateWatermark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaWatermarkTemplateWatermark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaWatermarkTemplateWatermark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dx: str,
                 dy: str,
                 loc_mode: str,
                 pos: str,
                 type: str,
                 end_time: Optional[str] = None,
                 image: Optional['outputs.MediaWatermarkTemplateWatermarkImage'] = None,
                 start_time: Optional[str] = None,
                 text: Optional['outputs.MediaWatermarkTemplateWatermarkText'] = None):
        """
        :param str dx: Horizontal offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ], 2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Top, Bottom and Center, the parameter is invalid.
        :param str dy: Vertical offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ],2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096],3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Left, Right and Center, the parameter is invalid.
        :param str loc_mode: Offset method, Relativity: proportional, Absolute: fixed position.
        :param str pos: Reference position, TopRight, TopLeft, BottomRight, BottomLeft, Left, Right, Top, Bottom, Center.
        :param str type: Watermark type, Text: text watermark, Image: image watermark.
        :param str end_time: Watermark end time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        :param 'MediaWatermarkTemplateWatermarkImageArgs' image: Image watermark node.
        :param str start_time: Watermark start time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        :param 'MediaWatermarkTemplateWatermarkTextArgs' text: Text Watermark Node.
        """
        pulumi.set(__self__, "dx", dx)
        pulumi.set(__self__, "dy", dy)
        pulumi.set(__self__, "loc_mode", loc_mode)
        pulumi.set(__self__, "pos", pos)
        pulumi.set(__self__, "type", type)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def dx(self) -> str:
        """
        Horizontal offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ], 2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Top, Bottom and Center, the parameter is invalid.
        """
        return pulumi.get(self, "dx")

    @property
    @pulumi.getter
    def dy(self) -> str:
        """
        Vertical offset, 1: In the picture watermark, if Background is true, when locMode is Relativity, it is %, value range: [-300 0]; when locMode is Absolute, it is px, value range: [-4096 0] ],2: In the picture watermark, if Background is false, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096],3: In text watermark, when locMode is Relativity, it is %, value range: [0 100]; when locMode is Absolute, it is px, value range: [0 4096], 4: When Pos is Left, Right and Center, the parameter is invalid.
        """
        return pulumi.get(self, "dy")

    @property
    @pulumi.getter(name="locMode")
    def loc_mode(self) -> str:
        """
        Offset method, Relativity: proportional, Absolute: fixed position.
        """
        return pulumi.get(self, "loc_mode")

    @property
    @pulumi.getter
    def pos(self) -> str:
        """
        Reference position, TopRight, TopLeft, BottomRight, BottomLeft, Left, Right, Top, Bottom, Center.
        """
        return pulumi.get(self, "pos")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Watermark type, Text: text watermark, Image: image watermark.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Watermark end time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.MediaWatermarkTemplateWatermarkImage']:
        """
        Image watermark node.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Watermark start time, 1: [0 video duration], 2: unit is second, 3: support float format, execution accuracy is accurate to milliseconds.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.MediaWatermarkTemplateWatermarkText']:
        """
        Text Watermark Node.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class MediaWatermarkTemplateWatermarkImage(dict):
    def __init__(__self__, *,
                 background: str,
                 mode: str,
                 transparency: str,
                 url: str,
                 height: Optional[str] = None,
                 width: Optional[str] = None):
        """
        :param str background: Whether the background image.
        :param str mode: Size mode, Original: original size, Proportion: proportional, Fixed: fixed size.
        :param str transparency: Transparency, value range: [1 100], unit %.
        :param str url: Address of watermark map (pass in after Urlencode is required).
        :param str height: High, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        :param str width: Width, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        """
        pulumi.set(__self__, "background", background)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "transparency", transparency)
        pulumi.set(__self__, "url", url)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def background(self) -> str:
        """
        Whether the background image.
        """
        return pulumi.get(self, "background")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Size mode, Original: original size, Proportion: proportional, Fixed: fixed size.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def transparency(self) -> str:
        """
        Transparency, value range: [1 100], unit %.
        """
        return pulumi.get(self, "transparency")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Address of watermark map (pass in after Urlencode is required).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def height(self) -> Optional[str]:
        """
        High, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[str]:
        """
        Width, 1: When the Mode is Original, it does not support setting the width of the watermark image, 2: When the Mode is Proportion, the unit is %, the value range of the background image: [100 300]; the value range of the foreground image: [1 100], relative to Video width, up to 4096px, 3: When Mode is Fixed, the unit is px, value range: [8, 4096], 4: If only Width is set, Height is calculated according to the proportion of the watermark image.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class MediaWatermarkTemplateWatermarkText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontColor":
            suggest = "font_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "fontType":
            suggest = "font_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MediaWatermarkTemplateWatermarkText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MediaWatermarkTemplateWatermarkText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MediaWatermarkTemplateWatermarkText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_color: str,
                 font_size: str,
                 font_type: str,
                 text: str,
                 transparency: str):
        """
        :param str font_color: Font color, format: 0xRRGGBB.
        :param str font_size: Font size, value range: [5 100], unit px.
        :param str font_type: font type.
        :param str text: Watermark content, the length does not exceed 64 characters, only supports Chinese, English, numbers, _, - and *.
        :param str transparency: Transparency, value range: [1 100], unit %.
        """
        pulumi.set(__self__, "font_color", font_color)
        pulumi.set(__self__, "font_size", font_size)
        pulumi.set(__self__, "font_type", font_type)
        pulumi.set(__self__, "text", text)
        pulumi.set(__self__, "transparency", transparency)

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> str:
        """
        Font color, format: 0xRRGGBB.
        """
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> str:
        """
        Font size, value range: [5 100], unit px.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> str:
        """
        font type.
        """
        return pulumi.get(self, "font_type")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        Watermark content, the length does not exceed 64 characters, only supports Chinese, English, numbers, _, - and *.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def transparency(self) -> str:
        """
        Transparency, value range: [1 100], unit %.
        """
        return pulumi.get(self, "transparency")


