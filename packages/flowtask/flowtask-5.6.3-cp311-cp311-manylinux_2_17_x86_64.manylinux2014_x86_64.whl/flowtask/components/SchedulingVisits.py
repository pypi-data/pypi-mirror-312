from collections.abc import Callable
import asyncio
from datetime import datetime, date, timedelta
import numpy as np
import pandas as pd
import calendar
import requests
from sklearn.neighbors import BallTree
from geopy.distance import geodesic  # For calculating distances
from ..exceptions import DataNotFound, ComponentError, ConfigError
from .flow import FlowComponent


# OSRM base URL for routing requests
OSRM_BASE_URL = "http://router.project-osrm.org"

class SchedulingVisits(FlowComponent):
    """Generating the Schedule of Employee Visits.

    Overview:
        The SchedulingVisits class is a component for generating a schedule of employee visits based on a set of
        rules and constraints. This component can be used to optimize the order of visits, minimize travel time,
        and balance workloads across employees. The schedule is generated by solving a combinatorial optimization
        problem with support for custom objective functions and constraints.

        Example of row consumed:
        ```
        associate_oid -> object -> G3Q86F5E1JXN1XVM
        corporate_email -> object -> buko@trocglobal.com
        employee_position -> object -> (3442724.8764311927, -10973885.176252203)
        store_id -> object -> BBY0178
        store_position -> object -> (3564143.804984759, -10887222.41833608)
        visit_rule -> int64 -> 2
        visit_category -> object -> Monthly
        ```
    """
    def __init__(
        self,
        loop: asyncio.AbstractEventLoop = None,
        job: Callable = None,
        stat: Callable = None,
        **kwargs,
    ):
        # TODO: add support for Masks
        # total hours worked per day
        self.day_duration: float = kwargs.pop('day_duration', 8.0)
        # 60% of the day in store
        self.in_store_percentage: float = kwargs.pop('in_store_percentage', 0.6)
        # near to 45 minutes in store
        self.in_store_visit: float = kwargs.pop('in_store_visit', 0.75)
        self.max_stores: int = kwargs.pop('max_stores', 4)
        # no more than 600 miles covered at day
        self.max_distance: int = kwargs.pop('max_distance', 600)
        # Average Speed:
        self.average_speed: float = kwargs.pop('average_speed', 40)
        # calculate year and month of current day:
        today = date.today()
        self._today = today
        self.year: int = kwargs.pop('year', today.year)
        self.month: int = kwargs.pop('month', today.month)
        super(SchedulingVisits, self).__init__(
            loop=loop,
            job=job,
            stat=stat,
            **kwargs
        )

    def _get_fdom(self, year, month):
        """Function to get the first Monday of a given month
        (which is Labor Day in the US)."""
        cal = calendar.Calendar()
        first_monday = None
        for day in cal.itermonthdays2(year, month):
            if day[0] != 0 and day[1] == 0:  # day[1] == 0 means Monday
                first_monday = day[0]
                break
        return datetime(year, month, first_monday)

    def get_distance(self, coord1, coord2):
        """Function to calculate distance
        between two points (latitude, longitude)."""
        return geodesic(coord1, coord2).miles

    def to_miles(self, distance) -> float:
        return distance * 0.621371  # Convert to miles

    def to_hours(self, minutes) -> float:
        return minutes / 60  # Convert to hours

    def get_labor_days(self, year: int = 2024, month: int = 9):
        """Function to get all workdays (Monday to Friday) in a given month."""
        # Get first Labor Day (first Monday) of the month
        labor_day = self._get_fdom(year, month)
        # Generate list of weekdays (excluding weekends) starting from Labor Day
        workdays = []
        current_day = labor_day
        while current_day.month == month:
            if current_day.weekday() < 5:  # Only Monday to Friday (weekday < 5)
                workdays.append(current_day)
            current_day += timedelta(days=1)
        return workdays

    def get_travel(self, waypoints, transportation: str = 'driving'):
        # Build the request URL for OSRM driving route
        # including all waypoints
        osrm_url = f"{OSRM_BASE_URL}/route/v1/{transportation}/{waypoints}?overview=false"
        # Send the request to OSRM API
        response = requests.get(osrm_url)
        # Check if the request was successful
        if response.status_code == 200:
            route_data = response.json()
            # Extract total travel duration and distance (in seconds and meters)
            # Total duration
            duration_seconds = route_data['routes'][0]['duration']
            # Total distance
            distance_meters = route_data['routes'][0]['distance']
            # Convert to more readable formats
            duration_minutes = duration_seconds / 60
            distance_km = distance_meters / 1000
            return duration_minutes, distance_km
        else:
            return 0, 0

    def get_travel_duration(self, origin, destination):
        """Helper function to get distance and duration between two points.
        """
        waypoints = f"{origin[1]},{origin[0]};{destination[1]},{destination[0]}"
        duration_minutes, distance_km = self.get_travel(waypoints, transportation='driving')
        distance_miles = self.to_miles(distance_km)
        return distance_miles, duration_minutes

    async def start(self, **kwargs):
        if self.previous:
            self.data: pd.DataFrame = self.input
            if not isinstance(self.data, pd.DataFrame):
                raise ConfigError(
                    "Incompatible Pandas Dataframe", status=404
                )
        else:
            raise DataNotFound(
                "Data Not Found", status=404
            )
        await super().start(**kwargs)
        return True

    async def close(self):
        pass

    async def run(self):
        self._logger.debug('=== RUNNING FUNCTION SCHEDULING VISITS ===')

        # Get workdays
        workdays = self.get_labor_days(self.year, self.month)

        # Initialize a dictionary to keep track of assignments and exceptions
        schedule_rows = []
        exception_rows = []

        # Group the data by employee
        employee_groups = self.data.groupby('associate_oid')

        for employee_id, employee_data in employee_groups:
            # Get employee information
            employee_info = employee_data.iloc[0]
            employee_email = employee_info['corporate_email']
            # (latitude, longitude) of the employee's position
            employee_position = employee_info['employee_position']

            # Get unique stores for the employee
            unvisited_stores = employee_data.drop_duplicates('store_id').reset_index(drop=True)

            # Prepare store positions
            store_positions = np.array([store for store in unvisited_stores['store_position']])
            store_positions_rad = np.radians(store_positions)

            self._logger.notice(
                f"Generating schedule for: {employee_email} ({employee_position}) for {len(store_positions)} stores."
            )

            # Build initial BallTree
            if len(store_positions) > 0:
                tree = BallTree(store_positions_rad, metric='haversine')
            else:
                # No stores to visit
                continue

            # Initialize list to store the employee's schedule
            employee_schedule = []

            # Keep track of visited stores
            visited_store_ids = set()

            # Iterate over workdays
            for day in workdays:
                day_schedule = {
                    'associate_oid': employee_id,
                    'corporate_email': employee_email,
                    'start_position': employee_position,
                    'day': day,
                    'month': self.month,
                    'year': self.year,
                    'total_time_minutes': 0,
                    'total_time_hours': 0,
                    'total_in_store_time': 0,
                    'total_travel_time': 0,
                    'total_distance': 0,
                    'visited_stores': {}
                }
                # Initialize day parameters
                current_time = 0  # in minutes
                current_distance = 0  # in miles
                total_in_store_time = 0  # in minutes
                total_travel_time = 0  # in minutes
                stores_visited = 0
                current_position = employee_position

                while True:
                    # Check if constraints are met
                    if current_time >= self.day_duration * 60 or \
                       current_distance >= self.max_distance or \
                       stores_visited >= self.max_stores or \
                       len(unvisited_stores) == 0:
                        break  # Cannot add more stores today

                    # Convert current position to radians
                    current_position_rad = np.radians([current_position])

                    # Query the nearest unvisited store
                    distances, indices = tree.query(current_position_rad, k=1)

                    # Extract nearest store information
                    nearest_index = indices[0][0]
                    nearest_distance_rad = distances[0][0]
                    nearest_distance_km = nearest_distance_rad * 6371  # Earth's radius in km
                    nearest_distance_miles = nearest_distance_km * 0.621371  # Convert km to miles
                    nearest_store = unvisited_stores.iloc[nearest_index]

                    # Calculate travel time (assuming average speed of 60 mph)
                    travel_time = (nearest_distance_miles / self.average_speed) * 60  # in minutes

                    # Total time if we add this store
                    time_in_store = self.in_store_visit * 60  # in minutes
                    potential_total_time = current_time + travel_time + time_in_store

                    # Check constraints
                    if potential_total_time > self.day_duration * 60 or \
                       current_distance + nearest_distance_miles > self.max_distance:
                        break  # Constraints exceeded

                    # Update day parameters
                    current_time = potential_total_time
                    current_distance += nearest_distance_miles
                    current_position = nearest_store['store_position']
                    total_in_store_time += time_in_store
                    total_travel_time += travel_time
                    stores_visited += 1

                    # Add store to day's schedule
                    store_entry = {
                        'store_id': nearest_store['store_id'],
                        'store_name': nearest_store.get('store_name', 'Unknown'),
                        'latitude': current_position[0],
                        'longitude': current_position[1],
                        'visit_rule': nearest_store.get('visit_rule', None),
                        'visit_category': nearest_store.get('visit_category', None)
                    }
                    day_schedule['visited_stores'][nearest_store['store_id']] = store_entry

                    # Mark store as visited
                    visited_store_ids.add(nearest_store['store_id'])

                    # Remove store from unvisited stores
                    unvisited_stores = unvisited_stores.drop(nearest_store.name).reset_index(drop=True)

                    # Rebuild the tree if there are stores left
                    if len(unvisited_stores) > 0:
                        store_positions = np.array([list(pos) for pos in unvisited_stores['store_position']])
                        store_positions_rad = np.radians(store_positions)
                        tree = BallTree(store_positions_rad, metric='haversine')
                    else:
                        break  # No more stores to visit

                if day_schedule['visited_stores']:
                    # Record the day's schedule
                    day_schedule['total_distance'] = current_distance
                    day_schedule['total_time_minutes'] = current_time
                    day_schedule['total_time_hours'] = current_time / 60
                    day_schedule['total_in_store_time'] = total_in_store_time
                    day_schedule['total_travel_time'] = total_travel_time
                    schedule_rows.append(day_schedule)

                # Stop if no more stores to visit
                if len(unvisited_stores) == 0:
                    break

            # Handle unvisited stores
            if len(unvisited_stores) > 0:
                for _, store_row in unvisited_stores.iterrows():
                    exception_row = {
                        'associate_oid': employee_id,
                        'corporate_email': employee_email,
                        'year': self.year,
                        'month': self.month,
                        'store_id': store_row['store_id'],
                        'store_name': store_row.get('store_name', 'Unknown'),
                        'store_position': store_row['store_position']
                    }
                    exception_rows.append(exception_row)

        # Save the schedule for the employee
        schedule_df = pd.DataFrame(schedule_rows)
        exception_stores_df = pd.DataFrame(exception_rows)

        # Set the final results
        self.schedule_df = schedule_df
        self.exception_stores_df = exception_stores_df

        print(' === Visit Schedule === ')
        print(schedule_df.head())
        print('=== Exception Stores ====')
        print(exception_stores_df.head())

        self._result = schedule_df

        self._print_data_(self._result, 'Schedule')

        return self._result
