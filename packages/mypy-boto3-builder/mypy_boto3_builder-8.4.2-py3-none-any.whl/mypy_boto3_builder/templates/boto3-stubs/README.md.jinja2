{% include "common/header.md.jinja2" with context %}

{% include "common/how_to_install.md.jinja2" with context %}

{% with extras_name="essential" %}
{% include "common/usage.md.jinja2" with context %}
{% endwith %}

### Explicit type annotations

To speed up type checking and code completion, you can set types explicitly.

```python
import boto3
from boto3.session import Session

from {{ package.data.SERVICE_PREFIX }}_ec2.client import EC2Client
from {{ package.data.SERVICE_PREFIX }}_ec2.service_resource import EC2ServiceResource
from {{ package.data.SERVICE_PREFIX }}_ec2.waiter import BundleTaskCompleteWaiter
from {{ package.data.SERVICE_PREFIX }}_ec2.paginator import DescribeVolumesPaginator

session = Session(region_name="us-west-1")

ec2_client: EC2Client = boto3.client("ec2", region_name="us-west-1")
ec2_resource: EC2ServiceResource = session.resource("ec2")

bundle_task_complete_waiter: BundleTaskCompleteWaiter = ec2_client.get_waiter("bundle_task_complete")
describe_volumes_paginator: DescribeVolumesPaginator = ec2_client.get_paginator("describe_volumes")
```

### Pylint compatibility

It is totally safe to use `TYPE_CHECKING` flag in order to avoid `{{ package.pypi_name }}`
dependency in production.
However, there is an issue in `pylint` that it complains about undefined
variables. To fix it, set all types to `object` in non-`TYPE_CHECKING` mode.

```python
import boto3
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from {{ package.data.SERVICE_PREFIX }}_ec2 import EC2Client, EC2ServiceResource
    from {{ package.data.SERVICE_PREFIX }}_ec2.waiters import BundleTaskCompleteWaiter
    from {{ package.data.SERVICE_PREFIX }}_ec2.paginators import DescribeVolumesPaginator
else:
    EC2Client = object
    EC2ServiceResource = object
    BundleTaskCompleteWaiter = object
    DescribeVolumesPaginator = object

...
```

{% include "common/footer.md.jinja2" with context %}

{% include "common/submodules.md.jinja2" with context %}
