from collections import defaultdict
from varphi_types import *

from .VarphiLexer import VarphiLexer
from .VarphiParser import VarphiParser
from .VarphiListener import VarphiListener
from .VarphiSyntaxErrorListener import VarphiSyntaxErrorListener, VarphiSyntaxError

TALLY_CHARACTERS = {'1'}
BLANK_CHARACTERS = {'b'}
LEFT_CHARACTERS = {'L'}
RIGHT_CHARACTERS = {'R'}


class VarphiRepresentor(VarphiListener):
    """
    This class translates the tokens generated by VarphiParser into model
    objects.
    """
    stateNameToObject: dict[str, State]
    initialState: State | None
    positionToObject: defaultdict[tuple[int, int], State | HeadDirection | TapeCharacter | Comment]
    positionRangeToObject: defaultdict[tuple[tuple[int, int], tuple[int, int]], State | HeadDirection | TapeCharacter | Comment]

    def __init__(self):
        """
        Initializes the VarphiEvaluator.
        Sets up a mapping of state names to State objects and initializes
        the initial state to None.
        """
        self.stateNameToObject = {}
        self.initialState = None
        self.positionToObject = defaultdict(lambda: None)
        self.positionRangeToObject = defaultdict(lambda: None)
        super().__init__()

    def enterLine(self, ctx: VarphiParser.LineContext) -> None:
        """
        Enter a parse tree produced by VarphiParser#line.
        Processes the parse tree nodes to extract state transitions and
        instructions.

        Args:
            - ctx (VarphiParser.LineContext): The context for the parse tree
              node.
        """
        ifStateString = str(ctx.STATE(0).getText())
        ifCharacterString = str(ctx.SYMBOL(0).getText())
        thenStateString = str(ctx.STATE(1).getText())
        thenCharacterString = str(ctx.SYMBOL(1).getText())
        thenDirectionString = str(ctx.DIRECTION().getText())

        ifStateToken = ctx.STATE(0).getSymbol()
        ifStateStartLine = ifStateToken.line
        ifStateStartColumn = ifStateToken.column
        ifStateEndColumn = ifStateStartColumn + len(ifStateString) - 1

        ifCharacterToken = ctx.SYMBOL(0).getSymbol()
        ifCharacterStartLine = ifCharacterToken.line
        ifCharacterStartColumn = ifCharacterToken.column
        ifCharacterEndColumn = ifCharacterStartColumn + len(ifCharacterString) - 1

        thenStateToken = ctx.STATE(1).getSymbol()
        thenStateStartLine = thenStateToken.line
        thenStateStartColumn = thenStateToken.column
        thenStateEndColumn = thenStateStartColumn + len(thenStateString) - 1

        thenCharacterToken = ctx.SYMBOL(1).getSymbol()
        thenCharacterStartLine = thenCharacterToken.line
        thenCharacterStartColumn = thenCharacterToken.column
        thenCharacterEndColumn = thenCharacterStartColumn + len(thenCharacterString) - 1

        thenDirectionToken = ctx.DIRECTION().getSymbol()
        thenDirectionStartLine = thenDirectionToken.line
        thenDirectionStartColumn = thenDirectionToken.column
        thenDirectionEndColumn = thenDirectionStartColumn + len(thenDirectionString) - 1


        if ifStateString in self.stateNameToObject:
            ifStateObject = self.stateNameToObject[ifStateString]
        else:
            ifStateObject = State(ifStateString)
            self.stateNameToObject[ifStateString] = ifStateObject

            if self.initialState is None:
                self.initialState = ifStateObject
        
        ifStateObject.references.append((ifStateStartLine, (ifStateStartColumn, ifStateEndColumn)))
        ifStateObject.implementations.append((ifStateStartLine, (ifStateStartColumn, ifStateEndColumn)))
        for i in range(ifStateStartColumn, ifStateEndColumn + 1):
            self.positionToObject[ifStateStartLine, i] = ifStateObject
        self.positionRangeToObject[((ifStateStartLine, ifStateStartColumn), (ifStateStartLine, ifStateEndColumn))] = ifStateObject
        

        if ifCharacterString in TALLY_CHARACTERS:
            ifCharacterObject = TapeCharacter.TALLY
        else:
            ifCharacterObject = TapeCharacter.BLANK
        
        for i in range(ifCharacterStartColumn, ifCharacterEndColumn + 1):
            self.positionToObject[ifCharacterStartLine, i] = ifCharacterObject
        self.positionRangeToObject[((ifCharacterStartLine, ifCharacterStartColumn), (ifCharacterStartLine, ifCharacterEndColumn))] = ifCharacterObject

        if thenStateString in self.stateNameToObject:
            thenStateObject = self.stateNameToObject[thenStateString]
        else:
            thenStateObject = State(thenStateString)
            self.stateNameToObject[thenStateString] = thenStateObject
        
        thenStateObject.references.append((thenStateStartLine, (thenStateStartColumn, thenStateEndColumn)))
        for i in range(thenStateStartColumn, thenStateEndColumn + 1):
            self.positionToObject[thenStateStartLine, i] = thenStateObject
        self.positionRangeToObject[((thenStateStartLine, thenStateStartColumn), (thenStateStartLine, thenStateEndColumn))] = thenStateObject

        if thenCharacterString in TALLY_CHARACTERS:
            thenCharacterObject = TapeCharacter.TALLY
        else:
            thenCharacterObject = TapeCharacter.BLANK

        for i in range(thenCharacterStartColumn, thenCharacterEndColumn + 1):
            self.positionToObject[thenCharacterStartLine, i] = thenCharacterObject
        self.positionRangeToObject[((thenCharacterStartLine, thenCharacterStartColumn), (thenCharacterStartLine, thenCharacterEndColumn))] = thenCharacterObject

        if thenDirectionString in RIGHT_CHARACTERS:
            thenDirectionObject = HeadDirection.RIGHT
        else:
            thenDirectionObject = HeadDirection.LEFT

        for i in range(thenDirectionStartColumn, thenDirectionEndColumn + 1):
            self.positionToObject[thenDirectionStartLine, i] = thenDirectionObject
        self.positionRangeToObject[((thenDirectionStartLine, thenDirectionStartColumn), (thenDirectionStartLine, thenDirectionEndColumn))] = thenDirectionObject

        instruction = Instruction(thenStateObject,
                                  thenCharacterObject,
                                  thenDirectionObject,
                                  ctx.start.line,
                                  f"{ctx.start.line} {ifStateString} {ifCharacterString} {thenStateString} {thenCharacterString} {thenDirectionString}")

        if ifCharacterObject == TapeCharacter.TALLY:
            ifStateObject.addOnTallyInstruction(instruction)
        else:
            ifStateObject.addOnBlankInstruction(instruction)

        if ctx.COMMENT() is not None:
            commentToken = ctx.COMMENT().getSymbol()
            commentString = str(ctx.COMMENT().getText())
            commentObject = Comment()
            commentStartLine = commentToken.line
            commentStartColumn = commentToken.column
            commentEndColumn = commentStartColumn + len(commentString) - 1
            for i in range(commentStartColumn, commentEndColumn + 1):
                self.positionToObject[commentStartLine, i] = commentObject
            self.positionRangeToObject[((commentStartLine, commentStartColumn), (commentStartLine, commentEndColumn))] = Comment()
